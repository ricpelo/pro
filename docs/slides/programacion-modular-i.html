<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Ricardo Pérez López">
  <title>Programación modular I</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="shortcut icon" type="image/png" href="/assets/icons/icon.png">
  <link rel="stylesheet" href="reveal.js/css/reset.css">
  <link rel="stylesheet" href="reveal.js/css/reveal.css">
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #cb4b16; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #d33682; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #dc322f; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #93a1a1; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #268bd2; } /* DataType */
code span.dv { color: #d33682; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #d33682; } /* Float */
code span.fu { color: #268bd2; } /* Function */
code span.im { font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #268bd2; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #a57800; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #2aa198; } /* SpecialString */
code span.st { color: #2aa198; } /* String */
code span.va { color: #6c71c4; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="reveal.js/css/theme/solarized.css" id="theme">
  <link rel="stylesheet" href="custom.css"/>
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
    var mathElements = document.getElementsByClassName("math");
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") { katex.render(texText.data, mathElements[i], { displayMode: mathElements[i].classList.contains("display"), throwOnError: false } );
    }}});</script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css" />
  <link href="https://fonts.googleapis.com/css?family=Lato&display=swap" rel="stylesheet">
  <style type="text/css">
      #header-left {
          position: absolute;
          font-size: 25%;
          top: 0%;
          left: 0%;
          margin-left: 10px;
          margin-top: 10px;
      }
      #header-right {
          position: absolute;
          font-size: 25%;
          top: 0%;
          right: 0%;
          margin-right: 10px;
          margin-top: 10px;
      }
      #footer-left {
          position: absolute;
          font-size: 25%;
          bottom: 0%;
          left: 0%;
          margin-left: 10px;
          margin-bottom: 10px;
      }
  </style>
</head>
<body>
<div id="hidden" style="display:none;">
    <div id="header">
        <div id="header-left"></div>
        <div id="header-right"></div>
        <div id="footer-left"></div>
    </div>
</div>
<script type="text/javascript">
    document.addEventListener("DOMContentLoaded", function(event) {
        var title = document.getElementsByClassName('title')[0];
        title = title != null ? title.innerHTML : '';
        var author = document.getElementsByClassName('author')[0];
        author = author != null ? author.innerHTML : '';
        var date = document.getElementsByClassName('date')[0];
        date = date != null ? date.innerHTML : '';
        var el = document.createElement('a');
        var href = '#/title-slide';
        el.href = href;
        el.innerHTML = title;
        document.getElementById('header-left').appendChild(el);
        document.getElementById('footer-left').innerHTML = '&copy; ' + author + ' (' + date + ')';

        function updateHeader(nd) {
            var hr = document.getElementById('header-right');
            while (hr.children.length > 0) {
                hr.removeChild(hr.lastChild);
            }
            buscar(nd, 3, hr);
            buscar(nd, 2, hr);
            buscar(nd, 1, hr);
            hr.style.fontSize = Math.round(50 * Reveal.getScale()) + '%';
            hr.style.fontSize = Math.max(Number.parseInt(getComputedStyle(hr).fontSize), 12) + 'px';
            var hl = document.getElementById('header-left');
            hl.style.fontSize = hr.style.fontSize;
        }

        function buscar(nd, level, hr) {
            if (!nd.classList.contains('level' + (level - 1))) {
                for (var n = nd; n != null; n = n.previousSibling) {
                    if (n.nodeType == Node.TEXT_NODE) {
                        continue;
                    }
                    var cl = n.classList;
                    if (cl.contains('level' + level)) {
                        var h = n.querySelector('h' + level);
                    } else if (cl.contains('level' + (level - 1))) {
                        break;
                    } else {
                        continue;
                    }
                    if (h == null || Reveal.getCurrentSlide().id == 'title-slide') {
                        hr.innerHTML = '';
                    } else {
                        var el = document.createElement('a');
                        var href = '#/' + n.id;
                        el.href = href;
                        el.innerHTML = h.innerHTML;
                        var a = el.querySelector('a');
                        if (a !== null) {
                            a.href = href;
                        }
                        if (hr.innerHTML != '') {
                            hr.innerHTML = ' &mdash; ' + hr.innerHTML;
                        }
                        hr.insertBefore(el, hr.firstChild);
                    }
                    break;
                }
            }
        }

        // On Reveal.js ready event, copy header/footer <div>
        // into each `.slide-background` <div>
        Reveal.addEventListener('ready', function(event) {
            var header = document.getElementById('header');
            document.querySelector('.reveal').appendChild(header);
            updateHeader(Reveal.getCurrentSlide());
        });

        Reveal.addEventListener('slidechanged', function(event) {
            // event.previousSlide, event.currentSlide, event.indexh, event.indexv
            updateHeader(event.currentSlide);
        });
    });
</script>
  <div class="reveal">
    <div class="slides">

<section>
<section id="title-slide" class="title-slide slide level1">
  <h1 class="title">Programación modular I</h1>
  <p class="author">Ricardo Pérez López</p>
  <p class="date">IES Doñana, curso 2019/2020</p>
</section>
<section id="TOC" class="slide level2">
<ul>
<li><a href="#/introducción"><span class="toc-section-number">1</span> Introducción</a></li>
<li><a href="#/diseño-modular"><span class="toc-section-number">2</span> Diseño modular</a></li>
<li><a href="#/criterios-de-descomposición-modular"><span class="toc-section-number">3</span> Criterios de descomposición modular</a></li>
<li><a href="#/abstracción-de-datos"><span class="toc-section-number">4</span> Abstracción de datos</a></li>
<li><a href="#/bibliografía">Bibliografía</a></li>
</ul>
</section>
</section>

<section><section id="introducción" class="title-slide slide level1"><h1><span class="header-section-number">1</span> Introducción</h1></section><section id="modularidad" class="title-slide slide level2"><h2><span class="header-section-number">1.1</span> Modularidad</h2><ul>
<li><p>La <strong>programación modular</strong> es una técnica de programación que consiste en descomponer y programar nuestro programa en partes llamadas <strong>módulos</strong>.</p>
<ul>
<li>El concepto de <em>módulo</em> hay que entenderlo en sentido amplio: cualquier parte de un programa se puede considerar «módulo».</li>
</ul></li>
<li><p>Equivale a la técnica clásica de resolución de problemas basada en 1) descomponer un problema en subproblemas; 2) resolver cada subproblema por separado; y 3) combinar las soluciones para así obtener la solución al problema original.</p></li>
<li><p>La <strong>modularidad</strong> es la propiedad que tienen los programas escritos siguiendo los principios de la programación modular.</p></li>
<li><p>El concepto de modularidad se puede estudiar a nivel <em>metodológico</em> y a nivel <em>práctico</em>.</p></li>
</ul></section><section class="slide level4">

<ul>
<li><p><strong>A nivel metodológico</strong>, la modularidad nos proporciona una herramienta más para controlar la complejidad de forma similar a como lo hace la abstracción.</p></li>
<li><p>Todos los mecanismos de control de la complejidad actúan de la misma forma: la mente humana es incapaz de mantener la atención en muchas cosas a la vez, así que lo que hacemos es centrarnos en una parte del problema y dejamos a un lado el resto momentáneamente.</p>
<ul>
<li><p>La <strong>abstracción</strong> nos permite controlar la complejidad permitiéndonos estudiar un problema o su solución por niveles, centrándonos en lo esencial e ignorando los detalles que a ese nivel resultan innecesarios.</p></li>
<li><p>Con la <strong>modularidad</strong> buscamos descomponer conceptualmente el programa en partes que se puedan estudiar y programar por separado, de forma más o menos independiente, lo que se denomina <strong>descomposición lógica</strong>.</p></li>
</ul></li>
</ul>
<!--
- Si fuera posible, también nos interesa que los módulos sean lo
  suficientemente genéricos como para que se se puedan reutilizar en otros
  programas. -->
</section><section class="slide level4">

<ul>
<li><p><strong>A nivel práctico</strong>, la modularidad nos ofrece una herramienta que nos permite partir el programa en partes más manejables.</p></li>
<li><p>A medida que los programas se hacen más y más grandes, el esfuerzo de mantener todo el código dentro de un único <em>script</em> se hace mayor.</p></li>
<li><p>No sólo resulta incómodo mantener todo el código en un mismo archivo, sino que además resulta intelectualmente más difícil de entender.</p></li>
<li><p>Lo más práctico es descomponer físicamente nuestro programa en una colección de archivos fuente que se puedan trabajar por separado, lo que se denomina <strong>descomposición física</strong>.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Un módulo es, pues, una parte de un programa que se puede estudiar, entender y programar por separado con relativa independencia del resto del programa.</p></li>
<li><p>Por tanto, podríamos considerar que una función es un ejemplo de módulo, ya que se ajusta a esa definición (salvo quizás que no habría <em>descomposición física</em>, aunque se podría colocar cada función en un archivo separado y entonces sí).</p></li>
<li><p>Sin embargo, descomponer un programa en partes usando únicamente como criterio la descomposición funcional no resulta adecuado en general, ya que muchas veces nos encontramos con funciones que no actúan por separado, sino de forma conjunta formando un todo interrelacionado.</p></li>
<li><p>Además, un módulo no tiene por qué ser simplemente una abstracción funcional, sino que también puede tener su propio estado interno en forma de datos (variables) manipulables desde dentro del módulo pero también desde fuera.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Por ejemplo, supongamos un conjunto de funciones que manipulan números racionales.</p></li>
<li><p>Tendríamos funciones para crear racionales, para sumarlos, para multiplicarlos, para simplificarlos… Y todas esas funciones trabajarían conjuntamente, actuando sobre la misma colección de datos (la representación interna que usa el módulo para implementar los números racionales).</p></li>
<li><p>Esos datos (es decir, esa representación interna) también formarían parte del módulo y constituirían su estado interno.</p></li>
<li><p>Por consiguiente, aunque resulta muy apropiado considerar cada función anterior por separado, también resulta evidente que debemos considerarlas como formando un todo conjunto con los datos que manipulan: el <em>módulo de manipulación de números racionales</em>.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>De lo dicho hasta ahora se deducen varias conclusiones importantes:</p>
<ul>
<li><p>Un módulo es una parte del programa.</p></li>
<li><p>Los módulos nos permiten descomponer el programa en <strong>partes independientes y manejables por separado</strong>.</p></li>
<li><p>Una función, en general, no es una candidata con suficiente entidad como para ser considerada un módulo.</p></li>
<li><p>Los módulos, en general, agrupan colecciones de <strong>funciones interrelacionadas</strong>.</p></li>
<li><p>Los módulos, en general, también poseen un <strong>estado interno</strong> en forma de estructuras de datos, manipulable desde el interior del módulo así como desde el exterior del mismo usando las funciones que forman el módulo.</p></li>
<li><p>A nivel práctico, los módulos se programan físicamente en <strong>archivos separados</strong> del resto del programa.</p></li>
</ul></li>
</ul>
</section><section id="beneficios-de-la-programación-modular" class="title-slide slide level2"><h2><span class="header-section-number">1.2</span> Beneficios de la programación modular</h2><ul>
<li><p>El tiempo de desarrollo se reduce porque grupos separados de programadores pueden trabajar cada uno en un módulo con poca necesidad de comunicación entre ellos.</p></li>
<li><p>Se mejora la productividad del producto resultante, porque los cambios (pequeños o grandes) realizados en un módulo no afectarían demasiado a los demás.</p></li>
<li><p>Comprensibilidad, porque se puede entender mejor el sistema completo cuando se puede estudiar módulo a módulo en lugar de tener que estudiarlo todo a la vez.</p></li>
</ul></section></section>
<section><section id="diseño-modular" class="title-slide slide level1"><h1><span class="header-section-number">2</span> Diseño modular</h1></section><section id="partes-de-un-módulo" class="title-slide slide level2"><h2><span class="header-section-number">2.1</span> Partes de un módulo</h2><ul>
<li><p>Desde la perspectiva de la programación modular, un programa está formado por una colección de módulos que interactúan entre sí.</p></li>
<li><p>Puede decirse que un módulo proporciona una serie de <em>servicios</em> que son <em>usados</em> o <em>consumidos</em> por otros módulos del programa.</p></li>
<li><p>Así que podemos estudiar el diseño de un módulo desde <strong>dos puntos de vista complementarios</strong>:</p>
<ul>
<li><p>El <strong>creador</strong> o <strong>implementador</strong> del módulo es la persona encargada de la programación del mismo y, por tanto, debe conocer todos los detalles internos al módulo, necesarios para que éste funcione (es decir, su <strong>implementación</strong>).</p></li>
<li><p>Los <strong>usuarios</strong> del módulo son los programadores que desean usar ese módulo en sus programas. También se les llama así a los módulos de un programa que usan a ese módulo (lo necesitan para funcionar).</p>
<p>A la parte que un usuario necesita conocer para poder usar el módulo se le denomina la <strong>interfaz</strong> del módulo.</p></li>
</ul></li>
</ul></section><section class="slide level4">

<div class="caja">
<p>Los <strong>usuarios</strong> están interesados en usar al módulo como una <strong>entidad abstracta</strong> sin necesidad de conocer los <em>detalles internos</em> del mismo, sino sólo lo necesario para poder consumir los servicios que proporciona (su <strong>interfaz</strong>).</p>
</div>
</section><section class="slide level4">

<ul>
<li><p>Concretando, un módulo tendrá:</p>
<ul>
<li><p>Un <strong>nombre</strong> (que generalmente coincidirá con el nombre del archivo en el que reside).</p></li>
<li><p>Una <strong>interfaz</strong>, formada por un conjunto de <strong>especificaciones de funciones</strong> que permiten al usuario consumir sus servicios, así como manipular y acceder al estado interno desde fuera del módulo.</p>
<p>Es posible que la interfaz también incluya <strong>constantes</strong>.</p></li>
<li><p>Una <strong>implementación</strong>, formada por:</p>
<ul>
<li><p>Su posible estado interno en forma de <strong>variables</strong> locales al módulo.</p></li>
<li><p>Un conjunto de <strong>funciones auxiliares</strong> pensadas para ser usadas exclusivamente por el propio módulo de manera interna, pero no por otras partes del programa.</p></li>
</ul></li>
</ul></li>
</ul>
</section><section id="interfaz" class="title-slide slide level3"><h3><span class="header-section-number">2.1.1</span> Interfaz</h3><ul>
<li><p>La <strong>interfaz</strong> es la parte del módulo que el <strong>usuario</strong> del mismo necesita conocer para poder utilizarlo.</p></li>
<li><p>Es la parte <strong>expuesta, pública o visible</strong> del mismo.</p></li>
<li><p>También se la denomina su <strong>API</strong> (<em>Application Program Interface</em>).</p></li>
<li><p>Debería estar perfectamente <strong>documentada</strong> para que cualquier potencial usuario tenga toda la información necesaria para poder usar el módulo sin tener que conocer o acceder a partes internas del mismo.</p></li>
<li><p>En general <strong>debería estar formada únicamente por funciones</strong> (y, tal vez, <strong>constantes</strong>) que el usuario del módulo pueda llamar para consumir los servicios que ofrece el módulo.</p></li>
<li><p>Esas funciones deben usarse como <em>abstracciones funcionales</em>, de forma que el usuario sólo necesite conocer las <strong>especificaciones</strong> de las funciones y no sus <em>implementaciones</em> concretas (el <em>cuerpo</em> o código de las funciones).</p></li>
</ul></section><section class="slide level4">

<ul>
<li><p>Acabamos de decir que la interfaz de un módulo debería estar formada únicamente por <strong>funciones</strong> (y, tal vez, <em>constantes</em>).</p></li>
<li><p>En teoría, la interfaz podría estar formada también por (algunas o todas las) <strong>variables locales al módulo</strong>, pero en la práctica eso no resulta apropiado, ya que cualquier cambio posterior en la representación interna de los datos almacenados en esas variables afectaría al resto de los módulos que acceden a dichas variables.</p>
<p>Más adelante estudiaremos este aspecto en profundidad cuando hablemos del <strong>principio de ocultación de información</strong>.</p></li>
</ul>
</section><section id="implementación" class="title-slide slide level3"><h3><span class="header-section-number">2.1.2</span> Implementación</h3><ul>
<li><p>La <strong>implementación</strong> es la parte del módulo que queda <strong>oculta a los usuarios</strong> del mismo.</p></li>
<li><p>Es decir: es la parte que los usuarios del módulo no necesitan (ni deben) conocer para poder usarlo adecuadamente.</p></li>
<li><p>Está formada por todas las <strong>variables locales al módulo</strong> que almacenan su estado interno, junto con las funciones que utiliza el propio módulo para gestionarse a sí mismo y que no forman parte de su interfaz (<strong>funciones <em>auxiliares</em></strong>).</p></li>
<li><p>La implementación debe poder cambiarse tantas veces como sea necesario sin que por ello se tenga que cambiar el resto del programa.</p></li>
</ul></section><section id="diagramas-de-estructura" class="title-slide slide level2"><h2><span class="header-section-number">2.2</span> Diagramas de estructura</h2><ul>
<li><p>Los diferentes módulos que forman un programa y la relación que hay entre ellos se puede representar gráficamente mediante un <em>diagrama de descomposición modular</em> o <strong>diagrama de estructura</strong>.</p></li>
<li><p>En el diagrama de estructura, cada módulo se representa mediante un rectángulo y las relaciones entre cada par de módulos se dibujan como una línea con punta de flecha entre los dos módulos.</p></li>
<li><p>Una flecha dirigida del módulo <em>A</em> al módulo <em>B</em> representa que el módulo <em>A</em> <em>utiliza</em> o <em>llama</em> o <em>depende</em> del módulo <em>B</em>.</p></li>
</ul>
<div class="centered">
<figure>
<img data-src="images/modulos-dependientes.svg" class="plain" style="width:30.0%" alt="" /><figcaption><em>A</em> depende de <em>B</em></figcaption>
</figure>
</div></section><section class="slide level4">

<div class="centered">
<figure>
<img data-src="images/diagrama-estructura.svg" class="plain" style="width:40.0%" alt="" /><figcaption>Diagrama de estructura</figcaption>
</figure>
</div>
</section><section id="programación-modular-en-python" class="title-slide slide level2"><h2><span class="header-section-number">2.3</span> Programación modular en Python</h2><ul>
<li><p>En Python, un módulo es otra forma de llamar a un <em>script</em>. Es decir: «módulo» y «<em>script</em>» son sinónimos en Python.</p></li>
<li><p>Los módulos contienen definiciones y sentencias.</p></li>
<li><p>El nombre del archivo es el nombre del módulo con extensión <code>.py</code>.</p></li>
<li><p>Dentro de un módulo, el nombre del módulo (como cadena) se encuentra almacenado en la variable global <code>__name__</code>.</p></li>
<li><p>Cada módulo tiene su propio ámbito local, que es usado como el ámbito global de todas las funciones definidas en el módulo.</p></li>
<li><p>Por tanto, el autor de un módulo puede usar variables globales en el módulo sin preocuparse de posibles colisiones accidentales con las variables globales de otros módulos.</p></li>
</ul></section><section id="importación-de-módulos" class="title-slide slide level3"><h3><span class="header-section-number">2.3.1</span> Importación de módulos</h3><ul>
<li><p>Para que un módulo pueda usar a otros módulos tiene que <strong>importarlos</strong> usando la orden <code>import</code>. Por ejemplo, la siguiente sentencia importa el módulo <code>math</code> dentro del módulo actual:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">import</span> math</span></code></pre></div></li>
<li><p>Al importar un módulo de esta forma, lo que se hace es incorporar la definición del propio módulo (el módulo <em>importado</em>) en el ámbito actual del módulo o <em>script</em> que ejecuta el <code>import</code> (el módulo <em>importador</em>).</p></li>
<li><p>O dicho de otra forma: se incorpora al marco actual (es decir, el marco del ámbito donde se ejecuta el <code>import</code>) la ligadura entre el nombre del módulo importado y el propio módulo, por lo que el módulo importador puede acceder al módulo importado a través de su nombre.</p></li>
<li><p>De esta forma, lo que se importa dentro del marco actual no es el contenido del módulo importado, sino el módulo en sí.</p></li>
</ul></section><section class="slide level4">

<ul>
<li><p>Por ejemplo, si tenemos:</p>
<div class="columns">
<div class="column" style="width:40%;">
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="co"># uno.py</span></span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="im">import</span> dos</span>
<span id="cb2-4"><a href="#cb2-4"></a></span>
<span id="cb2-5"><a href="#cb2-5"></a>a <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>b <span class="op">=</span> <span class="dv">3</span></span></code></pre></div>
</div><div class="column" style="width:10%;">

</div><div class="column" style="width:40%;">
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a><span class="co"># dos.py</span></span>
<span id="cb3-2"><a href="#cb3-2"></a></span>
<span id="cb3-3"><a href="#cb3-3"></a>x <span class="op">=</span> <span class="dv">9</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>y <span class="op">=</span> <span class="dv">5</span></span></code></pre></div>
</div>
</div>
<p>al final de la ejecución del script <code>uno.py</code> tendremos:</p></li>
</ul>
<div class="centered">
<figure>
<img data-src="images/import-modulo.svg" class="plain" style="width:50.0%" alt="" /><figcaption>Importación del módulo <code>dos</code> en <code>uno</code></figcaption>
</figure>
</div>
</section><section class="slide level4">

<ul>
<li><p>Eso significa que los módulos en Python son internamente un dato más, al igual que las listas o las funciones: se pueden asignar a variables, se pueden borrar de la memoria con <code>del</code>, etc.</p></li>
<li><p>Y significa, además, que los módulos tienen su propio ámbito y, por tanto, crean su propio marco donde se almacenan sus definiciones, aunque eso es algo que ya sabíamos.</p></li>
<li><p>Para acceder al contenido del módulo importado, indicamos el nombre de ese módulo seguido de un punto (<code>.</code>) y el nombre del contenido al que queramos acceder.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Por ejemplo, para acceder a la función <code>gcd</code> definida en el módulo <code>math</code> haremos:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a><span class="im">import</span> math</span>
<span id="cb4-2"><a href="#cb4-2"></a></span>
<span id="cb4-3"><a href="#cb4-3"></a>x <span class="op">=</span> math.gcd(<span class="dv">16</span>, <span class="dv">6</span>)</span></code></pre></div></li>
</ul>
<div class="centered">
<figure>
<img data-src="images/import-math.svg" class="plain" style="width:60.0%" alt="" /><figcaption>Entorno en la última línea del script anterior</figcaption>
</figure>
</div>
<p><br></p>
<ul>
<li>Se recomienda (aunque no es obligatorio) colocar todas las sentencias <code>import</code> al principio del módulo importador.</li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Se puede importar un módulo dándole al mismo tiempo otro nombre dentro del marco actual, usando la sentencia <code>import</code> con la palabra clave <code>as</code>.</p></li>
<li><p>Por ejemplo:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a><span class="im">import</span> math <span class="im">as</span> mates</span></code></pre></div>
<p>La sentencia anterior importa el módulo <code>math</code> dentro del módulo actual pero con el nombre <code>mates</code> en lugar del <code>math</code> original. Por tanto, para usar la función <code>gcd</code> como en el ejemplo anterior usaremos:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a>x <span class="op">=</span> mates.gcd(<span class="dv">16</span>, <span class="dv">6</span>)</span></code></pre></div></li>
</ul>
<div class="centered">
<figure>
<img data-src="images/import-math-as.svg" class="plain" style="width:60.0%" alt="" /><figcaption>Resultado de ejecutar las dos últimas líneas anteriores</figcaption>
</figure>
</div>
</section><section class="slide level4">

<ul>
<li><p>Existe una variante de la sentencia <code>import</code> que nos permite importar directamente las definiciones de un módulo en lugar del propio módulo. Para ello, se usa la orden <code>from</code>.</p></li>
<li><p>Por ejemplo, para importar sólo la función <code>gcd</code> del módulo <code>math</code>, y no el módulo en sí, haremos:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a><span class="im">from</span> math <span class="im">import</span> gcd</span></code></pre></div></li>
<li><p>Por lo que ahora podemos usar la función <code>gcd</code> directamente dentro del módulo importador, sin necesidad de indicar el nombre del módulo importado:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a>x <span class="op">=</span> gcd(<span class="dv">16</span>, <span class="dv">6</span>)</span></code></pre></div></li>
</ul>
<div class="centered">
<figure>
<img data-src="images/from-math-import-gcd.svg" class="plain" style="width:30.0%" alt="" /><figcaption>Resultado de ejecutar las dos últimas líneas anteriores</figcaption>
</figure>
</div>
</section><section class="slide level4">

<ul>
<li><p>De hecho, ahora el módulo importado no está definido en el módulo importador (es decir, que en el marco global del módulo importador no hay ninguna ligadura con el nombre del módulo importado).</p></li>
<li><p>En nuestro ejemplo, eso significa que el módulo <code>math</code> no existe ahora como tal en el módulo importador, es decir, que ese nombre no está definido en el ámbito del módulo importador.</p></li>
<li><p>Por tanto, si hacemos:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a>x <span class="op">=</span> math  <span class="co"># error</span></span></code></pre></div>
<p>da error porque no hemos importado el módulo como tal, sino sólo una de sus funciones.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>También podemos usar la palabra clave <code>as</code> con la orden <code>from</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a><span class="im">from</span> math <span class="im">import</span> gcd <span class="im">as</span> mcd</span></code></pre></div>
<p>De esta forma, se importa en el módulo actual la función <code>gcd</code> del módulo <code>math</code> pero llamándola <code>mcd</code>.</p></li>
<li><p>Por tanto, para usarla la invocaremos con su nuevo nombre:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1"></a>x <span class="op">=</span> mcd(<span class="dv">16</span>, <span class="dv">6</span>)</span></code></pre></div></li>
</ul>
<div class="centered">
<figure>
<img data-src="images/from-math-import-gcd-as-mcd.svg" class="plain" style="width:30.0%" alt="" /><figcaption>Resultado de ejecutar las dos últimas líneas anteriores</figcaption>
</figure>
</div>
</section><section class="slide level4">

<ul>
<li><p>Existe incluso una variante para importar todas las definiciones de un módulo:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1"></a><span class="im">from</span> math <span class="im">import</span> <span class="op">*</span></span></code></pre></div></li>
<li><p>Con esta sintaxis importaremos todas las definiciones del módulo excepto aquellas cuyo nombre comience por un guión bajo (<code>_</code>).</p>
<p>Las definiciones con nombres que comienzan por <code>_</code> son consideradas <strong>privadas</strong> o internas al módulo, lo que significa que no están concebidas para ser usadas por los usuarios del módulo y que, por tanto, no forman parte de su <strong>interfaz</strong>.</p></li>
<li><p>En general, los programadores no suelen usar esta funcionalidad ya que puede introducir todo un conjunto de definiciones desconocidas dentro del módulo importador, lo que incluso puede provocar que se «<em>machaquen</em>» definiciones ya existentes.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Para saber qué definiciones contiene un módulo, se puede usar la funcion <code>dir()</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> math</span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">dir</span>(math)</span>
<span id="cb13-3"><a href="#cb13-3"></a>[<span class="st">&#39;__doc__&#39;</span>, <span class="st">&#39;__loader__&#39;</span>, <span class="st">&#39;__name__&#39;</span>, <span class="st">&#39;__package__&#39;</span>, <span class="st">&#39;__spec__&#39;</span>, <span class="st">&#39;acos&#39;</span>,</span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="st">&#39;acosh&#39;</span>, <span class="st">&#39;asin&#39;</span>, <span class="st">&#39;asinh&#39;</span>, <span class="st">&#39;atan&#39;</span>, <span class="st">&#39;atan2&#39;</span>, <span class="st">&#39;atanh&#39;</span>, <span class="st">&#39;ceil&#39;</span>, <span class="st">&#39;copysign&#39;</span>,</span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="st">&#39;cos&#39;</span>, <span class="st">&#39;cosh&#39;</span>, <span class="st">&#39;degrees&#39;</span>, <span class="st">&#39;e&#39;</span>, <span class="st">&#39;erf&#39;</span>, <span class="st">&#39;erfc&#39;</span>, <span class="st">&#39;exp&#39;</span>, <span class="st">&#39;expm1&#39;</span>, <span class="st">&#39;fabs&#39;</span>,</span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="st">&#39;factorial&#39;</span>, <span class="st">&#39;floor&#39;</span>, <span class="st">&#39;fmod&#39;</span>, <span class="st">&#39;frexp&#39;</span>, <span class="st">&#39;fsum&#39;</span>, <span class="st">&#39;gamma&#39;</span>, <span class="st">&#39;gcd&#39;</span>, <span class="st">&#39;hypot&#39;</span>,</span>
<span id="cb13-7"><a href="#cb13-7"></a><span class="st">&#39;inf&#39;</span>, <span class="st">&#39;isclose&#39;</span>, <span class="st">&#39;isfinite&#39;</span>, <span class="st">&#39;isinf&#39;</span>, <span class="st">&#39;isnan&#39;</span>, <span class="st">&#39;ldexp&#39;</span>, <span class="st">&#39;lgamma&#39;</span>, <span class="st">&#39;log&#39;</span>,</span>
<span id="cb13-8"><a href="#cb13-8"></a><span class="st">&#39;log10&#39;</span>, <span class="st">&#39;log1p&#39;</span>, <span class="st">&#39;log2&#39;</span>, <span class="st">&#39;modf&#39;</span>, <span class="st">&#39;nan&#39;</span>, <span class="st">&#39;pi&#39;</span>, <span class="st">&#39;pow&#39;</span>, <span class="st">&#39;radians&#39;</span>, <span class="st">&#39;sin&#39;</span>,</span>
<span id="cb13-9"><a href="#cb13-9"></a><span class="st">&#39;sinh&#39;</span>, <span class="st">&#39;sqrt&#39;</span>, <span class="st">&#39;tan&#39;</span>, <span class="st">&#39;tanh&#39;</span>, <span class="st">&#39;tau&#39;</span>, <span class="st">&#39;trunc&#39;</span>]</span></code></pre></div></li>
</ul>
</section><section id="módulos-como-scripts" class="title-slide slide level3"><h3><span class="header-section-number">2.3.2</span> Módulos como <em>scripts</em></h3><ul>
<li><p>Un módulo puede contener sentencias ejecutables además de definiciones.</p></li>
<li><p>Generalmente, esas sentencias existen para inicializar el módulo.</p></li>
<li><p>Las sentencias de un módulo se ejecutan sólo la primera vez que se encuentra el nombre de ese módulo en una sentencia <code>import</code>.</p></li>
<li><p>También se ejecutan si el archivo se ejecuta como un <em>script</em>.</p></li>
</ul></section><section class="slide level4">

<ul>
<li><p>Cuando se ejecuta un módulo Python desde la línea de órdenes como:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode console"><code class="sourceCode console"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">$ </span>python3 fact.py <span class="co">&lt;argumentos&gt;</span></span></code></pre></div>
<p>se ejecutará el código del módulo como si fuera un <em>script</em> más, igual que si se hubiera importado con un <code>import</code> dentro de otro módulo, pero con la diferencia de que la variable global <code>__name__</code> contendrá el valor <code>"__main__"</code>.</p></li>
<li><p>Eso significa que si se añade este código al final del módulo:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb15-2"><a href="#cb15-2"></a>    <span class="op">&lt;</span>sentencias<span class="op">&gt;</span></span></code></pre></div>
<p>el módulo podrá funcionar como un <em>script</em> independiente.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Por ejemplo, supongamos el siguiente módulo <code>fact.py</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">def</span> fac(n):</span>
<span id="cb16-2"><a href="#cb16-2"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb16-3"><a href="#cb16-3"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb16-4"><a href="#cb16-4"></a>    <span class="cf">else</span>:</span>
<span id="cb16-5"><a href="#cb16-5"></a>        <span class="cf">return</span> n <span class="op">*</span> fac(n <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb16-6"><a href="#cb16-6"></a></span>
<span id="cb16-7"><a href="#cb16-7"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb16-8"><a href="#cb16-8"></a>    <span class="im">import</span> sys</span>
<span id="cb16-9"><a href="#cb16-9"></a>    <span class="bu">print</span>(fac(<span class="bu">int</span>(sys.argv[<span class="dv">1</span>])))</span></code></pre></div></li>
<li><p>Este módulo se podrá usar como un <em>script</em> separado o como un módulo que se pueda importar dentro de otro.</p></li>
<li><p>Si se usa como <em>script</em>, podremos llamarlo desde la línea de órdenes del sistema operativo:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode console"><code class="sourceCode console"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">$ </span>python3 fac.py 4</span>
<span id="cb17-2"><a href="#cb17-2"></a>24</span></code></pre></div></li>
<li><p>Y si importamos el módulo dentro de otro, el código del último <code>if</code> no se ejecutará, por lo que sólo se incorporará la definición de la función <code>fac</code>.</p></li>
</ul>
<!--
### Paquetes

### Documentación interna
-->
</section></section>
<section><section id="criterios-de-descomposición-modular" class="title-slide slide level1"><h1><span class="header-section-number">3</span> Criterios de descomposición modular</h1></section><section id="introducción-1" class="title-slide slide level2"><h2><span class="header-section-number">3.1</span> Introducción</h2><ul>
<li><p>No existe una única forma de descomponer un programa en módulos (entiendo aquí por <em>módulo</em> cualquier parte del programa en sentido amplio, incluyendo una simple función).</p></li>
<li><p>Las diferentes formas de dividir el sistema en módulos traen consigo diferentes requisitos de comunicación y coordinación entre las personas (o equipos) que trabajan en esos módulos, y ayudan a obtener los beneficios descritos anteriormente en mayor o menor medida.</p></li>
<li><p>Nos interesa responder a las siguientes preguntas:</p>
<ul>
<li><p>¿Qué criterios se deben seguir para dividir el programa en módulos?</p></li>
<li><p>¿Qué módulos debe tener nuestro programa?</p></li>
<li><p>¿Cuántos módulos debe tener nuestro programa?</p></li>
<li><p>¿De qué tamaño deben ser los módulos?</p></li>
</ul></li>
</ul></section><section id="tamaño-y-número" class="title-slide slide level2"><h2><span class="header-section-number">3.2</span> Tamaño y número</h2><ul>
<li><p>Se supone que, si seguimos al pie de la letra la estrategia de diseño basada en la división de problemas, sería posible concluir que si el programa se dividiera indefinidamente, cada vez se necesitaría menos esfuerzo hasta llegar a cero.</p></li>
<li><p>Evidentemente, esto no es así, ya que hay otras fuerzas que entran en juego.</p></li>
<li><p>El coste de desarrollar un módulo individual disminuye conforme aumenta el número de módulos.</p></li>
<li><p>Dado el mismo conjunto de requisitos funcionales, cuantos más módulos hay, más pequeños son.</p></li>
<li><p>Sin embargo, cuantos más módulos hay, más cuesta integrarlos.</p></li>
<li><p>El tamaño de cada módulo debe ser el adecuado: si es demasiado grande, será difícil hacer cambios en él; si es demasiado pequeño, no merecerá la pena tratarlo como un módulo, sino más bien como parte de otros módulos.</p></li>
</ul></section><section class="slide level4">

<ul>
<li>El valor <span class="math inline">M</span> es el número de módulos ideal, ya que reduce el coste total del desarrollo.</li>
</ul>
<div class="centered">
<figure>
<img data-src="images/modulos.png" class="plain" style="width:80.0%" alt="" /><figcaption>Esfuerzo frente al número de módulos</figcaption>
</figure>
</div>
</section><section class="slide level4">

<ul>
<li><p>Las curvas de la figura anterior constituyen una guía útil al considerar la modularidad.</p></li>
<li><p>Debemos evitar hacer pocos o muchos módulos para así permanecer en la cercanía de M.</p></li>
<li><p>Pero, ¿cómo saber cuál es la cercanía de M? ¿Cómo de modular debe hacerse el programa?</p></li>
<li><p>Debe hacerse un diseño con módulos, de manera que el desarrollo pueda planearse con más facilidad, que los cambios se realicen con más facilidad, que las pruebas y la depuración se efectúen con mayor eficiencia y que el mantenimiento a largo plazo se lleve a cabo sin efectos indeseados de importancia.</p></li>
<li><p>Para ello nos basaremos en los siguientes <strong>criterios</strong>.</p></li>
</ul>
</section><section id="abstracción" class="title-slide slide level2"><h2><span class="header-section-number">3.3</span> Abstracción</h2><ul>
<li><p>La <strong>abstracción</strong> es un proceso mental que se basa en estudiar un aspecto del problema a un determinado nivel centrándose en lo esencial e ignorando momentáneamente los detalles que no son importantes en este nivel.</p></li>
<li><p>Igualmente, nos permite comprender la esencia de un subsistema sin tener que conocer detalles innecesarios del mismo.</p></li>
<li><p>La utilización de la abstracción también permite trabajar con conceptos y términos que son familiares en el entorno del problema sin tener que transformarlos en una estructura no familiar.</p></li>
<li><p>La abstracción se usa principalmente como una técnica de <strong>manejo y control de la complejidad</strong>.</p></li>
</ul></section><section class="slide level4">

<ul>
<li><p>Cuando se considera una solución modular a cualquier problema, se pueden definir varios <strong>niveles de abstracción</strong>:</p>
<ul>
<li><p>En niveles <strong>más altos</strong> de abstracción, se enuncia una solución en términos más generales usando el lenguaje del entorno del problema.</p>
<p>A estos niveles hay menos elementos de información, pero más grandes e importantes.</p></li>
<li><p>En niveles <strong>más bajos</strong> de abstracción se da una descripción más detallada de la solución.</p>
<p>A estos niveles se revelan más detalles, aparecen más elementos y se aumenta la cantidad de información con la que tenemos que trabajar.</p></li>
</ul></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>La barrera de separación entre un nivel de abstracción y su inmediatamente inferior es la diferencia entre el <em>qué</em> y el <em>cómo</em>:</p>
<ul>
<li><p>Cuando estudiamos un concepto a un determinado nivel de abstracción, estudiamos <em>qué</em> hace.</p></li>
<li><p>Cuando bajamos al nivel inmediatamente inferior, pasamos a estudiar <em>cómo</em> lo hace.</p></li>
</ul></li>
<li><p>Esta división o separación puede continuar en niveles inferiores, de forma que siempre puede considerarse que cualquier nivel responde al <em>qué</em> y el nivel siguiente responde al <em>cómo</em>.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Recordemos que un módulo tiene siempre un doble punto de vista:</p>
<ul>
<li><p>El punto de vista del <em>creador</em> o implementador del módulo.</p></li>
<li><p>El punto de vista del <em>usuario</em> del módulo.</p></li>
</ul>
<div class="caja">
<p>La abstracción nos ayuda a <strong>definir qué módulos constituyen nuestro programa</strong> considerando la relación que se establece entre los <em>creadores</em> y los <em>usuarios</em> de los módulos.</p>
</div></li>
<li><p>Esto es así porque <strong>los usuarios de un módulo quieren usar a éste como una abstracción</strong>: sabiendo <em>qué</em> hace (su función) pero sin necesidad de saber <em>cómo</em> lo hace (sus detalles internos).</p></li>
<li><p>El responsable del <em>cómo</em> es únicamente el <strong>creador</strong> del módulo.</p></li>
<li><p>Los módulos definidos como abstracciones son más fáciles de usar, diseñar y mantener.</p></li>
</ul>
</section><section id="ocultación-de-información" class="title-slide slide level2"><h2><span class="header-section-number">3.4</span> Ocultación de información</h2><ul>
<li><p>David Parnas introdujo el <strong>principio de ocultación de información</strong> en 1972.</p></li>
<li><p>Afirmó que el criterio principal para la modularización de un sistema debe ser la <strong>ocultación de <em>decisiones de diseño</em> complejas o que puedan cambiar en el futuro</strong>, es decir, que los módulos se deben caracterizar por ocultar <em>decisiones de diseño</em> a los demás módulos.</p>
<div class="caja">
<p>Por tanto: todos los elementos que necesiten conocer las mismas <em>decisiones de diseño</em>, deben pertenecer al mismo módulo.</p>
</div></li>
<li><p>Al ocultar la información de esa manera se evita que los usuarios de un módulo necesiten de un conocimiento íntimo del diseño interno del mismo para poder usarlo, y los aísla de los posibles efectos de cambiar esas decisiones posteriormente.</p></li>
<li><p>Implica que la modularidad efectiva se logra <strong>definiendo un conjunto de módulos independientes que intercambien sólo aquella información estrictamente necesaria para que el programa funcione</strong>.</p></li>
</ul></section><section class="slide level4">

<ul>
<li><p>Dicho de otra forma:</p>
<ul>
<li><p><strong>Para que un módulo <em>A</em> pueda usar a otro <em>B</em>, <em>A</em> tiene que conocer de <em>B</em> lo menos posible</strong>, lo imprescindible.</p>
<div class="caja">
<p>El uso del módulo debe realizarse únicamente por medio de <strong>interfaces</strong> bien definidas que no cambien (o cambien poco) con el tiempo y que no expongan detalles internos al exterior.</p>
</div></li>
<li><p>Por tanto, <em>B</em> debe <strong>ocultar</strong> al exterior sus detalles internos de <strong>implementación</strong> y exponer sólo lo necesario para que otros lo puedan utilizar.</p>
<p>Ésto aísla a los usuarios de los posibles cambios internos que pueda haber posteriormente en <em>B</em>.</p></li>
</ul></li>
</ul>
<div class="caja">
<p>Es decir: cada módulo debe ser una <strong>caja negra</strong> recelosa de su privacidad que tiene «aversión» por exponer sus interioridades a los demás.</p>
</div>
</section><section class="slide level4">

<ul>
<li><p>La <strong>abstracción</strong> y la <strong>ocultación de información</strong> se complementan:</p>
<ul>
<li><p>La <strong>ocultación de información</strong> es un <strong>principio de diseño</strong> que se basa en que los módulos deben ocultar a los demás módulos sus decisiones de diseño y exponer sólo la información estrictamente necesaria para que los demás puedan usarlos.</p></li>
<li><p>La <strong>abstracción</strong> puede usarse como una <strong>técnica de diseño</strong> que nos ayuda a cumplir con el principio de ocultación de información, porque nos permite descomponer el programa en módulos y <strong>nos ayuda a identificar qué detalles hay que ocultar</strong> y qué información hay que exponer a los demás.</p></li>
</ul></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Al <strong>usuario</strong> de un módulo…</p>
<ul>
<li><p>… le interesa la <strong>abstracción</strong> porque le permite usar el módulo sabiendo únicamente <em>qué</em> hace sin tener que saber <em>cómo</em> lo hace.</p></li>
<li><p>… le interesa la <strong>ocultación de información</strong> porque cuanta menos información necesite conocer para usar el módulo, más fácil y cómodo le resultará usarlo.</p></li>
</ul></li>
<li><p>Al <strong>creador</strong> de un módulo…</p>
<ul>
<li><p>… le interesa la <strong>abstracción</strong> como técnica porque le ayuda a determinar qué información debe ocultar su módulo al exterior.</p></li>
<li><p>… le interesa la <strong>ocultación de información</strong> porque cuantos más detalles necesiten conocer los usuarios para poder usar su módulo, menos libertad dentrá de poder cambiar esos detalles en el futuro (cuando lo necesite o cuando lo desee) sin afectar a los usuarios de su módulo.</p></li>
</ul></li>
</ul>
</section><section id="independencia-funcional" class="title-slide slide level2"><h2><span class="header-section-number">3.5</span> Independencia funcional</h2><ul>
<li><p>La independencia funcional se logra desarrollando módulos de manera que cada módulo resuelva una funcionalidad específica y tenga una interfaz sencilla cuando se vea desde otras partes de del programa (idealmente, mediante paso de parámetros).</p>
<ul>
<li>De hecho, la interfaz del módulo debe estar destinada únicamente a cumplir con esa funcionalidad.</li>
</ul></li>
<li><p>Al limitar su objetivo, el módulo necesita menos ayuda de otros módulos.</p></li>
<li><p>Y por eso el módulo debe ser tan independiente como sea posible del resto de los módulos del programa, es decir, que dependa lo menos posible de lo que hagan otros módulos, y también que dependa lo menos posible de los datos que puedan facilitarle otros módulos.</p>
<div class="caja">
<p>Dicho de otra forma: los módulos deben centrarse en resolver un problema concreto (ser «monotemáticos»), deben ser «antipáticos» y tener «aversión» a relacionarse con otros módulos.</p>
</div></li>
</ul></section><section class="slide level4">

<ul>
<li><p>Los módulos independientes son más fáciles de desarrollar porque la función del programa se subdivide y las interfaces se simplifican, por lo que se pueden desarrollar por separado.</p></li>
<li><p>Los módulos independientes son más fáciles de mantener y probar porque los efectos secundarios causados por el diseño o por la modificación del código son más limitados, se reduce la propagación de errores y es posible obtener módulos reutilizables.</p></li>
<li><p>De esta forma, la mayor parte de los cambios y mejoras que haya que hacer al programa implicarán modificar sólo un módulo o un número muy pequeño de ellos.</p></li>
<li><p>Es un objetivo a alcanzar para obtener una modularidad efectiva.</p></li>
<li><p>La independencia funcional se mide usando dos métricas: la <strong>cohesión</strong> y el <strong>acoplamiento</strong>.</p></li>
<li><p>El objetivo de la independencia funcional es <strong>maximizar la cohesión y minimizar el acoplamiento</strong>.</p></li>
</ul>
</section><section id="cohesión" class="title-slide slide level3"><h3><span class="header-section-number">3.5.1</span> Cohesión</h3><ul>
<li><p>La <strong>cohesión</strong> mide la fuerza con la que se relacionan los componentes de un módulo.</p></li>
<li><p>Cuanto más cohesivo sea un módulo, mejor será nuestro diseño modular.</p></li>
<li><p>Un módulo cohesivo realiza una sola función, por lo que requiere interactuar poco con otros componentes en otras partes del programa.</p></li>
<li><p>En un módulo cohesivo, sus componentes están fuertemente relacionados entre sí y pertenencen al módulo por una razón lógica (no están ahí por casualidad), es decir, todos cooperan para alcanzar un objetivo común que es la función del módulo.</p></li>
<li><p>Un módulo cohesivo mantiene unidos (<em>atrae</em>) los componentes que están relacionados entre ellos y mantiene fuera (<em>repele</em>) el resto.</p></li>
</ul></section><section class="slide level4">

<ul>
<li><p>En pocas palabras, un módulo cohesivo debe tener un único objetivo, y todos los elementos que lo componen deben contrubuir a alcanzar dicho objetivo.</p></li>
<li><p>Aunque siempre debe tratarse de lograr mucha cohesión (por ejemplo, una sola tarea), con frecuencia es necesario y aconsejable hacer que un módulo realice varias tareas, siempre que contribuyan a una misma finalidad lógica.</p></li>
<li><p>Sin embargo, para lograr un buen diseño hay que evitar módulos que llevan a cabo funciones no relacionadas.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>La siguiente es una escala de grados de cohesión, ordenada de mayor a menor:</p>
<ul>
<li><p>Cohesión funcional</p></li>
<li><p>Cohesión secuencial</p></li>
<li><p>Cohesión de comunicación</p>
<p>[Hasta aquí, los módulos se consideran <strong>cajas negras</strong>.]</p></li>
<li><p>Cohesión procedimental</p></li>
<li><p>Cohesión temporal</p></li>
<li><p>Cohesión lógica</p></li>
<li><p>Cohesión coincidental</p></li>
</ul></li>
<li><p>No hace falta determinar con precisión qué cohesión tenemos. Lo importante es intentar conseguir una cohesión alta y reconocer cuándo hay poca cohesión para modificar el diseño y conseguir una mayor independencia funcional.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p><strong>Cohesión funcional</strong>: se da cuando los componentes del módulo pertenecen al mismo porque todos contribuyen a una tarea única y bien definida del módulo.</p></li>
<li><p><strong>Cohesión secuencial</strong>: se da cuando los componentes del módulo pertenecen al mismo porque la salida de uno es la entrada del otro, como en una cadena de montaje (por ejemplo, una función que lee datos de un archivo y los procesa).</p></li>
<li><p><strong>Cohesión de comunicación</strong>: se da cuando los componentes del módulo pertenecen al mismo porque trabajan sobre los mismos datos (por ejemplo, un módulo que procesa números racionales).</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p><strong>Cohesión procedimental</strong>: se da cuando los componentes del módulo pertenecen al mismo porque siguen una cierta secuencia de ejecución (por ejemplo, una función que comprueba los permisos de un archivo y después lo abre).</p></li>
<li><p><strong>Cohesión temporal</strong>: se da cuando los componentes del módulo pertenecen al mismo porque se ejecutan en el mismo momento (por ejemplo, una función que se dispara cuando se produce un error, abriría un archivo, crearía un registro de error y notificaría al usuario).</p></li>
<li><p><strong>Cohesión lógica</strong>: se da cuando los componentes del módulo pertenecen al mismo porque pertenencen a la misma categoría lógica aunque son esencialmente distintos (por ejemplo, un módulo que agrupe las funciones de manejo del teclado o el ratón).</p></li>
<li><p><strong>Cohesión coincidental</strong>: se da cuando los componentes del módulo pertenecen al mismo por casualidad o por razones arbitrarias, es decir, que la única razón por la que se encuentran en el mismo módulo es porque se han agrupado juntos (por ejemplo, un módulo de «utilidades»).</p></li>
</ul>
</section><section id="acoplamiento" class="title-slide slide level3"><h3><span class="header-section-number">3.5.2</span> Acoplamiento</h3><ul>
<li><p>El <strong>acoplamiento</strong> es una medida del grado de interdependencia entre los módulos de un programa.</p></li>
<li><p>Dicho de otra forma, es la fuerza con la que se relacionan los módulos de un programa.</p></li>
<li><p>El acoplamiento depende de:</p>
<ul>
<li><p>La complejidad de la interfaz entre los módulos</p></li>
<li><p>El punto en el que se entra o se hace referencia a un módulo</p></li>
<li><p>Los datos que se pasan a través de la interfaz</p></li>
</ul></li>
<li><p>Lo deseable es tener módulos con poco acoplamiento, es decir, módulos que dependan poco unos de otros.</p></li>
<li><p>De esta forma obtenemos programas más fáciles de entender y menos propensos al <em>efecto ola</em>, que ocurre cuando se dan errores en un sitio y se propagan por todo el programa.</p></li>
</ul></section><section class="slide level4">

<ul>
<li><p>Los programas con alto acoplamiento tienden a presentar los siguientes problemas:</p>
<ul>
<li><p>Un cambio en un módulo normalmente obliga a cambiar otros módulos (consecuencia del <em>efecto ola</em>).</p></li>
<li><p>Requiere más esfuerzo integrar los módulos del programa ya que dependen mucho unos de otros.</p></li>
<li><p>Un módulo particular resulta más difícil de reutilizar o probar debido a que hay que incluir en el lote a los módulos de los que depende éste (no se puede reutilizar o probar por separado).</p></li>
</ul></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>La siguiente es una escala de grados de acoplamiento, ordenada de mayor a menor:</p>
<ul>
<li><p>Acoplamiento por contenido</p></li>
<li><p>Acoplamiento común</p></li>
<li><p>Acoplamiento externo</p></li>
<li><p>Acoplamiento de control</p></li>
<li><p>Acoplamiento por estampado</p></li>
<li><p>Acoplamiento de datos</p></li>
<li><p>Sin acoplamiento</p></li>
</ul></li>
<li><p>No hace falta determinar con precisión qué cohesión tenemos. Lo importante es intentar conseguir una cohesión alta y reconocer cuándo hay poca cohesión para modificar el diseño y conseguir una mayor independencia funcional.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p><strong>Acoplamiento por contenido</strong>: ocurre cuando un módulo modifica o se apoya en el funcionamiento interno de otro módulo (por ejemplo, accediendo a datos locales del otro módulo). Cambiar la forma en que el segundo módulo produce los datos obligará a cambiar el módulo dependiente.</p></li>
<li><p><strong>Acoplamiento común</strong>: ocurre cuando dos módulos comparten los mismos datos globales. Cambiar el recurso compartido obligará a cambiar todos los módulos que lo usen.</p></li>
<li><p><strong>Acoplamiento externo</strong>: ocurre cuando dos módulos comparten un formato de datos impuesto externamente, un protocolo de comunicación o una interfaz de dispositivo de entrada/salida.</p></li>
<li><p><strong>Acoplamiento de control</strong>: ocurre cuando un módulo controla el flujo de ejecución del otro (por ejemplo, pasándole un <em>conmutador</em> booleano).</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p><strong>Acoplamiento por estampado</strong>: ocurre cuando los módulos comparten una estructura de datos compuesta y usan sólo una parte de ella, posiblemente una parte diferente. Esto podría llevar a cambiar la forma en la que un módulo lee un dato compuesto debido a que un elemento que el módulo no necesita ha sido modificado.</p></li>
<li><p><strong>Acoplamiento de datos</strong>: ocurre cuando los módulos comparten datos entre ellos (por ejemplo, parámetros). Cada dato es una pieza elemental y dicho parámetro es la única información compartida (por ejemplo, pasando un entero a una función que calcula una raíz cuadrada).</p></li>
<li><p><strong>Sin acoplamiento</strong>: ocurre cuando los módulos no se comunican para nada uno con otro.</p></li>
</ul>
</section><section id="reusabilidad" class="title-slide slide level2"><h2><span class="header-section-number">3.6</span> Reusabilidad</h2><ul>
<li><p>La <strong>reusabilidad</strong> es un factor de calidad del software que se puede aplicar tambien a sus componentes o módulos.</p></li>
<li><p>Un módulo es <strong>reusable</strong> cuando puede aprovecharse para ser utilizado (tal cual o con muy poca modificación) en varios programas.</p></li>
<li><p>A la hora de diseñar módulos (o de descomponer un programa en módulos) nos interesa que los módulos resultantes sean cuanto más reusables mejor.</p></li>
<li><p>Para ello, el módulo en cuestión debe ser lo suficientemente general y resolver un problema patrón que sea suficientemente común y se pueda encontrar en varios contextos y programas diferentes.</p></li>
<li><p>Además, para aumentar la reusabilidad, es conveniente que el módulo tenga un bajo acoplamiento y que, por tanto, no dependa de otros módulos del programa.</p></li>
</ul></section><section class="slide level4">

<ul>
<li><p>Esos módulos incluso podrían luego formar parte de una <em>biblioteca</em> o <em>repositorio</em> de módulos y ponerlos a disposición de los programadores para que puedan usarlos en sus programas.</p></li>
<li><p>A día de hoy, el desarrollo de programas se basa en gran medida en seleccionar y utilizar módulos (o bibliotecas, <em>librerías</em> o <em>paquetes</em>) desarrollados por terceros o reutilizados de otros programas elaborados por nosotros mismos anteriormente.</p></li>
<li><p>Es decir: la programación se ha convertido en una actividad consistente principalmente en ir combinando componentes intercambiables.</p></li>
<li><p>Eso nos permite acortar el tiempo de desarrollo porque podemos construir un programa a base de ir ensamblando módulos reusables como si fueran las piezas del engranaje de una máquina.</p></li>
</ul>
</section></section>
<section><section id="abstracción-de-datos" class="title-slide slide level1"><h1><span class="header-section-number">4</span> Abstracción de datos</h1></section><section id="introducción-2" class="title-slide slide level2"><h2><span class="header-section-number">4.1</span> Introducción</h2><ul>
<li><p>Hasta ahora hemos estudiado la abstracción como un proceso mental que ayuda a estudiar y manipular sistemas complejos destacando los detalles relevantes e ignorando momentáneamente los demás que ahora mismo no tienen importancia o no son necesarias.</p></li>
<li><p>Asimismo, hemos visto que la abstracción se crea por niveles, es decir, que cuando estudiamos un sistema a un determinado nivel:</p>
<ul>
<li><p>Se <em>destacan</em> los detalles relevantes en ese nivel.</p></li>
<li><p>Se <em>ignoran</em> los detalles irrelevantes en ese nivel. Si descendemos de nivel de abstracción, es probable que algunos de esos detalles pasen a ser relevantes.</p></li>
</ul></li>
<li><p>Los programas son sistemas complejos, así que resulta importante que el lenguaje de programación nos permita estudiar y diseñar programas mediante sucesivos niveles de abstracción.</p></li>
</ul></section><section class="slide level4">

<ul>
<li><p>La abstracción, además de ser un proceso, es un concepto que se puede manipular directamente en un programa.</p></li>
<li><p>Hasta ahora, las únicas abstracciones que hemos utilizado y creado son las <strong>funciones</strong>, también llamadas <strong>abstracciones funcionales</strong>.</p></li>
<li><p>Una función es una abstracción funcional porque el usuario de la función sólo necesita conocer la especificación de la abstracción (el <em>qué</em> hace) y puede ignorar el resto de los detalles de implementación que se encuentran en el cuerpo de la función (el <em>cómo</em> lo hace).</p></li>
<li><p>Por eso decimos que las funciones definen dos niveles de abstracción.</p></li>
<li><p>En otras palabras, al diseñar una función estamos creando una abstracción que separa la forma en la que utiliza la función de los detalles de cómo está implementada esa función.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Las abstracciones funcionales son un mecanismo que nos permite componer una <strong>operación compleja</strong> a partir de otras operaciones más simples y poder usarla sin necesidad de conocer cómo está hecha por dentro (es decir, sin necesidad de conocer cuáles son esas operaciones más simples que la forman).</p></li>
<li><p>Una vez que la función se ha diseñado y se está utilizando, se puede sustituir por cualquier otra que tenga el mismo comportamiento general.</p></li>
<li><p>De la misma forma, los datos compuestos o estructurados son un mecanismo que nos permite crear un <strong>dato complejo</strong> a partir de otros datos más simples, formando una única unidad conceptual.</p></li>
<li><p>Por desgracia, estos datos compuestos no ocultan sus detalles de implementación al usuario, sino que éste tiene que conocer cómo está construido.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Por ejemplo, podemos representar un número racional <span class="math inline">\frac{a}{b}</span> mediante una pareja de números enteros <span class="math inline">a</span> y <span class="math inline">b</span> (su numerador y su denominador).</p></li>
<li><p>Si almacenamos los dos números por separado no estaremos creando una sola unidad conceptual (no estaremos componiendo un nuevo dato a partir de otros datos más simples).</p></li>
<li><p>Eso no resulta conveniente. A nosotros, como programadores, nos interesa que el numerador y el denominador de un número racional estén juntos formando una sola cosa, un nuevo valor: un número racional.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Podríamos representar dicha pareja de números usando una lista como <code>[</code><span class="math inline">a</span><code>,</code> <span class="math inline">b</span><code>]</code>, o una tupla <code>(</code><span class="math inline">a</span><code>,</code> <span class="math inline">b</span><code>)</code>, o incluso un diccionario<br />
<code>{'numer':</code> <span class="math inline">a</span><code>, 'denom':</code> <span class="math inline">b</span><code>}</code>.</p></li>
<li><p>Pero estaríamos obligando al usuario de nuestros números racionales a tener que saber cómo representamos los racionales en función de otros tipos más primitivos, lo que nos impide cambiar luego esa representación sin afectar al resto del programa.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Por ejemplo, si representamos un racional como dos números enteros separados, no podríamos escribir una función que multiplique dos racionales <span class="math inline">\frac{n_1}{d_1}</span> y <span class="math inline">\frac{n_2}{d_2}</span> ya que dicha función tendría que devolver dos valores, el numerador y el denominador del resultado:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1"></a><span class="kw">def</span> mult_rac(n1, d1, n2, d2):</span>
<span id="cb18-2"><a href="#cb18-2"></a>    <span class="cf">return</span> ????</span></code></pre></div></li>
<li><p>Si representamos un racional <span class="math inline">\frac{n}{d}</span> con, por ejemplo, una tupla <code>(</code><span class="math inline">n</span><code>,</code> <span class="math inline">d</span><code>)</code>, la función que multiplica dos racionales podría ser:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1"></a><span class="kw">def</span> mult_rac(r1, r2):</span>
<span id="cb19-2"><a href="#cb19-2"></a>    <span class="cf">return</span> (r1[<span class="dv">0</span>] <span class="op">*</span> r2[<span class="dv">0</span>], r1[<span class="dv">1</span>] <span class="op">*</span> r2[<span class="dv">1</span>])</span></code></pre></div>
<p>Es decir, que la función tendría que saber que el racional se representa internamente con una tupla, y que el numerador es el primer elemento y que el denominador es el segundo elemento.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Nos interesa que nuestro programa sea capaz de expresar el concepto de «número racional» y que pueda manipular números racionales como valores con entidad propia y definida, no simplemente como parejas de números enteros, independientemente de su representación interna.</p></li>
<li><p>Para todo esto, es importante que el programa que utilice los números racionales no necesite conocer los detalles internos de cómo está representado internamente un número racional.</p></li>
<li><p>Es decir: que los números racionales se pueden representar internamente como una lista de dos números, o como una tupla, o como un diccionario, o de cualquier otro modo, pero ese detalle interno debe quedar oculto para los usuarios de los números racionales.</p></li>
<li><p>La técnica general de aislar las partes de un programa que se ocupan de <em>cómo se representan</em> los datos de las partes que se ocupan de <em>cómo se usan</em> los datos es una poderosa metodología de diseño llamada <strong>abstracción de datos</strong>.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>La abstracción de datos es una técnica pero también es un concepto que se puede manipular directamente en un programa.</p></li>
<li><p>Diseñar programas usando abstracción de datos da como resultado la creación y utilización de <strong>tipos abstractos de datos</strong> (o <strong>TAD</strong>), a los que también se se les denomina <strong>abstracciones de datos</strong>.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>La abstracción de datos se parece a la abstracción funcional:</p>
<ul>
<li><p>Cuando creamos una <strong>abstracción funcional</strong>, se ocultan los detalles de cómo se implementa una función, y esa función particular se puede sustituir luego por cualquier otra función que tenga el mismo comportamiento general sin que los usuarios de la función se vean afectados.</p>
<p>En otras palabras, podemos hacer una abstracción que separe la forma en que se utiliza la función de los detalles de cómo se implementa la función.</p></li>
<li><p>Igualmente, la <strong>abstracción de datos</strong> separa el uso de un dato compuesto de los detalles de cómo está construido ese dato compuesto, que quedan ocultos para los usuarios de la abstracción de datos.</p>
<p>Para usar una abstracción de datos no necesitamos conocer sus detalles internos de implementación.</p></li>
</ul></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>El concepto de <strong>abstracción de datos</strong> (o <strong>tipo abstracto de datos</strong>) fue propuesto por John Guttag en 1974 y dice que:</p>
<div class="caja">
<p><strong>Tipo abstracto de datos</strong></p>
<p>Un <strong>tipo abstracto de datos</strong> (o <strong><em>abstracción de datos</em></strong>) es un conjunto de valores y de operaciones que se definen mediante una <strong>especificación</strong> que es independiente de cualquier representación.</p>
</div></li>
<li><p>Para ello, los tipos abstractos de datos se definen nombrando, no sus valores, sino sus <strong>operaciones</strong> y las propiedades que cumplen éstas.</p></li>
<li><p>Los <strong>valores</strong> de un tipo abstracto se definen también como operaciones.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Por ejemplo, <code>set</code> es un tipo abstracto de datos en Python.</p>
<ul>
<li><p>Se nos proporcionan <strong>operaciones primitivas</strong> para crear conjuntos y manipular conjuntos (unión, intersección) y también un modo de visualizar sus valores.</p></li>
<li><p>Pero no se nos especifica cómo se representan internamente los conjuntos en la memoria del ordenador.</p></li>
</ul></li>
<li><p>En general, el programador que usa un tipo abstracto puede no saber, e incluso se le impide saber, cómo se representan los elementos del tipo de datos.</p></li>
<li><p>Esas <strong>barreras de abstracción</strong> son muy útiles porque permiten cambiar la representación interna sin afectar a las demás partes del programa que utilizan dicho tipo abstracto.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>En resumen, tenemos que un tipo abstracto debe cumplir:</p>
<ul>
<li><p><strong>Privacidad de la representación</strong>: los usuarios no conocen la representación de los valores del tipo abstracto en la memoria del ordenador.</p></li>
<li><p><strong>Protección</strong>: sólo se pueden utilizar para el nuevo tipo las operaciones previstas en la especificación.</p></li>
</ul></li>
</ul>
<blockquote>
<p>«Son las especificaciones, y no los programas, los que realmente describen una abstracción; los programas simplemente la implementan.»</p>
<p>– Barbara Liskov</p>
</blockquote>
</section><section class="slide level4">

<ul>
<li><p>El programador de un tipo abstracto debe crear, por tanto, dos partes bien diferenciadas:</p>
<ul>
<li><p>La <strong>especificación</strong> del tipo: única parte que conoce el usuario del mismo y que consiste en:</p>
<ul>
<li><p>El <strong>nombre</strong> del tipo.</p></li>
<li><p>La especificación de las <strong>operaciones</strong> permitidas. Esta especificación tendrá:</p>
<ul>
<li><p>Una parte <strong>sintáctica</strong>: la <em>signatura</em> de cada operación.</p></li>
<li><p>Otra parte <strong>semántica</strong>: que define las <strong>propiedades</strong> que deben cumplir dichas operaciones y que se pueden expresar mediante <strong>ecuaciones</strong> o directamente en lenguaje natural.</p></li>
</ul></li>
</ul></li>
<li><p>La <strong>implementación</strong> del tipo: conocida sólo por el programador del mismo y que consiste en la <em>representación</em> del tipo por medio de otros tipos y en la implementación de las operaciones.</p></li>
</ul></li>
</ul>
</section><section id="especificaciones" class="title-slide slide level2"><h2><span class="header-section-number">4.2</span> Especificaciones</h2><div class="columns">
<div class="column">
<ul>
<li>La sintaxis de una <strong>especificación algebraica</strong> es la siguiente:</li>
</ul>
<div class="line-block"><strong><code>espec</code></strong> <span style="color:teal">⟨<em>tipo</em>⟩</span><br />
      [<strong><code>parámetros</code></strong><br />
            <span style="color:teal">⟨<em>parámetro</em>⟩</span>+]<br />
      <strong><code>operaciones</code></strong><br />
            (<span style="color:teal">⟨<em>operación</em>⟩</span> <strong><code>:</code></strong> <span style="color:teal">⟨<em>signatura</em>⟩</span>)+<br />
      [<strong><code>var</code></strong><br />
            <span style="color:teal">⟨<em>decl_var</em>⟩</span> (<strong><code>;</code></strong> <span style="color:teal">⟨<em>decl_var</em>⟩</span>)*]<br />
      <strong><code>ecuaciones</code></strong><br />
            <span style="color:teal">⟨<em>ecuación</em>⟩</span>+</div>
</div><div class="column">
<ul>
<li>Donde:</li>
</ul>
<div class="line-block"><span style="color:teal">⟨<em>decl_var</em>⟩</span> ::= <span style="color:teal">⟨<em>variable</em>⟩</span> <strong><code>:</code></strong> <span style="color:teal">⟨<em>tipo</em>⟩</span><br />
<span style="color:teal">⟨<em>ecuación</em>⟩</span> ::= <span style="color:teal">⟨<em>izquierda</em>⟩</span> <span class="math inline">\doteq</span> <span style="color:teal">⟨<em>derecha</em>⟩</span></div>
</div>
</div></section><section id="operaciones" class="title-slide slide level3"><h3><span class="header-section-number">4.2.1</span> Operaciones</h3><ul>
<li><p>Las operaciones que forman parte de la especificación de un tipo abstracto <span class="math inline">T</span> pueden clasificarse en:</p>
<ul>
<li><p><strong>Constructoras</strong>: operaciones que devuelven un valor de tipo <span class="math inline">T</span>.</p>
<ul>
<li><p>A su vez, las constructoras se dividen en:</p>
<ul>
<li><p><strong>Generadoras</strong>: el conjunto de operaciones generadoras está formado por aquellas operaciones constructoras que tienen la propiedad de que sólo con ellas es suficiente para generar cualquier valor del tipo, y excluyendo cualquiera de ellas hay valores que no pueden ser generados.</p></li>
<li><p><strong>Modificadoras</strong>: son las operaciones constructoras que no forman parte del conjunto de las generadoras.</p></li>
</ul></li>
</ul></li>
<li><p><strong>Selectoras</strong>: operaciones que toman como argumento uno o más valores de tipo <span class="math inline">T</span> que no devuelven un valor de tipo <span class="math inline">T</span>.</p></li>
</ul></li>
</ul></section><section id="ejemplos" class="title-slide slide level3"><h3><span class="header-section-number">4.2.2</span> Ejemplos</h3><ul>
<li>Un ejemplo de especificación de las <strong>listas</strong> como tipo abstracto sería:</li>
</ul>
<div class="columns">
<div class="column">
<div class="line-block"><strong>espec</strong> <em>lista</em><br />
    <strong>parámetros</strong><br />
          <em>elemento</em><br />
    <strong>operaciones</strong><br />
          <code>[]</code> : <span class="math inline">\rightarrow</span> <em>lista</em><br />
          <code>[</code>_<code>]</code> : <em>elemento</em> <span class="math inline">\rightarrow</span> <em>lista</em><br />
          _<code>++</code>_ : <em>lista</em> <span class="math inline">\times</span> <em>lista</em> <span class="math inline">\rightarrow</span> <em>lista</em><br />
          _<code>:</code>_ : <em>elemento</em> <span class="math inline">\times</span> <em>lista</em> <span class="math inline">\rightarrow</span> <em>lista</em><br />
          <code>len</code> : <em>lista</em> <span class="math inline">\rightarrow</span> <span class="math inline">\mathbb{N}</span><br />
    <strong>var</strong><br />
          <span class="math inline">x</span> : <em>elemento</em>; <span class="math inline">l, l_1, l_2, l_3</span> : <em>lista</em><br />
    <strong>ecuaciones</strong><br />
          <span class="math inline">x</span> <code>:</code> <span class="math inline">l</span> <span class="math inline">\doteq</span> <code>[</code><span class="math inline">x</span><code>]</code> <code>++</code> <span class="math inline">l</span><br />
          <span class="math inline">l</span> <code>++</code> <code>[]</code> <span class="math inline">\doteq</span> <span class="math inline">l</span><br />
          <code>[]</code> <code>++</code> <span class="math inline">l</span> <span class="math inline">\doteq</span> <span class="math inline">l</span><br />
          (<span class="math inline">l_1</span> <code>++</code> <span class="math inline">l_2</span>) <code>++</code> <span class="math inline">l_3</span> <span class="math inline">\doteq</span> <span class="math inline">l_1</span> <code>++</code> (<span class="math inline">l_2</span> <code>++</code> <span class="math inline">l_3</span>)<br />
          <code>len</code>(<code>[]</code>) <span class="math inline">\doteq</span> 0<br />
          <code>len</code>(<code>[</code><span class="math inline">x</span><code>]</code>) <span class="math inline">\doteq</span> 1<br />
          <code>len</code>(<span class="math inline">x</span> <code>:</code> <span class="math inline">l</span>) <span class="math inline">\doteq</span> 1 + <code>len</code>(<span class="math inline">l</span>)<br />
          <code>len</code>(<span class="math inline">l_1</span> <code>++</code> <span class="math inline">l_2</span>) <span class="math inline">\doteq</span> <code>len</code>(<span class="math inline">l_1</span>) + <code>len</code>(<span class="math inline">l_2</span>)</div>
</div><div class="column">
<ul>
<li><p>Este estilo de especificación se denomina <strong>especificación algebraica</strong>.</p></li>
<li><p>Su principal virtud es que permite definir un nuevo tipo de forma <em>totalmente independiente</em> de cualquier posible representación o implementación.</p></li>
<li><p>¿A qué categoría pertenencen cada una de esas operaciones?</p></li>
</ul>
</div>
</div></section><section class="slide level4">

<div class="columns">
<div class="column">
<ul>
<li>Las <strong>pilas</strong> como tipo abstracto se podrían especificar así:</li>
</ul>
<div class="line-block"><strong>espec</strong> <em>pila</em><br />
    <strong>parámetros</strong><br />
          <em>elemento</em><br />
    <strong>operaciones</strong><br />
          <code>pvacia</code> : <span class="math inline">\rightarrow</span> <em>pila</em><br />
          <code>apilar</code> : <em>pila</em> <span class="math inline">\times</span> <em>elemento</em> <span class="math inline">\rightarrow</span> <em>pila</em><br />
          <strong>parcial</strong> <code>cima</code> : <em>pila</em> <span class="math inline">\rightarrow</span> <em>elemento</em><br />
          <strong>parcial</strong> <code>desapilar</code> : <em>pila</em> <span class="math inline">\rightarrow</span> <em>pila</em><br />
          <code>vacia?</code> : <em>pila</em> <span class="math inline">\rightarrow</span> <span class="math inline">\mathfrak{B}</span><br />
    <strong>var</strong><br />
          <span class="math inline">p</span> : <em>pila</em>; <span class="math inline">x</span> : <em>elemento</em><br />
    <strong>ecuaciones</strong><br />
          <code>cima</code>(<code>apilar</code>(<span class="math inline">p</span>, <span class="math inline">x</span>)) <span class="math inline">\doteq</span> <span class="math inline">x</span><br />
          <code>desapilar</code>(<code>apilar</code>(<span class="math inline">p</span>, <span class="math inline">x</span>)) <span class="math inline">\doteq</span> <span class="math inline">p</span><br />
          <code>vacia?</code>(<code>pvacia</code>) <span class="math inline">\doteq</span> <span class="math inline">V</span><br />
          <code>vacia?</code>(<code>apilar</code>(<span class="math inline">p</span>, <span class="math inline">x</span>)) <span class="math inline">\doteq</span> <span class="math inline">F</span><br />
          <code>cima</code>(<code>pvacia</code>) <span class="math inline">\doteq</span> <span class="math inline">error</span><br />
          <code>desapilar</code>(<code>pvacia</code>) <span class="math inline">\doteq</span> <span class="math inline">error</span></div>
</div><div class="column">
<ul>
<li><p>Y un programa que hiciera uso de las pilas una vez implementado el tipo abstracto de datos, podría ser:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1"></a>p <span class="op">=</span> pvacia()        <span class="co"># crea vacía</span></span>
<span id="cb20-2"><a href="#cb20-2"></a>p <span class="op">=</span> apilar(p, <span class="dv">4</span>)    <span class="co"># apila valor 4</span></span>
<span id="cb20-3"><a href="#cb20-3"></a>p <span class="op">=</span> apilar(p, <span class="dv">8</span>)    <span class="co"># apila valor 8</span></span>
<span id="cb20-4"><a href="#cb20-4"></a><span class="bu">print</span>(vacia(p))     <span class="co"># imprime False</span></span>
<span id="cb20-5"><a href="#cb20-5"></a><span class="bu">print</span>(cima(p))      <span class="co"># imprime 8</span></span>
<span id="cb20-6"><a href="#cb20-6"></a><span class="bu">print</span>(desapilar(p)) <span class="co"># imprime 8</span></span>
<span id="cb20-7"><a href="#cb20-7"></a><span class="bu">print</span>(desapilar(p)) <span class="co"># imprime 4</span></span>
<span id="cb20-8"><a href="#cb20-8"></a><span class="bu">print</span>(vacia(p))     <span class="co"># imprime True</span></span>
<span id="cb20-9"><a href="#cb20-9"></a><span class="bu">print</span>(cima(pvacia)) <span class="co"># error</span></span></code></pre></div></li>
<li><p>El programa usa la pila a través de las operaciones sin necesidad de conocer su representación interna (su implementación).</p></li>
</ul>
</div>
</div>
</section><section class="slide level4">

<ul>
<li>Y los <strong>números racionales</strong> se podrían especificar así:</li>
</ul>

<div class="line-block"><strong>espec</strong> <em>rac</em><br />
    <strong>operaciones</strong><br />
          <strong>parcial</strong> <code>racional</code> : <span class="math inline">\mathbb{N}</span> <span class="math inline">\times</span> <span class="math inline">\mathbb{N}</span> <span class="math inline">\rightarrow</span> <em>rac</em><br />
          <code>numer</code> : <em>rac</em> <span class="math inline">\rightarrow</span> <span class="math inline">\mathbb{N}</span><br />
          <code>denom</code> : <em>rac</em> <span class="math inline">\rightarrow</span> <span class="math inline">\mathbb{N}</span><br />
          <code>suma</code> : <em>rac</em> <span class="math inline">\times</span> <em>rac</em> <span class="math inline">\rightarrow</span> <em>rac</em><br />
          <code>mult</code> : <em>rac</em> <span class="math inline">\times</span> <em>rac</em> <span class="math inline">\rightarrow</span> <em>rac</em><br />
          <code>iguales?</code> : <em>rac</em> <span class="math inline">\times</span> <em>rac</em> <span class="math inline">\rightarrow</span> <span class="math inline">\mathfrak{B}</span><br />
          <code>imprimir</code> : <em>rac</em> <span class="math inline">\rightarrow</span> <span class="math inline">\emptyset</span><br />
    <strong>var</strong><br />
          <span class="math inline">r</span> : <em>rac</em>; <span class="math inline">n</span>, <span class="math inline">d</span>, <span class="math inline">n_1</span>, <span class="math inline">n_2</span>, <span class="math inline">d_1</span>, <span class="math inline">d_2</span> : <span class="math inline">\mathbb{N}</span><br />
    <strong>ecuaciones</strong><br />
          <code>numer</code>(<code>racional</code>(<span class="math inline">n</span>, <span class="math inline">d</span>)) <span class="math inline">\doteq</span> <span class="math inline">n</span><br />
          <code>denom</code>(<code>racional</code>(<span class="math inline">n</span>, <span class="math inline">d</span>)) <span class="math inline">\doteq</span> <span class="math inline">d</span><br />
          <code>suma</code>(<code>racional</code>(<span class="math inline">n_1</span>, <span class="math inline">d_1</span>), <code>racional</code>(<span class="math inline">n_2</span>, <span class="math inline">d_2</span>)) <span class="math inline">\doteq</span> <code>racional</code>(<span class="math inline">n_1\cdot{}d_2 + n_2\cdot{}d_1</span>, <span class="math inline">d_1\cdot{}d_2</span>)<br />
          <code>mult</code>(<code>racional</code>(<span class="math inline">n_1</span>, <span class="math inline">d_1</span>), <code>racional</code>(<span class="math inline">n_2</span>, <span class="math inline">d_2</span>)) <span class="math inline">\doteq</span> <code>racional</code>(<span class="math inline">n_1\cdot{}n_2</span>, <span class="math inline">d_1\cdot{}d_2</span>)<br />
          <code>iguales?</code>(<code>racional</code>(<span class="math inline">n_1</span>, <span class="math inline">d_1</span>), <code>racional</code>(<span class="math inline">n_2</span>, <span class="math inline">d_2</span>)) <span class="math inline">\doteq</span> <span class="math inline">n_1\cdot{}d_2 = n_2\cdot{}d_1</span><br />
          <code>imprimir</code>(<span class="math inline">r</span>) { imprime el racional <span class="math inline">r</span> }<br />
          <code>racional</code>(<span class="math inline">n</span>, 0) <span class="math inline">\doteq</span> <span class="math inline">error</span></div>

</section><section class="slide level4">

<ul>
<li><p>Según la especificación anterior, podemos suponer que disponemos de un constructor y dos selectores a través de las siguientes funciones:</p>
<ul>
<li><p><code>racional(</code><span class="math inline">n</span><code>,</code><span class="math inline">d</span><code>)</code>: devuelve el número racional con numerador <span class="math inline">n</span> y denominador <span class="math inline">d</span>.</p></li>
<li><p><code>numer(</code><span class="math inline">x</span><code>)</code>: devuelve el numerador del número racional <span class="math inline">x</span>.</p></li>
<li><p><code>denom(</code><span class="math inline">x</span><code>)</code>: devuelve el denominador del número racional <span class="math inline">x</span>.</p></li>
</ul></li>
<li><p>Estamos usando una estrategia poderosa para diseñar programas: el <strong>pensamiento optimista</strong>, ya que todavía no hemos dicho cómo se representa un número racional, o cómo se deben implementar las funciones <code>numer</code>, <code>denom</code> y <code>racional</code>.</p></li>
<li><p>Aun así, si definimos estas tres funciones, podríamos sumar, multiplicar, imprimir y comprobar la igualdad de números racionales, con lo que implementaríamos las funciones <code>suma</code>, <code>mult</code>, <code>imprimir</code> e <code>iguales?</code>, ya especificadas, en función de <code>racional</code>, <code>numer</code> y <code>denom</code>.</p></li>
</ul>
</section><section class="slide level4">

<div class="sourceCode" id="cb21"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">def</span> suma(x, y):</span>
<span id="cb21-2"><a href="#cb21-2"></a>    nx, dx <span class="op">=</span> numer(x), denom(x)</span>
<span id="cb21-3"><a href="#cb21-3"></a>    ny, dy <span class="op">=</span> numer(y), denom(y)</span>
<span id="cb21-4"><a href="#cb21-4"></a>    <span class="cf">return</span> racional(nx <span class="op">*</span> dy <span class="op">+</span> ny <span class="op">*</span> dx, dx <span class="op">*</span> dy)</span>
<span id="cb21-5"><a href="#cb21-5"></a></span>
<span id="cb21-6"><a href="#cb21-6"></a><span class="kw">def</span> mult(x, y):</span>
<span id="cb21-7"><a href="#cb21-7"></a>    <span class="cf">return</span> racional(numer(x) <span class="op">*</span> numer(y), denom(x) <span class="op">*</span> denom(y))</span>
<span id="cb21-8"><a href="#cb21-8"></a></span>
<span id="cb21-9"><a href="#cb21-9"></a><span class="kw">def</span> iguales(x, y):</span>
<span id="cb21-10"><a href="#cb21-10"></a>    <span class="cf">return</span> numer(x) <span class="op">*</span> denom(y) <span class="op">==</span> numer(y) <span class="op">*</span> denom(x)</span>
<span id="cb21-11"><a href="#cb21-11"></a></span>
<span id="cb21-12"><a href="#cb21-12"></a><span class="kw">def</span> imprimir(x):</span>
<span id="cb21-13"><a href="#cb21-13"></a>    <span class="bu">print</span>(numer(x), <span class="st">&#39;/&#39;</span>, denom(x), sep<span class="op">=</span><span class="st">&#39;&#39;</span>)</span></code></pre></div>
</section><section id="implementaciones" class="title-slide slide level2"><h2><span class="header-section-number">4.3</span> Implementaciones</h2><ul>
<li><p>Ahora tenemos las operaciones sobre números racionales implementadas sobre las funciones selectoras <code>numer</code> y <code>denom</code> y la función constructora <code>racional</code>, pero aún no hemos implementado estas tres funciones.</p></li>
<li><p>Lo que necesitamos es alguna forma de unir un numerador y un denominador en un valor compuesto.</p></li>
<li><p>Podemos usar cualquier representación que nos permita combinar ambos valores (numerador y denominador) en una sola unidad y que también nos permita manipular cada valor por separado cuando sea necesario.</p></li>
</ul></section><section class="slide level4">

<ul>
<li><p>Por ejemplo, podemos usar una lista de dos números enteros para representar un racional mediante sus su numerador y su denominador:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1"></a><span class="kw">def</span> racional(n, d):</span>
<span id="cb22-2"><a href="#cb22-2"></a>    <span class="co">&quot;&quot;&quot;Un racional es una lista que contiene el numerador y el denominador.&quot;&quot;&quot;</span></span>
<span id="cb22-3"><a href="#cb22-3"></a>    <span class="cf">return</span> [n, d]</span>
<span id="cb22-4"><a href="#cb22-4"></a></span>
<span id="cb22-5"><a href="#cb22-5"></a><span class="kw">def</span> numer(x):</span>
<span id="cb22-6"><a href="#cb22-6"></a>    <span class="co">&quot;&quot;&quot;El numerador es el primer elemento de la lista.&quot;&quot;&quot;</span></span>
<span id="cb22-7"><a href="#cb22-7"></a>    <span class="cf">return</span> x[<span class="dv">0</span>]</span>
<span id="cb22-8"><a href="#cb22-8"></a></span>
<span id="cb22-9"><a href="#cb22-9"></a><span class="kw">def</span> denom(x):</span>
<span id="cb22-10"><a href="#cb22-10"></a>    <span class="co">&quot;&quot;&quot;El denominador es el segundo elemento de la lista.&quot;&quot;&quot;</span></span>
<span id="cb22-11"><a href="#cb22-11"></a>    <span class="cf">return</span> x[<span class="dv">1</span>]</span></code></pre></div></li>
<li><p>Junto con las operaciones aritméticas que definimos anteriormente, podemos manipular números racionales con las funciones que hemos definido y sin tener que conocer su representación interna:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1"></a><span class="op">&gt;&gt;&gt;</span> medio <span class="op">=</span> racional(<span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="op">&gt;&gt;&gt;</span> imprimir(medio)</span>
<span id="cb23-3"><a href="#cb23-3"></a><span class="dv">1</span><span class="op">/</span><span class="dv">2</span></span>
<span id="cb23-4"><a href="#cb23-4"></a><span class="op">&gt;&gt;&gt;</span> tercio <span class="op">=</span> racional(<span class="dv">1</span>, <span class="dv">3</span>)</span>
<span id="cb23-5"><a href="#cb23-5"></a><span class="op">&gt;&gt;&gt;</span> imprimir(mult(medio, tercio))</span>
<span id="cb23-6"><a href="#cb23-6"></a><span class="dv">1</span><span class="op">/</span><span class="dv">6</span></span>
<span id="cb23-7"><a href="#cb23-7"></a><span class="op">&gt;&gt;&gt;</span> imprimir(suma(tercio, tercio))</span>
<span id="cb23-8"><a href="#cb23-8"></a><span class="dv">6</span><span class="op">/</span><span class="dv">9</span></span></code></pre></div></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Como muestra el ejemplo anterior, nuestra implementación de números racionales no simplifica las fracciones resultantes.</p></li>
<li><p>Podemos corregir ese defecto cambiando únicamente la implementación de <code>racional</code>.</p></li>
<li><p>Usando el máximo común divisor podemos reducir el numerador y el denominador para obtener un número racional equivalente:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1"></a><span class="im">from</span> math <span class="im">import</span> gcd </span>
<span id="cb24-2"><a href="#cb24-2"></a></span>
<span id="cb24-3"><a href="#cb24-3"></a><span class="kw">def</span> racional(n, d): </span>
<span id="cb24-4"><a href="#cb24-4"></a>    g <span class="op">=</span> gcd(n, d)</span>
<span id="cb24-5"><a href="#cb24-5"></a>    <span class="cf">return</span> [n <span class="op">//</span> g, d <span class="op">//</span> g]   </span></code></pre></div></li>
<li><p>Con esta implementación revisada de <code>racional</code> nos aseguramos de que los racionales se expresan de la forma más simplificada posible:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1"></a><span class="op">&gt;&gt;&gt;</span> imprimir(suma(tercio, tercio))</span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="dv">2</span><span class="op">/</span><span class="dv">3</span></span></code></pre></div></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Lo interesante es que este cambio sólo ha afectado al constructor <code>racional</code>, y las demás operaciones no se han visto afectadas por ese cambio.</p></li>
<li><p>Esto es así porque el resto de las operaciones no conocen ni necesitan conocer la representación interna de un número racional, es decir, la implementación del constructor <code>racional</code>. Sólo necesitan conocer la <strong>especificación</strong> de <code>racional</code>, la cual no ha cambiado.</p></li>
</ul>
</section><section id="barreras-de-abstracción" class="title-slide slide level2"><h2><span class="header-section-number">4.4</span> Barreras de abstracción</h2><ul>
<li><p>Parémonos ahora a considerar algunos de las cuestiones planteadas en el ejemplo de los números racionales.</p></li>
<li><p>Hemos definido todas las operaciones de <em>rac</em> en términos de un constructor <code>racional</code> y dos selectores <code>numer</code> y <code>denom</code>.</p>
<p>En general, la idea que hay detrás de la abstracción de datos es la de:</p>
<ul>
<li><p>identificar un conjunto básico de operaciones sobre las cuales se expresarán todas las manipulaciones de valores de algún tipo de datos, y luego</p></li>
<li><p>obligar a usar sólo esas operaciones para manipular los datos.</p></li>
</ul></li>
<li><p>Al obligar a usar las operaciones de esta manera, es mucho más fácil cambiar luego la representación de los datos abstractos o la implementación de las operaciones básicas sin tener que cambiar el resto del programa.</p></li>
</ul></section><section class="slide level4">

<ul>
<li>Para el caso de los números racionales, diferentes partes del programa manipulan números racionales usando diferentes operaciones, como se describe en esta tabla:</li>
</ul>
<table>
<colgroup>
<col style="width: 34%" />
<col style="width: 32%" />
<col style="width: 32%" />
</colgroup>
<thead>
<tr class="header">
<th>Las partes del programa que…</th>
<th>Tratan a los racionales como…</th>
<th>Usando sólo…</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><ul>
<li>Usan números racionales para realizar cálculos</li>
</ul></td>
<td><ul>
<li>Valores de datos completos, un todo</li>
</ul></td>
<td><ul>
<li><code>suma</code>, <code>mult</code>, <code>iguales</code>, <code>imprimir</code></li>
</ul></td>
</tr>
<tr class="even">
<td><ul>
<li>Crean racionales o implementan operaciones sobre racionales</li>
</ul></td>
<td><ul>
<li>Numeradores y denominadores</li>
</ul></td>
<td><ul>
<li><code>racional</code>, <code>numer</code>, <code>denom</code></li>
</ul></td>
</tr>
<tr class="odd">
<td><ul>
<li>Implementan selectores y constructores de racionales</li>
</ul></td>
<td><ul>
<li>Listas de dos elementos</li>
</ul></td>
<td><ul>
<li>Literales de tipo lista e indexación</li>
</ul></td>
</tr>
</tbody>
</table>
</section><section class="slide level4">

<ul>
<li><p>Cada una de las filas de la tabla anterior representa un nivel de abstracción, de forma que cada nivel usa las operaciones y las facilidades ofrecidas por el nivel inmediatamente inferior.</p></li>
<li><p>Dicho de otra forma: en cada nivel, las funciones que aparecen en la última columna imponen una barrera de abstracción. Estas funciones son usadas desde un nivel más alto de abstracción e implementadas usando un nivel más bajo de abstracción.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Se produce una violación de una barrera de abstracción cada vez que una parte del programa que puede utilizar una función de nivel superior utiliza una función de un nivel inferior.</p></li>
<li><p>Por ejemplo, una función que calcula el cuadrado de un número racional se implementa mejor en términos de <code>mult</code>, que no necesita supone nada sobre cómo se implementa un número racional:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1"></a><span class="kw">def</span> cuadrado(x): </span>
<span id="cb26-2"><a href="#cb26-2"></a>    <span class="cf">return</span> mult(x,x)      </span></code></pre></div></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Si hiciéramos referencia directa a los numeradores y los denominadores estaríamos violando una barrera de abstracción:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1"></a><span class="kw">def</span> cuadrado_viola_una_barrera(x): </span>
<span id="cb27-2"><a href="#cb27-2"></a>    <span class="cf">return</span> racional(numer(x) <span class="op">*</span> numer(x), denom(x) <span class="op">*</span> denom(x)) </span></code></pre></div></li>
<li><p>Y si suponemos que los racionales se representan como listas estaríamos violando dos barreras de abstracción:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1"></a><span class="kw">def</span> cuadrado_viola_dos_barreras(x): </span>
<span id="cb28-2"><a href="#cb28-2"></a>    <span class="cf">return</span> [x[<span class="dv">0</span>] <span class="op">*</span> x[<span class="dv">0</span>], x[<span class="dv">1</span>] <span class="op">*</span> x[<span class="dv">1</span>]]    </span></code></pre></div></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Las barreras de abstracción hacen que los programas sean más fáciles de mantener y modificar.</p></li>
<li><p>Cuantas menos funciones dependan de una representación particular, menos cambios se necesitarán cuando se quiera cambiar esa representación.</p></li>
<li><p>Todas las implementaciones de <code>cuadrado</code> que acabamos de ver se comportan correctamente, pero sólo la primera es lo bastante robusta como para soportar bien los futuros cambios de los niveles inferiores.</p></li>
<li><p>La función <code>cuadrado</code> no tendrá que cambiarse incluso aunque cambiemos la representación interna de los números racionales.</p></li>
<li><p>Por el contrario, <code>cuadrado_viola_una_barrera</code> tendrá que cambiarse cada vez que cambien las signaturas del constructor o los selectores, y <code>cuadrado_viola_dos_barreras</code> tendrá que cambiarse cada vez que cambie la representación interna de los números racionales.</p></li>
</ul>
</section><section id="el-tipo-abstracto-como-módulo" class="title-slide slide level2"><h2><span class="header-section-number">4.5</span> El tipo abstracto como módulo</h2><ul>
<li><p>Claramente, un <strong>tipo abstracto</strong> representa una <strong>abstracción</strong>:</p>
<ul>
<li><p>Se <strong>destacan</strong> los detalles (normalmente pocos) de la <strong>especificación</strong>, es decir, el <em>comportamiento observable</em> del tipo. Es de esperar que este aspecto sea bastante estable y cambie poco durante la vida útil del programa.</p></li>
<li><p>Se <strong>ocultan</strong> los detalles (normalmente numerosos) de la <strong>implementación</strong>. Este aspecto es, además, propenso a cambios.</p></li>
</ul></li>
<li><p>Y estas propiedades anteriores hacen que el tipo abstracto sea el concepto ideal alrededor del cual basar la descomposición en módulos de un programa grande.</p></li>
</ul></section><section class="slide level4">

<ul>
<li><p>Recordemos que para que haya una buena modularidad:</p>
<ul>
<li><p>Las <strong>conexiones</strong> del módulo con el resto del programa han de ser pocas y simples. De este modo se espera lograr una relativa independencia en el desarrollo de cada módulo con respecto a los otros.</p></li>
<li><p>La <strong>descomposición</strong> en módulos ha de ser tal que la mayor parte de los cambios y mejoras al programa impliquen modificar sólo un módulo o un número muy pequeño de ellos.</p></li>
<li><p>El <strong>tamaño</strong> de un módulo ha de ser el adecuado: si es demasiado grande, será difícil realizar cambios en él; si es demasiado pequeño, los costes de integración con otros módulos aumenta.</p></li>
</ul></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>La parte del código fuente de un programa dedicada a la definición de un tipo abstracto de datos es un <strong>candidato a módulo</strong> que cumple los siguientes requisitos:</p>
<ul>
<li><p>La <strong>interfaz</strong> del tipo abstracto con sus usuarios es un ejemplo de pocas y simples conexiones con el resto del programa: los usuarios simplemente invocan sus operaciones permitidas. Otras conexiones más peligrosas, como compartir variables entre módulos o compartir el conocimiento acerca de la estructura interna, son imposibles.</p></li>
<li><p>La <strong>implementación</strong> puede cambiarse libremente sin afectar al funcionamiento de los módulos usuarios. Es de esperar, por tanto, que muchos cambios al programa queden localizados en el interior de un sólo módulo.</p></li>
<li><p>El <strong>tamaño</strong> de una sola función que implementa una abstracción funcional es demasiado pequeño para ser útil como unidad modular. En cambio, la definición de un tipo abstracto consta, en general, de una colección de funciones más una representación, lo que proporciona un tamaño más adecuado.</p></li>
</ul></li>
</ul>
</section></section>
<section id="bibliografía" class="title-slide slide level1 unnumbered"><h1>Bibliografía</h1><div id="refs" class="references" role="doc-bibliography">
<div id="ref-pressman_ingenierisoftware:_2004">
<p>Pressman, Roger S, Darrel Ince, Rafael Ojeda Martín, and Luis Joyanes Aguilar. 2004. <em>Ingeniería Del Software: Un Enfoque Práctico</em>. Madrid: McGraw-Hill.</p>
</div>
<div id="ref-python_software_foundation_sitio_nodate">
<p>Python Software Foundation. n.d. “Sitio Web de Documentación de Python.” <a href="https://docs.python.org/3">https://docs.python.org/3</a>.</p>
</div>
</div></section>
    </div>
  </div>

  <script src="reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Display the page number of the current slide
        slideNumber: true,
        // Push each slide change to the browser history
        history: true,
        // Transition style
        transition: 'slide', // none/fade/slide/convex/concave/zoom
        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1280,
        height: 1080,

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'reveal.js/plugin/notes/notes.js', async: true },
          { src: 'reveal.js/plugin/reveal.js-menu/menu.js', async: true },
          { src: 'reveal.js/plugin/reveal.js-quiz/quiz/js/quiz.js', async: true, callback: function() { prepareQuizzes({preventUnanswered: true, checkAnswerText: 'Comprueba la respuesta', nextQuestionText: 'Siguiente &raquo;', backButtonText: '&laquo; Anterior', tryAgainText: 'Prueba de nuevo', preventUnansweredText: 'Selecciona una respuesta', questionCountText: 'Pregunta %current de %total', skipStartButton: true}); } },
          { src: 'reveal.js/plugin/search/search.js', async: true },
          { src: 'reveal.js/plugin/customcontrols/customcontrols.js', async: true }
        ],

        customcontrols: {
          controls: [
            { icon: '<i class="fa fa-question-circle"></i>',
                         css: 'position: fixed; right: 50px; bottom: 50px; z-index: 30; font-size: 24px;',
                         action: 'Reveal.toggleHelp(); return false;'
                       }
          ]
        },

        menu: {
          numbers: true,
          hideMissingTitles: true,
          themes: true,
          themesPath: 'reveal.js/css/theme/'
        }
      });
    </script>
    </body>
</html>
