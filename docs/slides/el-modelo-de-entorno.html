<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Ricardo Pérez López">
  <title>El modelo de entorno</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=1280">
  <link rel="stylesheet" href="./reveal.js/dist/reset.css">
  <link rel="stylesheet" href="./reveal.js/dist/reveal.css">
  <style>
    .reveal .sourceCode {  /* see #7635 */
      overflow: visible;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      { color: #268bd2;  }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #cb4b16; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #d33682; } /* BaseN */
    code span.bu { color: #4070a0; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #dc322f; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #93a1a1; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #6c71c4; } /* DataType */
    code span.dv { color: #d33682; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #d33682; } /* Float */
    code span.fu { color: #4070a0; } /* Function */
    code span.im { font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #268bd2; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #a57800; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #2aa198; } /* SpecialString */
    code span.st { color: #2aa198; } /* String */
    code span.va { color: #6c71c4; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    /* CSS for citations */
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
      margin-bottom: 0em;
    }
    .hanging-indent div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }  </style>
  <link rel="stylesheet" href="./reveal.js/dist/theme/solarized.css" id="theme">
  <link rel="stylesheet" href="custom.css"/>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css" />
  <link href="https://fonts.googleapis.com/css?family=Lato&display=swap" rel="stylesheet">
  <style type="text/css">
      #header-left {
          position: absolute;
          font-size: 25%;
          top: 0%;
          left: 0%;
          margin-left: 10px;
          margin-top: 10px;
      }
      #header-right {
          position: absolute;
          font-size: 25%;
          top: 0%;
          right: 0%;
          margin-right: 10px;
          margin-top: 10px;
      }
      #footer-left {
          position: absolute;
          font-size: 25%;
          bottom: 0%;
          left: 0%;
          margin-left: 10px;
          margin-bottom: 10px;
      }
  </style>
</head>
<body>
<div id="hidden" style="display:none;">
    <div id="header">
        <div id="header-left"></div>
        <div id="header-right"></div>
        <div id="footer-left"></div>
    </div>
</div>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">El modelo de entorno</h1>
  <p class="author">Ricardo Pérez López</p>
  <p class="date">IES Doñana, curso 2025/2026</p>
</section>
<section id="TOC">
<nav role="doc-toc"> 
<ul>
<li><a href="#/ámbitos" id="/toc-ámbitos"><span
class="toc-section-number">1</span> Ámbitos</a></li>
<li><a href="#/entorno" id="/toc-entorno"><span
class="toc-section-number">2</span> Entorno</a></li>
<li><a href="#/evaluación-con-entornos"
id="/toc-evaluación-con-entornos"><span
class="toc-section-number">3</span> Evaluación con entornos</a></li>
<li><a href="#/la-pila-de-control" id="/toc-la-pila-de-control"><span
class="toc-section-number">4</span> La pila de control</a></li>
<li><a href="#/estrategias-de-evaluación"
id="/toc-estrategias-de-evaluación"><span
class="toc-section-number">5</span> Estrategias de evaluación</a></li>
</ul>
</nav>
</section>

<section>
<section id="ámbitos" class="title-slide slide level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span>
Ámbitos</h1>

</section>
<section id="ámbitos-léxicos" class="title-slide slide level2"
data-number="1.1">
<h2 data-number="1.1"><span class="header-section-number">1.1</span>
Ámbitos léxicos</h2>
<ul>
<li><p>Un <strong>ámbito léxico</strong> (también llamado <strong>ámbito
estático</strong>) es una porción del código fuente de un
programa.</p></li>
<li><p>Decimos que <strong>ciertas construcciones sintácticas
<em>determinan</em> ámbitos léxicos</strong>, o que
<strong><em>introducen</em> un nuevo ámbito léxico</strong>.</p></li>
<li><p>Cuando una construcción determina un ámbito léxico, <strong>la
sintaxis del lenguaje establece dónde empieza y acaba</strong> ese
ámbito léxico en el código fuente.</p></li>
<li><p>Por tanto, siempre se puede determinar sin ambigüedad si
<strong>una instrucción situada en un punto concreto del programa está
dentro de un determinado ámbito léxico</strong>, tan sólo leyendo el
código fuente del programa y sin necesidad de ejecutarlo.</p></li>
<li><p>Eso significa que el concepto de <em>ámbito léxico</em> es un
concepto <strong>estático</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.1.0.0.1">

<ul>
<li><p>Además de los ámbitos léxicos, existen también los llamados
<strong>ámbitos dinámicos</strong>, que funcionan de otra forma y que no
estudiaremos en este curso.</p></li>
<li><p>La mayoría de los lenguajes de programación usan ámbitos léxicos,
salvo excepciones (como LISP o los <em>shell scripts</em>) que usan
ámbitos dinámicos.</p></li>
<li><p>Por esa razón, a partir de ahora, cuando hablemos de «ámbitos»
sin especificar de qué tipo, nos estaremos siempre refiriendo a «ámbitos
léxicos».</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.1.0.0.2">

<ul>
<li><p>Por ejemplo: en el lenguaje de programación Java, los
<em>bloques</em> son estructuras sintácticas delimitadas por llaves
<code>{</code> y <code>}</code> que contienen instrucciones.</p></li>
<li><p>Los bloques de Java determinan ámbitos léxicos; por tanto, si una
instrucción está dentro de un bloque (es decir, si está situada entre
las llaves <code>{</code> y <code>}</code> que delimitan el bloque),
entonces esa instrucción se encuentra dentro del ámbito léxico que
define el bloque.</p></li>
<li><p>En Python, <strong>las expresiones lambda determinan ámbitos
léxicos</strong>, así que, cada vez que creamos una expresión lambda,
estamos introduciendo un nuevo ámbito en el código fuente de nuestro
programa.</p></li>
<li><p>En concreto, el ámbito que determina una expresión lambda viene
delimitado por su <strong>cuerpo</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.1.0.0.3">

<ul>
<li><p>Los ámbitos <strong>se pueden anidar recursivamente</strong>, o
sea, que pueden estar contenidos unos dentro de otros.</p></li>
<li><p>Por tanto, una instrucción puede estar en varios ámbitos al mismo
tiempo (anidados unos dentro de otros).</p></li>
<li><p>De todos ellos, el <strong>ámbito más interno</strong> es el que
no contiene, a su vez, a ningún otro ámbito.</p></li>
<li><p>Definimos el <strong>ámbito de una instrucción</strong> como el
ámbito más interno en el que se encuentra dicha instrucción.</p></li>
<li><p>Según lo anterior, en un momento dado, el <strong>ámbito
actual</strong> es el ámbito de la instrucción actual, es decir, el
ámbito más interno en el que se encuentra la instrucción que se está
ejecutando actualmente.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.1.0.0.4">

<ul>
<li><p>Decimos que los ámbitos léxicos cumplen la <strong>propiedad de
la estructura</strong>.</p></li>
<li><p>Una <strong>estructura</strong> es una construcción sintáctica
que puede <strong>anidarse completamente</strong> dentro de otras
estructuras, de forma que, dadas dos estructuras cualesquiera, o una
está incluida completamente dentro de la otra, o no se tocan en
absoluto.</p></li>
<li><p>Por tanto, los bordes de dos ámbitos léxicos nunca pueden
cruzarse:</p></li>
</ul>
<div class="columns">
<div class="column">
<div class="centered">
<figure>
<img data-src="images/estructuras-anidadas.svg" class="plain"
style="width:35.0%" alt="Ámbitos léxicos anidados" />
<figcaption aria-hidden="true">Ámbitos léxicos anidados</figcaption>
</figure>
</div>
</div><div class="column">
<div class="centered">
<figure>
<img data-src="images/estructuras-que-se-cruzan.svg" class="plain"
style="width:35.0%"
alt="Estas no son estructuras, y por tanto no pueden ser ámbitos" />
<figcaption aria-hidden="true">Estas no son estructuras, y por tanto no
pueden ser ámbitos</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="ámbito-global" class="title-slide slide level3"
data-number="1.1.1">
<h3 data-number="1.1.1"><span class="header-section-number">1.1.1</span>
Ámbito global</h3>
<!--

- El concepto de _ámbito_ no es nada trivial y, a medida que vayamos
  incorporando nuevos elementos al lenguaje, tendremos que ir adaptándolo para
  tener en cuenta más condicionantes.

-->
<ul>
<li><p>Un ámbito que siempre existe en cualquier programa es el llamado
<strong>ámbito global</strong>:</p>
<ul>
<li><p>Si se está ejecutando un <em>script</em> en el intérprete por
lotes (con <code>python script.py</code>), <strong>el <em>ámbito
global</em> abarca todo el <em>script</em></strong>, desde la primera
instrucción hasta la última.</p></li>
<li><p>Si estamos en el intérprete interactivo (con <code>python</code>
o <code>ipython3</code>), el <em>ámbito global</em> abarca <strong>toda
nuestra sesión con el intérprete</strong>, desde que arrancamos la
sesión hasta que finalizamos la misma.</p></li>
</ul></li>
<li><p>Por tanto:</p>
<ul>
<li><p>En el momento en que se empieza a ejecutar un <em>script</em> o
se arranca una sesión con el intérprete interactivo, <strong>se
entra</strong> en el <em>ámbito global</em>.</p></li>
<li><p>Del ámbito global sólo <strong>se sale</strong> cuando se
finaliza la ejecución del <em>script</em> o se cierra el intérprete
interactivo.</p></li>
</ul></li>
</ul>
</section>
<section id="ejemplos" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejemplos</h5>
<ul>
<li><p>Por ejemplo, en la siguiente línea de código:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>suma <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span></code></pre></div>
<p>el cuerpo de la función <code class="sourceCode python">suma</code>
determina un ámbito.</p></li>
<li><p>Por tanto, en el siguiente código tenemos dos ámbitos: el ámbito
global (más externo) y el ámbito del cuerpo de la expresión lambda (más
interno y anidado dentro del ámbito global):</p>
<div class="centered">
<p><img data-src="images/ambitos-anidados.png" class="plain"
style="width:60.0%" /></p>
</div></li>
</ul>
</section>
<section class="slide level5" data-number="1.1.1.0.1">

<ul>
<li><p>En este otro ejemplo más complicado, tenemos el siguiente
<em>script</em>:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode numberSource python number-lines"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a>w <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>f <span class="op">=</span> <span class="kw">lambda</span> x, y: <span class="dv">5</span> <span class="op">+</span> (<span class="kw">lambda</span> z: z <span class="op">+</span> <span class="dv">3</span>)(x <span class="op">+</span> y)</span>
<span id="cb2-3"><a href="#cb2-3"></a>r <span class="op">=</span> f(<span class="dv">2</span>, <span class="dv">4</span>)</span>
<span id="cb2-4"><a href="#cb2-4"></a>m <span class="op">=</span> (<span class="kw">lambda</span> x: x <span class="op">**</span> <span class="dv">2</span>)(<span class="dv">3</span>)</span></code></pre></div>
<p>donde existen cuatro ámbitos:</p>
<div class="centered">
<p><img data-src="images/cuatro-ambitos.png" class="plain"
style="width:100.0%" /></p>
</div></li>
</ul>
</section>


<section id="ámbito-de-una-instrucción-y-de-una-ligadura"
class="title-slide slide level2" data-number="1.2">
<h2 data-number="1.2"><span class="header-section-number">1.2</span>
Ámbito de una instrucción y de una ligadura</h2>
<ul>
<li><p>El <strong>ámbito de una instrucción</strong> es el ámbito actual
de esa instrucción, es decir, el ámbito más interno donde aparece esa
instrucción.</p></li>
<li><p>El <strong>ámbito de una ligadura</strong> es el ámbito de la
instrucción que, al ejecutarse, creará la ligadura (es decir, el ámbito
más interno donde aparece la instrucción que, al ejecutarse, creará la
ligadura en tiempo de ejecución).</p></li>
<li><p>Si la instrucción que crea la ligadura es una definición,
hablamos de «ámbito de una definición».</p></li>
<li><p>Decimos que la <em>instrucción</em> (y la <em>ligadura</em>
correspondiente que se creará al ejecutar esa instrucción) es
<strong>local</strong> a su ámbito.</p></li>
<li><p>Si ese ámbito es el ámbito <em>global</em>, decimos que la
<em>instrucción</em> (y la <em>ligadura</em> que se creará al ejecutar
esa instrucción) es <strong>global</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.2.0.0.1">

<ul>
<li><p>Por ejemplo, en el siguiente <em>script</em> se ejecutan cuatro
definiciones:</p>
<div class="centered">
<p><img data-src="images/ambito-global.png" class="plain"
style="width:40.0%" /></p>
</div></li>
<li><p>El ámbito de cada una de las instrucciones es el ámbito
<em>global</em>, que es el único ámbito que existe en el
<em>script</em>.</p></li>
<li><p>En consecuencia:</p>
<ul>
<li><p>Las cuatro definiciones tienen <strong>ámbito global</strong> (y
son, por tanto, <strong>definiciones globales</strong>).</p></li>
<li><p>Cuando se ejecuten, esas definiciones crearán <strong>ligaduras
globales</strong>.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="1.2.0.0.2">

<ul>
<li><p>Como estamos usando un lenguaje de programación que trabaja con
<em>ámbitos léxicos</em>, <strong>el ámbito de una instrucción siempre
vendrá determinado por una <em>construcción sintáctica</em></strong> del
lenguaje.</p></li>
<li><p>Por tanto:</p>
<ul>
<li><p>Sus <em>límites</em> vienen marcados únicamente por la
<em>sintaxis</em> de la construcción que determina el ámbito de esa
definición.</p></li>
<li><p>El ámbito de la instrucción se puede determinar simplemente
leyendo el código fuente del programa, observando dónde empieza y dónde
acaba esa construcción, sin tener que ejecutarlo.</p>
<p>Es decir, que se puede determinar de forma
<em>estática</em>.</p></li>
</ul></li>
</ul>
</section>
<section id="visibilidad" class="title-slide slide level3"
data-number="1.2.1">
<h3 data-number="1.2.1"><span class="header-section-number">1.2.1</span>
Visibilidad</h3>
<ul>
<li><p>La visibilidad de una ligadura indica en qué lugares del código
fuente del programa es visible y accesible esa ligadura.</p></li>
<li><p>Una ligadura puede existir en un punto concreto del programa,
pero en cambio no ser accesible en ese mismo punto.</p></li>
<li><p>Para determinar las reglas de visibilidad de una ligadura,
existen dos posibilidades, dependiendo de si la ligadura está ligando un
atributo de un objeto, o no.</p></li>
<li><p>Veamos cada caso con detalle.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.2.1.0.1">

<ol type="1">
<li><p>Si el identificador ligado es un <strong>atributo de un
objeto</strong>, la ligadura sólo será visible dentro del objeto.</p>
<p>En tal caso, decimos que la visibilidad de la ligadura (y del
correspondiente atributo ligado) es <strong>local al objeto</strong> que
contiene el atributo.</p>
<p>Eso significa que debemos indicar (usando el operador punto
(<code>.</code>)) el objeto que contiene a la ligadura para poder
acceder a ella, lo que significa que también debemos tener acceso al
propio objeto que la contiene.</p></li>
</ol>
</section>
<section class="slide level5" data-number="1.2.1.0.2">

<ol start="2" type="1">
<li><p>Si el identificador ligado <strong>NO es un atributo de un
objeto</strong>, la ligadura sólo será visible dentro del ámbito donde
se definió la ligadura.</p>
<p>Ese ámbito representa una «región» cuyas fronteras limitan la porción
del código fuente en la que es visible esa ligadura.</p>
<p>En tal caso, decimos que la <strong>visibilidad</strong> de la
ligadura es <strong>local a su ámbito</strong>.</p>
<p>Eso significa que <strong>no es posible acceder a esa ligadura fuera
de su ámbito</strong>; sólo es visible dentro de él.</p>
<p>En cambio, si el ámbito de la ligadura contiene dentro otro ámbito
anidado, sí que podremos acceder a la ligadura dentro de ese ámbito más
interno, ya que técnicamente seguiría estando dentro de su ámbito.</p>
<p>Si el ámbito es el global, decimos que la ligadura tiene
<strong>visibilidad global</strong>.</p></li>
</ol>
</section>
<section class="slide level5" data-number="1.2.1.0.3">

<ul>
<li><p>Suponiendo que tenemos los siguientes cuatro ámbitos,
identificados con las letras A, B, C y D:</p>
<div class="columns">
<div class="column" style="width:40%;">
<div class="centered">
<figure>
<img data-src="images/estructuras-anidadas.svg" class="plain"
style="width:45.0%" alt="Ámbitos léxicos anidados" />
<figcaption aria-hidden="true">Ámbitos léxicos anidados</figcaption>
</figure>
</div>
</div><div class="column" style="width:60%;">
<ul>
<li><p>A puede ver los nombres definidos en A, pero no los definidos en
B, C o D.</p></li>
<li><p>B puede ver los nombres definidos en A y B, pero no los definidos
en C o D.</p></li>
<li><p>C puede ver los nombres definidos en A, B y C, pero no los
definidos en D.</p></li>
<li><p>D puede ver los nombres definidos en A y D, pero no los definidos
en B o C.</p></li>
</ul>
</div>
</div></li>
</ul>
</section>

<section id="tiempo-de-vida" class="title-slide slide level3"
data-number="1.2.2">
<h3 data-number="1.2.2"><span class="header-section-number">1.2.2</span>
Tiempo de vida</h3>
<ul>
<li><p>El <strong>tiempo de vida</strong> de una ligadura representa el
periodo de tiempo durante el cual <em>existe</em> esa ligadura, es
decir, el periodo comprendido desde su creación y almacenamiento en la
memoria hasta su posterior destrucción.</p></li>
<li><p>En la mayoría de los lenguajes (incluyendo Python y Java), una
ligadura <strong>empieza a existir</strong> justo cuando se crea, es
decir, en el punto donde se ejecuta la instrucción que define la
ligadura.</p>
<p>Por tanto, no es posible <em>acceder</em> a esa ligadura
<em>antes</em> de ese punto, ya que no existe hasta entonces.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.2.2.0.1">

<ul>
<li><p>Por otra parte, el momento en que una ligadura <strong>deja de
existir</strong> depende si el identificador ligado es un atributo de un
objeto, o no:</p>
<ul>
<li><p>Si el identificador ligado es un atributo de un objeto, la
ligadura dejará de existir cuando se elimine el objeto de la memoria, o
bien, cuando se elimine el propio atributo ligado.</p></li>
<li><p>En caso contrario, la ligadura dejará de existir allí donde
termine el ámbito de la ligadura.</p></li>
</ul></li>
<li><p>Es importante hacer notar que, en un momento dado, una ligadura
puede existir pero no ser visible.</p></li>
<li><p>Por ejemplo, si una ligadura local y una global vinculan el mismo
identificador, la local «hace sombra» a la global, cosa que estudiaremos
con más profundidad posteriormente.</p></li>
</ul>
<!--

- Eso significa que la **visibilidad** de una ligadura y el **acceso** a una
  ligadura son conceptos distintos:

  - La **visibilidad** de una ligadura la define su ámbito, y es, por tanto, un
    concepto **_estático_**.

  - La posibilidad de **acceder** a una ligadura depende de si esa ligadura ya
    se ha creado previamente al intentar acceder a ella durante la ejecución
    del programa, y es un concepto **_estático_** si el lenguaje es compilado,
    o **_dinámico_** si es interpretado.

-->
</section>

<section id="almacenamiento" class="title-slide slide level3"
data-number="1.2.3">
<h3 data-number="1.2.3"><span class="header-section-number">1.2.3</span>
Almacenamiento</h3>
<ul>
<li><p>Sabemos que las ligaduras se almacenan en <em>espacios de
nombres</em>.</p></li>
<li><p>En Python, hay dos lugares donde se pueden almacenar ligaduras y,
por tanto, <strong>hay dos posibles espacios de nombres: los
<em>objetos</em> y los <em>marcos</em></strong>.</p></li>
<li><p>Así que tenemos dos posibilidades:</p>
<ol>
<li><p>Si el identificador que se está ligando es un <em>atributo</em>
de un objeto, entonces la ligadura se almacenará en el objeto, junto con
el propio atributo.</p></li>
<li><p>En caso contrario, la ligadura se almacenará en un marco, el cual
depende del <em>ámbito actual</em>.</p></li>
</ol></li>
<li><p>Veamos cada caso con más detalle.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.2.3.0.1">

<ol type="1">
<li><p>Cuando se crea una ligadura dentro de un objeto en Python usando
el operador punto (<code>.</code>), <strong>el espacio de nombres será
el propio objeto</strong>, ya que los objetos son espacios de nombres en
Python.</p>
<p>En tal caso, la ligadura asocia un valor con un <em>atributo</em> del
objeto, y tanto el atributo como la ligadura se almacenan dentro del
objeto.</p>
<p>Por ejemplo, si en Python hacemos:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>math.x <span class="op">=</span> <span class="dv">75</span></span></code></pre></div>
<p>estamos creando la ligadura <code>x</code> → <code>75</code> en el
espacio de nombres que representa el módulo <code>math</code>, el cual
es un objeto en Python y, por tanto, es quien almacena la ligadura.</p>
<p>Así que el espacio de nombres ha sido seleccionado a través del
operador punto (<code>.</code>) para resolver el atributo dentro del
objeto, y no depende del ámbito donde se encuentre la sentencia <code
class="sourceCode python">math.x <span class="op">=</span> <span class="dv">75</span></code>.</p>
<p>Diremos que la ligadura es <strong>local</strong> al objeto.</p></li>
</ol>
</section>
<section class="slide level5" data-number="1.2.3.0.2">

<ol start="2" type="1">
<li><p>Si la ligadura no se crea dentro de un objeto usando el operador
punto (<code>.</code>), entonces el espacio de nombres irá asociado al
ámbito y, en este caso, <strong>ese espacio de nombres siempre será un
marco</strong>.</p>
<p>Ese marco será el que corresponda al <em>ámbito actual</em>, es
decir, el ámbito más interno en el que se encuentra la instrucción que
crea la ligadura.</p>
<p>Cuando el ámbito es el <em>ámbito global</em> (y, por tanto, la
ligadura se almacena en el marco global), se dice que la ligadura es
<strong>global</strong>.</p>
<p>En caso contrario, decimos que es <strong>local</strong> al ámbito, y
se almacenará en el marco correspondiente a ese ámbito.</p></li>
</ol>
</section>
<section id="ejemplo" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejemplo</h5>
<ul>
<li><p>En el siguiente ejemplo vemos cómo hay varias definiciones que,
al ejecutarse, crearán ligaduras en un determinado ámbito, pero no en un
objeto (ya que no se están creando atributos dentro de ningún
objeto):</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode numberSource python number-lines"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a>x <span class="op">=</span> <span class="dv">25</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>y <span class="op">=</span> <span class="dv">99</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>z <span class="op">=</span> y</span>
<span id="cb4-4"><a href="#cb4-4"></a>nombre <span class="op">=</span> <span class="st">&#39;Manolo&#39;</span></span></code></pre></div></li>
<li><p>Todas esas definiciones son globales y, por tanto, las ligaduras
que crean al ejecutarse son ligaduras globales o de ámbito global, y se
almacenan en el marco global.</p></li>
<li><p>Al no tratarse de atributos de objetos, la visibilidad vendrá
determinada por sus ámbitos.</p></li>
<li><p>En consecuencia, la visibilidad de todas esas ligaduras será el
ámbito global, ya que son ligaduras globales. Por tanto, decimos que su
<strong>visibilidad</strong> es <strong>global</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.2.3.0.3">

<ul>
<li><p>Por otra parte, como esas ligaduras no se crean sobre atributos
de objetos, empezarán a existir justo donde se crean, y terminarán de
existir al final de su ámbito.</p></li>
<li><p>Por ejemplo, la ligadura <code>y</code> → <code>99</code>
empezará a existir en la línea 2 y terminará al final del
<em>script</em>, que es donde termina su ámbito (que, en este ejemplo,
es el ámbito global).</p></li>
<li><p>En consecuencia, el <strong>tiempo de vida</strong> de la
ligadura será el periodo comprendido desde su creación (en la línea 2)
hasta el final de su ámbito.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.2.3.0.4">

<ul>
<li><p>Cuando la ligadura se crea sobre un <strong>atributo</strong> de
un <em>objeto</em> de Python, entonces ese objeto almacenará la ligadura
y será, por tanto, su espacio de nombres.</p></li>
<li><p>Recordemos que, por ejemplo, cuando importamos un módulo usando
la sentencia <code
class="sourceCode python"><span class="im">import</span></code>, podemos
acceder al objeto que representa ese módulo usando su nombre, lo que nos
permite acceder a sus atributos y crear otros nuevos.</p></li>
<li><p>Esos atributos y sus ligaduras correspondientes sólo son visibles
cuando accedemos a ellos usando el operador punto (<code>.</code>) a
través del objeto que lo contiene.</p></li>
<li><p>Por tanto, los atributos no son visibles fuera del objeto, y
debemos usar el operador punto (<code>.</code>) para acceder a ellos (su
visibilidad es local al objeto que los contiene).</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.2.3.0.5">

<ul>
<li><p>Por ejemplo:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> math</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> math.pi</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="fl">3.141592653589793</span>     <span class="co"># El nombre &#39;pi&#39; es visible dentro del objeto</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> pi                <span class="co"># El nombre &#39;pi&#39; no es visible fuera del objeto</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>Traceback (most recent call last):</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="pp">NameError</span>: name <span class="st">&#39;pi&#39;</span> <span class="kw">is</span> <span class="kw">not</span> defined</span></code></pre></div></li>
<li><p>Igualmente, si creamos un nuevo atributo dentro del objeto, la
ligadura entre el atributo y su valor sólo existirá en el propio objeto
y, por tanto, sólo será visible cuando accedamos al atributo a través
del objeto donde se ha creado.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> math</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> math.x <span class="op">=</span> <span class="dv">95</span>       <span class="co"># Creamos un nuevo atributo en el objeto</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> math.x            <span class="co"># El nombre &#39;x&#39; es visible dentro del objeto</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="dv">95</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> x                 <span class="co"># El nombre &#39;x&#39; no es visible fuera del objeto</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>Traceback (most recent call last):</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="pp">NameError</span>: name <span class="st">&#39;x&#39;</span> <span class="kw">is</span> <span class="kw">not</span> defined</span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="1.2.3.0.6">

<ul>
<li><p>Resumiendo:</p>
<ul>
<li><p>Para poder acceder a un atributo de un objeto, debemos acceder
primero al objeto y usar el operador punto (<code>.</code>).</p></li>
<li><p>Por tanto, la <strong>visibilidad</strong> de su ligadura
correspondiente no vendrá determinada por un ámbito, sino por el objeto
que contiene al atributo (y que, por consiguiente, también contiene a su
ligadura).</p>
<p>En tal caso, diremos que la visibilidad es local al objeto que
contiene el atributo.</p></li>
<li><p>Por otra parte, el <strong>tiempo de vida</strong> de la ligadura
será el tiempo que permanezca el atributo en el objeto, ligado a algún
valor.</p></li>
</ul></li>
</ul>
</section>
<section id="resumen" class="title-slide slide level4"
data-number="1.2.3.1">
<h4 data-number="1.2.3.1"><span
class="header-section-number">1.2.3.1</span> Resumen</h4>
<div class="caja">
<p><strong>Ámbito (léxico):</strong></p>
<p>Porción del código fuente de un programa. Los límites de ese ámbito
sólo vienen determinados por la sintaxis del lenguaje, ya que ciertas
construcciones sintácticas determinan su propio ámbito.</p>
</div>
<div class="caja">
<p><strong>Ámbito de una instrucción:</strong></p>
<p>El ámbito actual de la instrucción; es decir: el ámbito más interno
donde aparece la instrucción.</p>
</div>
<div class="caja">
<p><strong>Ámbito de una ligadura:</strong></p>
<p>El ámbito de la instrucción que creará la ligadura en tiempo de
ejecución.</p>
</div>
</section>
<section class="slide level5" data-number="1.2.3.1.1">

<div class="caja">
<p><strong>Visibilidad de una ligadura:</strong></p>
<p>Determina dónde es visible una ligadura dentro del programa.</p>
<p>Esa visibilidad depende de si el identificador ligado es un atributo
de un objeto o no:</p>
<ol type="a">
<li><p>Si es un atributo de un objeto, la visibilidad lo determina el
objeto que contiene la ligadura.</p></li>
<li><p>En caso contrario, la visibilidad lo determina el ámbito de la
ligadura.</p></li>
</ol>
</div>
</section>
<section class="slide level5" data-number="1.2.3.1.2">

<div class="caja">
<p><strong>Tiempo de vida de una ligadura:</strong></p>
<p>El periodo de tiempo durante el cual <em>existe</em> esa ligadura, es
decir, el periodo comprendido desde su creación y almacenamiento en la
memoria hasta su posterior destrucción.</p>
<p>Su tiempo de vida empieza siempre en el momento en que se crea la
ligadura, y su final depende de si el identificador ligado es un
atributo de un objeto o no:</p>
<ol type="a">
<li><p>Si es un atributo de un objeto, el tiempo de vida acabará cuando
se destruya el objeto que lo contiene (o cuando se elimine el atributo
ligado).</p></li>
<li><p>En caso contrario, el tiempo de vida acabará al final del ámbito
de la ligadura.</p></li>
</ol>
</div>
</section>
<section class="slide level5" data-number="1.2.3.1.3">

<div class="caja">
<p><strong>Almacenamiento de una ligadura:</strong></p>
<p>Determina el <strong>espacio de nombres</strong> donde se almacenará
la ligadura:</p>
<ol type="a">
<li><p>Si el identificador ligado es un atributo de un objeto, el
espacio de nombres será el objeto que lo contiene.</p></li>
<li><p>En caso contrario, el espacio de nombres será el marco asociado
al ámbito de la ligadura.</p></li>
</ol>
</div>
</section>



<section id="ámbito-de-un-identificador"
class="title-slide slide level2" data-number="1.3">
<h2 data-number="1.3"><span class="header-section-number">1.3</span>
Ámbito de un identificador</h2>
<ul>
<li><p>A veces, por economía del lenguaje, se suele hablar del
«<strong><em>ámbito de un identificador</em></strong>», en lugar de
hablar del «<em>ámbito de la ligadura que liga ese identificador con un
valor</em>».</p></li>
<li><p>Por ejemplo, en el siguiente <em>script</em>:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="dv">25</span></span></code></pre></div>
<p>tenemos que:</p>
<ul>
<li><p>En el ámbito global, hay una definición que liga al identificador
<code class="sourceCode python">x</code> con el valor <code
class="sourceCode python"><span class="dv">25</span></code>.</p></li>
<li><p>Por tanto, se dice que <strong>el <em>ámbito de esa ligadura</em>
es el ámbito global</strong>.</p></li>
<li><p>Pero también se suele decir que «<em>el identificador <code
class="sourceCode python">x</code> es global</em>» o, simplemente, que
«<em><code class="sourceCode python">x</code> es global</em>».</p></li>
</ul></li>
<li><p>O sea, se <strong>asocia al ámbito</strong> no la ligadura, sino
<strong>el identificador en sí</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.3.0.0.1">

<ul>
<li><p>Pero hay que tener cuidado, ya que ese mismo identificador puede
aparecer en ámbitos diferentes y, por tanto, ligarse en ámbitos
diferentes.</p></li>
<li><p>Así que no tendría sentido hablar del ámbito que tiene ese
identificador (ya que podría tener varios) sino, más bien, <strong>del
ámbito que tiene <em>una aparición concreta</em> de ese
identificador</strong>.</p></li>
<li><p>Por eso, sólo deberíamos hablar del ámbito de un identificador
cuando no haya ninguna ambigüedad respecto a qué aparición concreta nos
estamos refiriendo.</p></li>
<li><p>Por ejemplo, en el siguiente <em>script</em>:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode numberSource python number-lines"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a>x <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>suma <span class="op">=</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">2</span>, <span class="dv">3</span>)</span></code></pre></div>
<p>el identificador <code class="sourceCode python">x</code> que aparece
en la línea 1 y el identificador <code
class="sourceCode python">x</code> que aparece en la línea 2 pertenecen
a ámbitos distintos (como veremos en breve) aunque sea el mismo
identificador.</p></li>
</ul>
</section>

<section id="ámbito-de-un-parámetro" class="title-slide slide level2"
data-number="1.4">
<h2 data-number="1.4"><span class="header-section-number">1.4</span>
Ámbito de un parámetro</h2>
<ul>
<li><p>Sabemos que el cuerpo de la expresión lambda determina un
ámbito.</p></li>
<li><p>Por ejemplo, supongamos la siguiente llamada a una expresión
lambda:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">2</span>, <span class="dv">3</span>)</span></code></pre></div></li>
<li><p><strong>Al llamar a la expresión lambda</strong> (es decir, al
aplicar la expresión lambda a unos argumentos), se empieza a ejecutar su
cuerpo y, por tanto, <strong>se entra en dicho ámbito</strong>.</p></li>
<li><p>En ese momento, <strong>se crea un nuevo marco</strong> en la
memoria, que representa esa ejecución concreta de dicha expresión
lambda.</p></li>
<li><p>Lo que ocurre justo a continuación es que <strong>cada parámetro
de la expresión lambda se liga a uno de los argumentos</strong> en el
orden en que aparecen en la llamada a la expresión lambda (primer
parámetro con primer argumento, segundo con segundo, etcétera).</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.4.0.0.1">

<ul>
<li><p>En el ejemplo anterior, es como si el intérprete ejecutara las
siguientes definiciones dentro del ámbito de la expresión lambda:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> <span class="dv">3</span></span></code></pre></div></li>
<li><p>Las ligaduras creadas por esas definiciones <strong>se almacenan
en el marco de la llamada a la expresión lambda</strong>.</p></li>
<li><p>Ese marco se eliminará de la memoria al salir del ámbito de la
expresión lambda, es decir, cuando se termine de ejecutar el cuerpo de
la expresión lambda al finalizar la llamada a la misma.</p>
<p>Por tanto, las ligaduras se destruyen de la memoria al eliminarse el
marco que las almacena.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.4.0.0.2">

<ul>
<li><p>La próxima vez que se llame a la expresión lambda, se volverán a
ligar sus parámetros, esta vez con los argumentos que haya en esa
llamada.</p></li>
<li><p>Por ejemplo, supongamos que tenemos esta situación:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>suma <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> suma(<span class="dv">4</span>, <span class="dv">3</span>)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> suma(<span class="dv">8</span>, <span class="dv">9</span>)</span></code></pre></div></li>
<li><p>En la primera llamada, se entrará en el ámbito determinado por el
cuerpo de la expresión lambda, se creará el marco que representa a esa
llamada, y se ejecutarán las siguientes definiciones dentro del
ámbito:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> <span class="dv">3</span></span></code></pre></div>
<p>lo que creará las correspondientes ligaduras y las almacenará en el
marco de esa llamada.</p>
<p>Despues, evaluará el cuerpo de la expresión lambda y devolverá el
resultado, saliendo del cuerpo de la expresión lambda y, por tanto, del
ámbito que determina dicho cuerpo, lo que hará que se destruya el marco
y, en consecuencia, las ligaduras que contiene.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.4.0.0.3">

<ul>
<li><p>En la siguiente llamada ocurrirá lo mismo pero, esta vez, las
definiciones que se ejecutarán serán las siguientes:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="dv">8</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> <span class="dv">9</span></span></code></pre></div>
<p>lo que creará otras ligaduras, que serán destruidas luego cuando se
destruya el marco que las contiene, al finalizar la ejecución del cuerpo
de la expresión lambda.</p></li>
<li><p>Es importante hacer notar que <strong>en ningún momento se está
haciendo un <em>rebinding</em> de los parámetros</strong>, ya que cada
vez que se llama de nuevo a la expresión lambda, se está creando una
ligadura nueva sobre un identificador que no estaba ligado.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.4.0.0.4">

<ul>
<li><p>En consecuencia, podemos decir que:</p>
<ul>
<li><p>El <strong>ámbito de la ligadura</strong> entre un parámetro y su
argumento es el <strong>cuerpo</strong> de la expresión lambda, así que
la <strong>visibilidad</strong> del parámetro (y de la ligadura) es ese
cuerpo.</p></li>
<li><p>Esa ligadura se crea justo después de entrar en ese ámbito, así
que se puede acceder a ella en cualquier parte del cuerpo de la
expresión lambda, por lo que su <strong>tiempo de vida</strong> va desde
el principio hasta el final de la llamada.</p></li>
<li><p>El <strong>espacio de nombres</strong> que almacena las ligaduras
entre parámetros y argumentos es el <strong>marco</strong> que se crea
al llamar a la expresión lambda.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="1.4.0.0.5">

<ul>
<li><p>Esto se resume diciendo que «el <strong>ámbito de un
parámetro</strong> es el <strong>cuerpo</strong> de su expresión
lambda».</p></li>
<li><p>También se dice que el parámetro tiene un <strong>ámbito
<em>local</em></strong> y un <strong>almacenamiento
<em>local</em></strong> al cuerpo de la expresión lambda.</p>
<p>Resumiendo: el parámetro es <strong>local</strong> a dicha expresión
lambda.</p></li>
<li><p>Por tanto, <strong>sólo podemos acceder al valor de un parámetro
dentro del cuerpo de su expresión lambda</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.4.0.0.6">

<!-- Esta diapositiva está repetida en una sección posterior -->
<ul>
<li><p>Por ejemplo, en el siguiente código:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>suma <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span></code></pre></div>
<p>el cuerpo de la expresión lambda ligada a <code
class="sourceCode python">suma</code> determina su propio
ámbito.</p></li>
<li><p>Por tanto, en el siguiente código tenemos dos ámbitos: el ámbito
global (más externo) y el ámbito del cuerpo de la expresión lambda (más
interno y anidado dentro del ámbito global):</p>
<div class="centered">
<p><img data-src="images/ambitos-anidados.png" class="plain"
style="width:60.0%" /></p>
</div></li>
<li><p>Además, cada vez que se llama a <code
class="sourceCode python">suma</code>, la ejecución del programa entra
en su cuerpo, lo que crea un nuevo marco que almacena las ligaduras
entre sus parámetros y los argumentos usados en esa llamada.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.4.0.0.7">

<div class="caja">
<p><strong>En resumen:</strong></p>
<ul>
<li><p>El <strong>ámbito de un parámetro</strong> es el ámbito de la
ligadura que se establece entre éste y su argumento correspondiente, y
se corresponde con el <strong>cuerpo</strong> de la expresión lambda
donde aparece.</p></li>
<li><p>Por tanto, el parámetro sólo existe dentro del cuerpo de la
expresión lambda y no podemos <strong>acceder</strong> a su valor fuera
del mismo; por eso se dice que tiene un <strong>ámbito
<em>local</em></strong> a la expresión lambda.</p></li>
<li><p>Además, <strong>la ligadura</strong> entre el parámetro y su
argumento <strong>se almacena en el marco</strong> de la llamada a la
expresión lambda, y por eso se dice que tiene un <strong>almacenamiento
<em>local</em></strong> a la expresión lambda.</p></li>
</ul>
</div>
</section>
<section class="slide level5" data-number="1.4.0.0.8">

<ul>
<li><p>Los ámbitos léxicos permiten ligaduras locales a ciertas
construcciones sintácticas, lo cual nos permite programar definiendo
partes suficientemente independientes entre sí.</p></li>
<li><p>Esto es la base de la llamada <em>programación
modular</em>.</p></li>
<li><p>Por ejemplo, nos permite crear funciones sin preocuparnos de si
los nombres de los parámetros ya han sido utilizados en otras partes del
programa.</p></li>
<li><p>Igualmente, nos permite crear programas sin preocuparnos de si
estamos usando nombres que ya han sido usados en el interior de alguna
de las funciones del programa.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.4.0.0.9">

<ul>
<li><p>De lo contrario, se podría provocar lo que se conoce como
<strong><em>name clash</em></strong> (<em>conflicto de nombres</em> o
<em>choque de nombres</em>), que es el problema que se produce cuando
usamos el mismo nombre para varias cosas diferentes y que impide que se
puedan usar todas al mismo tiempo.</p></li>
<li><p>Lo que impide el <em>name clash</em> son dos cosas:</p>
<ul>
<li><p>Los <em>ámbitos</em> hacen que los nombres sólo sean visibles en
ciertas zonas.</p></li>
<li><p>Los <em>espacios de nombres</em> permiten que un mismo nombre
pueda ligarse a diferentes nombres simultáneamente.</p></li>
</ul></li>
</ul>
</section>

<section id="ámbito-de-un-identificador-cuantificado"
class="title-slide slide level2" data-number="1.5">
<h2 data-number="1.5"><span class="header-section-number">1.5</span>
Ámbito de un identificador cuantificado</h2>
<ul>
<li><p>Hemos visto que a los <strong>parámetros</strong> de una
expresión lambda se les llama <strong>identificadores
cuantificados</strong> cuando aparecen dentro del cuerpo de dicha
expresión lambda.</p></li>
<li><p>Por tanto, todo lo que se dijo sobre el ámbito de un parámetro se
aplica exactamente igual al ámbito de un identificador
cuantificado.</p></li>
<li><p>Recordemos que el ámbito de un parámetro es el cuerpo de su
expresión lambda, que es la porción de código donde podemos acceder al
valor del argumento con el que está ligado.</p></li>
<li><p>Por tanto, <strong>el <em>ámbito</em> de un identificador
cuantificado es el <em>cuerpo</em> de la expresión lambda</strong> donde
aparece, y es el único lugar dentro del cual podremos acceder al valor
del identificador cuantificado (que también será el valor del argumento
con el que está ligada).</p></li>
<li><p>Por eso también se dice que el identificador cuantificado tiene
un <strong>ámbito local</strong> al cuerpo de la expresión
lambda.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.5.0.0.1">

<div class="caja">
<p><strong>En resumen:</strong></p>
<ul>
<li><p>El <strong>ámbito de un identificador cuantificado</strong> es el
ámbito de la ligadura que se crea entre ésto y su argumento
correspondiente, y se corresponde con el <strong>cuerpo</strong> de la
expresión lambda donde aparece.</p></li>
<li><p>Por tanto, el identificador cuantificado sólo existe dentro del
cuerpo de la expresión lambda y no podemos <strong>acceder</strong> a su
valor fuera del mismo; por eso se dice que tiene un <strong>ámbito
<em>local</em></strong> a la expresión lambda.</p></li>
<li><p>Además, <strong>la ligadura</strong> entre el identificador
cuantificado y su argumento <strong>se almacena en el marco</strong> de
la llamada a la expresión lambda, y por eso se dice que tiene un
<strong>almacenamiento <em>local</em></strong> a la expresión
lambda.</p></li>
</ul>
</div>
<ul>
<li>O sea: con los <strong>identificadores cuantificados</strong> ocurre
exactamente lo mismo que con los <strong>parámetros</strong>, ya que, de
hecho, <strong>un parámetro y un identificador cuantificado son la misma
cosa</strong>, como ya hemos visto.</li>
</ul>
</section>
<section id="ejemplo-1" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejemplo</h5>
<ul>
<li><p>En el siguiente <em>script</em>:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode numberSource python number-lines"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1"></a><span class="co"># Aquí empieza el script (no hay más definiciones antes de esta línea):</span></span>
<span id="cb15-2"><a href="#cb15-2"></a>producto <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> x</span>
<span id="cb15-3"><a href="#cb15-3"></a>y <span class="op">=</span> producto(<span class="dv">3</span>)</span>
<span id="cb15-4"><a href="#cb15-4"></a>z <span class="op">=</span> x <span class="op">+</span> <span class="dv">1</span>       <span class="co"># da error</span></span></code></pre></div></li>
<li><p>Hay dos ámbitos: el ámbito global y el ámbito local definido por
el cuerpo de la expresión lambda (o sea, la expresión <code
class="sourceCode python">x <span class="op">*</span> x</code>).</p></li>
<li><p>Esa expresión lambda tiene un parámetro (<code
class="sourceCode python">x</code>) que aparece como el identificador
cuantificado <code class="sourceCode python">x</code> en el cuerpo de la
expresión lambda.</p></li>
<li><p>El ámbito del parámetro <code class="sourceCode python">x</code>
(o, lo que es lo mismo, el identificador cuantificado <code
class="sourceCode python">x</code>) es el <strong>cuerpo</strong> de la
expresión lambda.</p></li>
<li><p>Por tanto, fuera de ese cuerpo, no es posible acceder al valor
del identificador cuantificado <code class="sourceCode python">x</code>,
al encontrarnos <strong>fuera de su ámbito</strong> (la ligadura
<strong>sólo es visible dentro del cuerpo</strong> de la expresión
lambda).</p></li>
<li><p>Por eso, la línea 4 dará un error al intentar acceder al valor
<code class="sourceCode python">x</code>, cuya ligadura no es visible
fuera de la expresión lambda.</p></li>
</ul>
</section>

<section id="ámbito-de-un-identificador-libre"
class="title-slide slide level2" data-number="1.6">
<h2 data-number="1.6"><span class="header-section-number">1.6</span>
Ámbito de un identificador libre</h2>
<ul>
<li><p>Los identificadores y ligaduras que no tienen ámbito local se
dice que tienen un <strong>ámbito <em>no local</em></strong> o, a veces,
un <strong>ámbito <em>más global</em></strong>.</p>
<p>Si, además, ese ámbito resulta ser el <strong>ámbito global</strong>,
decimos directamente que esos identificadores o ligaduras son
<strong>globales</strong>.</p></li>
<li><p>Por ejemplo, los <strong>identificadores libres</strong> que
aparecen en una expresión lambda no son locales a dicha expresión (ya
que no representan parámetros de la expresión) y, por tanto:</p>
<ol>
<li><p>Tienen un ámbito más global que el cuerpo de dicha expresión
lambda.</p></li>
<li><p>Se almacenarán en otro espacio de nombres distinto al marco que
se crea al llamar a la expresión lambda.</p></li>
</ol></li>
</ul>
</section>
</section>
<section>
<section id="entorno" class="title-slide slide level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span>
Entorno</h1>

</section>
<section id="definición" class="title-slide slide level2"
data-number="2.1">
<h2 data-number="2.1"><span class="header-section-number">2.1</span>
Definición</h2>
<ul>
<li><p>El <strong>entorno</strong> (del inglés, <em>environment</em>) es
una extensión del concepto de <em>marco</em>, usado por los lenguajes
interpretados en la <strong>resolución de identificadores</strong>, ya
que:</p>
<div class="caja">
<p>El <strong>entorno</strong> nos da acceso a <strong><em>todas</em>
las ligaduras (almacenadas en marcos, es decir, no de atributos de
objetos) que son <em>visibles</em> en un momento concreto de la
ejecución de un programa interpretado</strong>.</p>
</div></li>
<li><p>El intérprete usa el entorno para resolver los identificadores
que se encuentran ligados mediante ligaduras cuya visibilidad depende de
un ámbito y que estén, por tanto, almacenadas en un marco.</p></li>
<li><p>Por tanto, no lo usa para resolver los identificadores asociados
a atributos de objetos.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.1.0.0.1">

<ul>
<li><p>Durante la ejecución del programa, se van creando y destruyendo
marcos a medida que se van entrando y saliendo de ciertos ámbitos; en
concreto, a medida que se van ejecutando <em>scripts</em>, funciones o
métodos.</p></li>
<li><p>Asimismo, en esos marcos se van almacenando ligaduras.</p></li>
<li><p><strong>Según se van creando en memoria, esos marcos van
enlazándose unos con otros</strong> creando una <strong>secuencia de
marcos</strong> que se denomina <strong>entorno</strong> (del inglés,
<em>environment</em>).</p></li>
<li><p>En un momento dado, el entorno contendrá más o menos marcos
dependiendo de por dónde haya pasado la ejecución del programa hasta ese
momento.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.1.0.0.2">

<ul>
<li><p>El entorno, por tanto, es un concepto
<strong><em>dinámico</em></strong> que <strong>depende del momento en el
que se calcule</strong>, es decir, de por dónde va la ejecución del
programa.</p></li>
<li><p>Por tanto, el entorno depende de qué partes del programa se han
ido ejecutando hasta llegar a la instrucción actual.</p></li>
<li><p>El entorno <strong>siempre contendrá</strong>, al menos, un
marco: el <em>marco global</em>, que <strong>siempre será <em>el
último</em> de la secuencia de marcos</strong> que forman el
entorno.</p></li>
<li><p>Asimismo, el primer marco del entorno se denomina el
<strong>marco actual</strong>.</p></li>
<li><p>Si el marco global es el único que existe, entonces el marco
actual será el marco global.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.1.0.0.3">

<ul>
<li><p>Gráficamente, representaremos los entornos como una <strong>lista
enlazada de marcos</strong> conectados entre sí formando secuencias, de
manera que:</p>
<ul>
<li><p>Usaremos la letra <span class="math inline">E</span> como un
indicador que siempre apunta al primer marco de la lista.</p>
<p>Ese primer marco es el <strong>marco actual</strong>.</p></li>
<li><p>El último marco siempre será el marco global.</p></li>
</ul>
<div class="centered">
<p><img data-src="images/cadena-de-marcos.svg" class="plain"
style="width:60.0%" /></p>
</div></li>
<li><p>Si sólo hay un marco en el entorno, ése será necesariamente el
marco global, el cual será también al mismo tiempo el marco actual:</p>
<div class="centered">
<p><img data-src="images/unico-marco-en-entorno.svg" class="plain"
style="width:25.0%" /></p>
</div></li>
</ul>
</section>
<section class="slide level5" data-number="2.1.0.0.4">

<ul>
<li><p>Por ejemplo:</p>
<ul>
<li><p>Cuando entramos a ejecutar un <em>script</em>, se crea su
<em>marco global</em>.</p>
<div class="centered">
<p><img data-src="images/unico-marco-en-entorno.svg" class="plain"
style="width:25.0%" /></p>
</div></li>
<li><p>Si dentro de ese <em>script</em> llamamos a una expresión lambda,
se creará un marco para esa ejecución concreta de la expresión lambda,
por lo que en ese caso habrá dos marcos en la memoria: el
<em>global</em> y el de esa llamada a la expresión lambda.</p>
<p>El marco de la expresión lambda será el marco actual, que será el
primer marco del entorno y apuntará a su vez al marco global.</p>
<div class="centered">
<p><img data-src="images/marcos-de-expresion-lambda-y-global.svg"
class="plain" style="width:60.0%" /></p>
</div></li>
<li><p>El marco de la expresión lambda se eliminará de la memoria cuando
termine esa ejecución de la expresión lambda.</p></li>
<li><p>A su vez, el marco global sólo se eliminará de la memoria cuando
se finalice la ejecución del <em>script</em>.</p></li>
</ul></li>
</ul>
</section>

<section id="ámbitos-marcos-y-entornos" class="title-slide slide level2"
data-number="2.2">
<h2 data-number="2.2"><span class="header-section-number">2.2</span>
Ámbitos, marcos y entornos</h2>
<ul>
<li><p>Hagamos un resumen rápido de todo lo visto hasta ahora.</p></li>
<li><p>El entorno contiene todas las ligaduras visibles en un punto
concreto de la ejecución del programa interpretado, siempre que sean
ligaduras cuya visibilidad dependa de un ámbito y estén, por tanto,
almacenadas en un marco (o sea, no es el caso de los atributos de
objetos).</p></li>
<li><p>Un marco contiene un conjunto de ligaduras (ya que es un
<em>espacio de nombres</em>), y un entorno es una secuencia de
marcos.</p></li>
<li><p>Los marcos se van creando y destruyendo a medida que se van
ejecutando y terminando de ejecutar ciertas partes del programa:
<em>scripts</em>, funciones o métodos (que son un caso particular de
función).</p></li>
<li><p>Una expresión lambda también es una función.</p></li>
<li><p>Cuando se llama a una función, se crea un nuevo marco que
contiene las ligaduras que ligan a los parámetros con los valores de
esos argumentos.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.2.0.0.1">

<ul>
<li><p>El cuerpo de una expresión lambda determina su propio ámbito, de
forma que las ligaduras que ligan a los parámetros con los argumentos se
crean dentro de ese ámbito y son, por tanto, <em>locales</em> a ese
ámbito.</p></li>
<li><p>Es decir: los parámetros (y las ligaduras entre los parámetros y
los argumentos) tienen <strong>un ámbito local</strong> al cuerpo de la
expresión lambda y sólo son visibles dentro de él.</p></li>
<li><p>Además, esas ligaduras tienen un <strong>almacenamiento
local</strong> al <strong>marco</strong> que se crea al llamar a la
expresión lambda.</p></li>
<li><p>Ese <strong>marco</strong> y ese <strong>ámbito</strong> van
ligados:</p>
<ul>
<li><p>Cuando <strong>se <em>empieza</em></strong> a ejecutar el cuerpo
de la expresión lambda, <strong>se <em>entra</em></strong> en el ámbito
y, por tanto, <strong>se <em>crea</em></strong> el marco en la
memoria.</p></li>
<li><p>Cuando <strong>se <em>termina</em></strong> de ejecutar el cuerpo
de la expresión lambda, <strong>se <em>sale</em></strong> del ámbito y,
por tanto, <strong>se <em>elimina</em></strong> el marco de la
memoria.</p></li>
</ul></li>
<li><p><strong>Todo <em>marco</em> lleva asociado un
<em>ámbito</em></strong> (lo contrario no siempre es cierto).</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.2.0.0.2">

<ul>
<li><p>Cuando se crea el nuevo marco, éste se enlaza con el marco que
hasta ese momento había sido el marco actual, en cadena.</p></li>
<li><p>El último marco de la cadena es siempre el marco global.</p></li>
<li><p>Se va formando así una <strong>secuencia de marcos</strong> que
representa el <strong>entorno</strong> del programa allí donde se está
ejecutando la instrucción actual.</p></li>
<li><p>Así que no tendremos un único marco (el <em>marco global</em>)
sino que tendremos, además, al menos uno más cada vez que se llame a una
expresión lambda y mientras dure la ejecución de la misma.</p></li>
<li><p>El <strong>ámbito</strong> es un concepto <em>estático</em>: es
algo que existe y se reconoce simplemente leyendo el código del
programa, sin tener que ejecutarlo.</p></li>
<li><p>El <strong>marco</strong> es un concepto <em>dinámico</em>: es
algo que se crea y se destruye a medida que se van ejecutando y
terminando de ejecutar ciertas partes del programa: <em>scripts</em>,
funciones y métodos.</p>
<div class="caja">
<p><strong>Un marco se crea</strong> cuando se <strong>entra</strong> en
el <strong>ámbito</strong> de un <em>script</em>, función o método, y
<strong>se destruye</strong> cuando se <strong>sale</strong> de ese
<strong>ámbito</strong>.</p>
</div></li>
</ul>
</section>
<section class="slide level5" data-number="2.2.0.0.3">

<!-- Esta diapositiva está repetida en una sección anterior -->
<ul>
<li><p>Por ejemplo, en el siguiente código:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>suma <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span></code></pre></div>
<p>el cuerpo de la función <code class="sourceCode python">suma</code>
determina un ámbito.</p></li>
<li><p>Por tanto, en el siguiente código tenemos dos ámbitos: el ámbito
global (más externo) y el ámbito del cuerpo de la expresión lambda (más
interno y anidado dentro del ámbito global):</p>
<div class="centered">
<p><img data-src="images/ambitos-anidados.png" class="plain"
style="width:60.0%" /></p>
</div></li>
<li><p>Además, cada vez que se llama a <code
class="sourceCode python">suma</code>, la ejecución del programa entra
en su cuerpo, lo que crea un nuevo marco que almacena las ligaduras
entre sus parámetros y los argumentos usados en esa llamada.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.2.0.0.4">

<ul>
<li><p>El concepto de <strong>entorno</strong> refleja el hecho de que
los ámbitos se contienen unos a otros (están anidados unos dentro de
otros).</p>
<div class="caja">
<p><strong>Si un marco <span class="math inline">A</span> apunta a un
marco <span class="math inline">B</span> en el entorno, significa que el
ámbito de <span class="math inline">A</span> está contenido en el ámbito
de <span class="math inline">B</span>.</strong></p>
</div></li>
<li><p>El <strong>primer marco</strong> en la cadena del entorno siempre
será el último marco que se ha creado y que todavía no se ha
destruido.</p>
<p>Ese marco es el <strong>marco actual</strong>, y se corresponde con
el ámbito actual, es decir, con el ámbito más interno de la instrucción
actual.</p></li>
<li><p>Por otra parte, el <strong>último marco</strong> del entorno
siempre es el <em>marco global</em>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.2.0.0.5">

<ul>
<li><p>Por ejemplo, si en cierto momento de la ejecución del programa
anterior tenemos el siguiente entorno:</p>
<div class="centered">
<p><img data-src="images/lambda-suma-entorno.svg" class="plain"
style="width:60.0%" /></p>
</div>
<p>Podemos afirmar que:</p>
<ul>
<li><p>El marco de la función <code
class="sourceCode python">suma</code> apunta al marco global en el
entorno.</p></li>
<li><p>El ámbito de la expresión lambda a la que está ligado <code
class="sourceCode python">suma</code> está contenido en el ámbito
global.</p></li>
<li><p>El marco actual es el marco de la expresión lambda.</p></li>
<li><p>Por tanto, el programa se encuentra actualmente ejecutando el
cuerpo de la expresión lambda.</p></li>
<li><p>De hecho, está ejecutando la llamada <code
class="sourceCode python">suma(<span class="dv">3</span>, <span class="dv">5</span>)</code>.</p></li>
</ul></li>
</ul>
</section>
</section>
<section>
<section id="evaluación-con-entornos" class="title-slide slide level1"
data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span>
Evaluación con entornos</h1>

</section>
<section id="evaluación-de-expresiones-con-entornos"
class="title-slide slide level2" data-number="3.1">
<h2 data-number="3.1"><span class="header-section-number">3.1</span>
Evaluación de expresiones con entornos</h2>
<ul>
<li><p>Al evaluar una expresión, el intérprete <strong>buscará en el
entorno el valor al que está ligado cada identificador</strong> que
aparezca en la expresión.</p></li>
<li><p>Para ello, el intérprete buscará <strong>en el primer marco del
entorno</strong> (el <em>marco actual</em>) una ligadura para ese
identificador y, si no la encuentra, <strong>irá pasando por toda la
secuencia de marcos</strong> hasta encontrarla.</p>
<p><strong>Si no aparece en ningún marco</strong>, querrá decir que:</p>
<ul>
<li><p>o bien el identificador <strong>no está ligado</strong> (porque
aún no se ha creado la ligadura),</p></li>
<li><p>o bien su ligadura <strong>está fuera del entorno</strong> y por
tanto no es visible actualmente (al encontrarse en otro ámbito
inaccesible desde el ámbito actual).</p></li>
</ul>
<p>En cualquiera de estos casos, <strong>generará un error</strong> de
tipo <code
class="sourceCode python"><span class="pp">NameError</span></code>
(«<em>nombre no definido</em>»).</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.1.0.0.1">

<ul>
<li><p>Por ejemplo:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode numberSource python number-lines"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1"></a>x <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb17-2"><a href="#cb17-2"></a>z <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb17-3"><a href="#cb17-3"></a>suma <span class="op">=</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y <span class="op">+</span> z)(<span class="dv">8</span>, <span class="dv">12</span>)</span>
<span id="cb17-4"><a href="#cb17-4"></a>y <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb17-5"><a href="#cb17-5"></a>w <span class="op">=</span> <span class="dv">9</span></span></code></pre></div></li>
<li><p>A medida que vamos ejecutando cada línea del código, tendríamos
los siguientes entornos:</p></li>
</ul>
<div class="columns">
<div class="column">
<div class="centered">
<figure>
<img data-src="images/lambda-entorno-linea1.svg" class="plain"
style="width:60.0%" alt="Entorno justo tras ejecutar la línea 1" />
<figcaption aria-hidden="true">Entorno justo tras ejecutar la línea
1</figcaption>
</figure>
</div>
</div><div class="column">
<div class="centered">
<figure>
<img data-src="images/lambda-entorno-linea2.svg" class="plain"
style="width:60.0%" alt="Entorno justo tras ejecutar la línea 2" />
<figcaption aria-hidden="true">Entorno justo tras ejecutar la línea
2</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section class="slide level5" data-number="3.1.0.0.2">

<div class="centered">
<figure>
<img data-src="images/lambda-entorno-linea3-durante.svg" class="plain"
style="width:60.0%"
alt="Entorno en la línea 3 en el cuerpo de la expresión lambda, después de aplicar los argumentos y durante la ejecución del cuerpo" />
<figcaption aria-hidden="true">Entorno en la línea 3 en el cuerpo de la
expresión lambda, después de aplicar los argumentos y
<strong>durante</strong> la ejecución del cuerpo</figcaption>
</figure>
</div>
<div class="centered">
<figure>
<img data-src="images/lambda-entorno-linea3-despues.svg" class="plain"
style="width:30.0%"
alt="Entorno en la línea 3, después de ejecutar el cuerpo y devolver el resultado" />
<figcaption aria-hidden="true">Entorno en la línea 3,
<strong>después</strong> de ejecutar el cuerpo y devolver el
resultado</figcaption>
</figure>
</div>
</section>
<section class="slide level5" data-number="3.1.0.0.3">

<div class="columns">
<div class="column">
<div class="centered">
<figure>
<img data-src="images/lambda-entorno-linea4.svg" class="plain"
style="width:60.0%" alt="Entorno justo tras ejecutar la línea 4" />
<figcaption aria-hidden="true">Entorno justo tras ejecutar la línea
4</figcaption>
</figure>
</div>
</div><div class="column">
<div class="centered">
<figure>
<img data-src="images/lambda-entorno-linea5.svg" class="plain"
style="width:60.0%" alt="Entorno justo tras ejecutar la línea 5" />
<figcaption aria-hidden="true">Entorno justo tras ejecutar la línea
5</figcaption>
</figure>
</div>
</div>
</div>
</section>

<section id="evaluación-de-expresiones-lambda-con-entornos"
class="title-slide slide level2" data-number="3.2">
<h2 data-number="3.2"><span class="header-section-number">3.2</span>
Evaluación de expresiones lambda con entornos</h2>
<ul>
<li><p>Para que una expresión lambda funcione, todos los identificadores
que aparezcan en el cuerpo deben estar ligados a algún valor en el
entorno <strong>en el momento de <em>evaluar la aplicación</em> de la
expresión lambda sobre unos argumentos</strong>.</p></li>
<li><p>Por ejemplo:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode numberSource python number-lines"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1"></a><span class="op">&gt;&gt;&gt;</span> prueba <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y <span class="op">+</span> z  <span class="co"># aquí no da error</span></span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="op">&gt;&gt;&gt;</span> prueba(<span class="dv">4</span>, <span class="dv">3</span>)                     <span class="co"># aquí sí</span></span>
<span id="cb18-3"><a href="#cb18-3"></a>Traceback (most recent call last):</span>
<span id="cb18-4"><a href="#cb18-4"></a>  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></span>
<span id="cb18-5"><a href="#cb18-5"></a>  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span><span class="kw">lambda</span><span class="op">&gt;</span></span>
<span id="cb18-6"><a href="#cb18-6"></a><span class="pp">NameError</span>: name <span class="st">&#39;z&#39;</span> <span class="kw">is</span> <span class="kw">not</span> defined</span></code></pre></div>
<p>da error porque <code class="sourceCode python">z</code> no está
definido (no está ligado a ningún valor en el entorno) en el momento de
llamar a <code class="sourceCode python">prueba</code> en la línea
2.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.0.0.1">

<ul>
<li><p>En cambio:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode numberSource python number-lines"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1"></a><span class="op">&gt;&gt;&gt;</span> prueba <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y <span class="op">+</span> z</span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="op">&gt;&gt;&gt;</span> z <span class="op">=</span> <span class="dv">9</span></span>
<span id="cb19-3"><a href="#cb19-3"></a><span class="op">&gt;&gt;&gt;</span> prueba(<span class="dv">4</span>, <span class="dv">3</span>)</span>
<span id="cb19-4"><a href="#cb19-4"></a><span class="dv">16</span></span></code></pre></div>
<p>sí funciona (y devuelve <code
class="sourceCode python"><span class="dv">16</span></code>) porque, en
el momento de evaluar la aplicación de la expresión lambda (en la línea
3), el identificador <code class="sourceCode python">z</code> está
ligado a un valor en el entorno (en este caso, <code
class="sourceCode python"><span class="dv">9</span></code>).</p></li>
<li><p>Observar que no es necesario que los identificadores que aparecen
en el cuerpo estén ligados en el entorno cuando <em>se crea</em> la
expresión lambda, sino cuando <strong><em>se evalúa</em> el cuerpo de la
expresión lambda</strong>, o sea, cuando se llama a la expresión
lambda.</p></li>
</ul>
</section>
<section id="ejemplo-2" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejemplo</h5>
<ul>
<li><p>En el siguiente <em>script</em>:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode numberSource python number-lines"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1"></a>w <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb20-2"><a href="#cb20-2"></a>f <span class="op">=</span> <span class="kw">lambda</span> x, y: <span class="dv">5</span> <span class="op">+</span> (<span class="kw">lambda</span> z: z <span class="op">+</span> <span class="dv">3</span>)(x <span class="op">+</span> y)</span>
<span id="cb20-3"><a href="#cb20-3"></a>r <span class="op">=</span> f(<span class="dv">2</span>, <span class="dv">4</span>)</span>
<span id="cb20-4"><a href="#cb20-4"></a>m <span class="op">=</span> (<span class="kw">lambda</span> x: x <span class="op">**</span> <span class="dv">2</span>)(<span class="dv">3</span>)</span></code></pre></div>
<p>existen cuatro ámbitos:</p>
<div class="centered">
<p><img data-src="images/cuatro-ambitos.png" class="plain"
style="width:100.0%" /></p>
</div></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.0.0.2">

<ul>
<li>Su ejecución, línea a línea, produce los siguientes entornos:</li>
</ul>
<div class="columns">
<div class="column">
<div class="centered">
<figure>
<img data-src="images/cuatro-ambitos-entorno-linea1.svg" class="plain"
style="width:60.0%" alt="Entorno justo tras ejecutar la línea 1" />
<figcaption aria-hidden="true">Entorno justo tras ejecutar la línea
1</figcaption>
</figure>
</div>
</div><div class="column">
<div class="centered">
<figure>
<img data-src="images/cuatro-ambitos-entorno-linea2.svg" class="plain"
style="width:60.0%" alt="Entorno justo tras ejecutar la línea 2" />
<figcaption aria-hidden="true">Entorno justo tras ejecutar la línea
2</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section class="slide level5" data-number="3.2.0.0.3">

<div class="centered">
<figure>
<img
data-src="images/cuatro-ambitos-entorno-linea3-durante-primer-lambda.svg"
class="plain" style="width:60.0%"
alt="Entorno en la línea 3 en el cuerpo de la primera expresión lambda, después de aplicar sus argumentos y durante la ejecución de su cuerpo" />
<figcaption aria-hidden="true">Entorno en la línea 3 en el cuerpo de la
primera expresión lambda, después de aplicar sus argumentos y durante la
ejecución de su cuerpo</figcaption>
</figure>
</div>
</section>
<section class="slide level5" data-number="3.2.0.0.4">

<div class="centered">
<figure>
<img
data-src="images/cuatro-ambitos-entorno-linea3-durante-segundo-lambda.svg"
class="plain" style="width:90.0%"
alt="Entorno en la línea 3 en el cuerpo de la segunda expresión lambda, después de aplicar sus argumentos y durante la ejecución de su cuerpo" />
<figcaption aria-hidden="true">Entorno en la línea 3 en el cuerpo de la
segunda expresión lambda, después de aplicar sus argumentos y durante la
ejecución de su cuerpo</figcaption>
</figure>
</div>
</section>
<section class="slide level5" data-number="3.2.0.0.5">

<div class="centered">
<figure>
<img
data-src="images/cuatro-ambitos-entorno-linea3-durante-primer-lambda.svg"
class="plain" style="width:60.0%"
alt="Entorno en la línea 3 en el cuerpo de la segunda expresión lambda, después de ejecutar su cuerpo y devolver su resultado" />
<figcaption aria-hidden="true">Entorno en la línea 3 en el cuerpo de la
segunda expresión lambda, después de ejecutar su cuerpo y devolver su
resultado</figcaption>
</figure>
</div>
</section>
<section class="slide level5" data-number="3.2.0.0.6">

<div class="centered">
<figure>
<img
data-src="images/cuatro-ambitos-entorno-linea3-despues-primer-lambda.svg"
class="plain" style="width:40.0%"
alt="Entorno en la línea 3 en el cuerpo de la primera expresión lambda, después de ejecutar su cuerpo y devolver su resultado" />
<figcaption aria-hidden="true">Entorno en la línea 3 en el cuerpo de la
primera expresión lambda, después de ejecutar su cuerpo y devolver su
resultado</figcaption>
</figure>
</div>
</section>
<section class="slide level5" data-number="3.2.0.0.7">

<div class="centered">
<figure>
<img
data-src="images/cuatro-ambitos-entorno-linea4-durante-tercer-lambda.svg"
class="plain" style="width:60.0%"
alt="Entorno en la línea 4 en el cuerpo de la tercera expresión lambda, después de aplicar sus argumentos y durante la ejecución de su cuerpo" />
<figcaption aria-hidden="true">Entorno en la línea 4 en el cuerpo de la
tercera expresión lambda, después de aplicar sus argumentos y durante la
ejecución de su cuerpo</figcaption>
</figure>
</div>
</section>
<section class="slide level5" data-number="3.2.0.0.8">

<div class="centered">
<figure>
<img
data-src="images/cuatro-ambitos-entorno-linea4-despues-tercer-lambda.svg"
class="plain" style="width:40.0%"
alt="Entorno justo tras ejecutar la línea 4" />
<figcaption aria-hidden="true">Entorno justo tras ejecutar la línea
4</figcaption>
</figure>
</div>
</section>
<section id="ligaduras-sombreadas" class="title-slide slide level3"
data-number="3.2.1">
<h3 data-number="3.2.1"><span class="header-section-number">3.2.1</span>
Ligaduras <em>sombreadas</em></h3>
<ul>
<li><p>Recordemos que la <strong>resolución de identificadores</strong>
es el proceso por el cual el compilador o el intérprete determinan qué
ligadura se corresponde con una aparición concreta de un determinado
identificador.</p></li>
<li><p>¿Qué ocurre cuando una expresión lambda contiene como parámetros
algunos identificadores que ya están ligados en el entorno, en un
espacio de nombres asociado a un ámbito más global?</p></li>
<li><p>Por ejemplo:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode numberSource python number-lines"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1"></a>x <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb21-2"><a href="#cb21-2"></a>total <span class="op">=</span> (<span class="kw">lambda</span> x: x <span class="op">*</span> x)(<span class="dv">3</span>)  <span class="co"># Su valor es 9</span></span></code></pre></div></li>
<li><p>¿Cómo resuelve el intérprete de Python las distintas
<code>x</code> que aparecen en el código? ¿Son la misma <code>x</code>?
¿Se corresponden con la misma ligadura? ¿Están todas esas <code>x</code>
ligadas al mismo valor?</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.1.0.1">

<ul>
<li><p>La <code class="sourceCode python">x</code> que aparece en la
línea 1 es distinta a las que aparecen en la 2:</p>
<ul>
<li><p>La <code class="sourceCode python">x</code> de la línea 1 es un
identificador ligado a un valor en el ámbito global (el ámbito de esa
ligadura es el ámbito global). Esa ligadura, se almacena en el marco
global, y por eso decimos que esa <code
class="sourceCode python">x</code> es <em>global</em>.</p>
<p>Por tanto, la aparición de la <code>x</code> en la línea 1 representa
a la <code>x</code> cuya ligadura se encuentra almacenada en el marco
global (es decir, la <code>x</code> global) y que está ligada al valor
<code
class="sourceCode python"><span class="dv">4</span></code>.</p></li>
<li><p>Las <code class="sourceCode python">x</code> de la línea 2
representan al parámetro de la expresión lambda. Ese parámetro está
ligado al argumento de la llamada, el ámbito de esa ligadura es el
cuerpo de la expresión lambda y esa ligadura se almacena en el marco de
la llamada a la expresión lambda.</p>
<p>En consecuencia, las apariciones de la <code>x</code> en la línea 2
representan a la <code>x</code> <em>local</em> a la expresión lambda,
cuya ligadura se encuentra almacenada en el marco de la llamada a la
expresión lambda y que está ligada a <code
class="sourceCode python"><span class="dv">3</span></code>.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.1.0.2">

<ul>
<li><p>Por tanto, la <code>x</code> que aparece en el cuerpo de la
expresión lambda <strong>no</strong> se refiere al identificador <code
class="sourceCode python">x</code> que está fuera de la expresión lambda
(y que aquí está ligado al valor <code
class="sourceCode python"><span class="dv">4</span></code>), sino al
parámetro <code class="sourceCode python">x</code> que, en la llamada de
la línea 2, está ligado al valor <code
class="sourceCode python"><span class="dv">3</span></code> (el argumento
de la llamada).</p></li>
<li><p>Es decir:</p>
<ul>
<li><p>Dentro del cuerpo de la expresión lambda, <code
class="sourceCode python">x</code> vale <code
class="sourceCode python"><span class="dv">3</span></code>.</p></li>
<li><p>Fuera del cuerpo de la expresión lambda, <code
class="sourceCode python">x</code> vale <code
class="sourceCode python"><span class="dv">4</span></code>.</p></li>
</ul></li>
<li><p>Para determinar cuánto vale cada aparición de la <code>x</code>
en ese código (es decir, para <em>resolver</em> la aparición de cada
<code>x</code>), el intérprete de Python consulta el
<strong>entorno</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.1.0.3">

<ul>
<li><p>La <code>x</code> que está en la línea 1 y las <code>x</code> que
están en la línea 2 son apariciones distintas que se corresponden con
ligaduras distintas que tienen ámbitos distintos y se almacenan en
espacios de nombres distintos.</p></li>
<li><p>Por tanto, el identificador <code>x</code> podrá tener valores
distintos dependiendo de qué aparición concreta de la <code>x</code>
estamos evaluando.</p></li>
<li><p>Cuando un mismo identificador está ligado dos veces en dos
ámbitos anidados uno dentro del otro, decimos que:</p>
<ul>
<li><p>El identificador que aparece en el ámbito más externo está
<strong>sombreado</strong> (y su ligadura está
<strong>sombreada</strong>) por el del ámbito más interno.</p></li>
<li><p>El identificador que aparece en el ámbito más interno
<strong>hace sombra</strong> al identificador sombreado (y también se
dice que su ligadura <strong>hace sombra</strong> a la ligadura
sombreada) que aparece en el ámbito más externo.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.1.0.4">

<ul>
<li><p>En nuestro ejemplo, podemos decir que el parámetro <code
class="sourceCode python">x</code> de la expresión lambda hace sombra al
identificador <code class="sourceCode python">x</code> que aparece en el
ámbito global.</p></li>
<li><p>Eso significa que no podemos acceder a ese identificador <code
class="sourceCode python">x</code> global desde dentro del cuerpo de la
expresión lambda, porque la <code class="sourceCode python">x</code>
dentro del cuerpo siempre se referirá a la <code
class="sourceCode python">x</code> local (el parámetro de la expresión
lambda).</p></li>
<li><p>Esto ocurre así porque, al buscar un valor para <code
class="sourceCode python">x</code>, la primera ligadura que se encuentra
el intérprete para el identificador <code
class="sourceCode python">x</code> al recorrer la secuencia de marcos
del entorno, es precisamente la que está en el marco de la expresión
lambda, que es el marco actual cuando se está ejecutando su
cuerpo.</p></li>
</ul>
<div class="centered">
<figure>
<img data-src="images/lambda-entorno-con-sombra.svg" class="plain"
style="width:50.0%"
alt="Entorno en el cuerpo de la expresión lambda, con ligadura sombreada" />
<figcaption aria-hidden="true">Entorno en el cuerpo de la expresión
lambda, con ligadura sombreada</figcaption>
</figure>
</div>
</section>
<section class="slide level5" data-number="3.2.1.0.5">

<ul>
<li><p>Si desde dentro de la expresión lambda necesitáramos acceder al
valor de la <code>x</code> que está fuera de ese expresión lambda, lo
que podríamos hacer es <strong>cambiarle el nombre</strong> al parámetro
<code class="sourceCode python">x</code>. Por ejemplo:</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>total <span class="op">=</span> (<span class="kw">lambda</span> w: w <span class="op">*</span> x)(<span class="dv">3</span>)  <span class="co"># Su valor es 12</span></span></code></pre></div>
<p>Así, en la expresión lambda tendríamos el parámetro <code
class="sourceCode python">w</code> y el identificador libre <code
class="sourceCode python">x</code>, éste último ligado en el ámbito
global, y a cuyo valor ahora sí podemos acceder al no estar sombreado y
encontrarse dentro del entorno.</p></li>
</ul>
<div class="centered">
<figure>
<img data-src="images/lambda-entorno-sin-sombra.svg" class="plain"
style="width:60.0%"
alt="Entorno en el cuerpo de la expresión lambda, sin identificador sombreado" />
<figcaption aria-hidden="true">Entorno en el cuerpo de la expresión
lambda, sin identificador sombreado</figcaption>
</figure>
</div>
</section>

<section id="renombrado-de-parámetros" class="title-slide slide level3"
data-number="3.2.2">
<h3 data-number="3.2.2"><span class="header-section-number">3.2.2</span>
Renombrado de parámetros</h3>
<ul>
<li><p>Los parámetros se pueden <em>renombrar</em> sin que se altere el
significado de la expresión lambda, siempre que ese renombrado se haga
de forma adecuada.</p></li>
<li><p>A esta operación se la denomina
<strong>α-conversión</strong>.</p></li>
<li><p>Un ejemplo de α-conversión es la que hicimos antes.</p></li>
<li><p>La α-conversión hay que hacerla correctamente para evitar efectos
indeseados. Por ejemplo, en:</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lambda</span> x, y: x <span class="op">+</span> y <span class="op">+</span> z</span></code></pre></div>
<p>si renombramos <code class="sourceCode python">x</code> a <code
class="sourceCode python">z</code> tendríamos:</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lambda</span> z, y: z <span class="op">+</span> y <span class="op">+</span> z</span></code></pre></div>
<p>lo que es claramente incorrecto. A este fenómeno indeseable se le
denomina <strong>captura de identificadores</strong>.</p></li>
</ul>
</section>

<section id="visualización-en-pythontutor"
class="title-slide slide level3" data-number="3.2.3">
<h3 data-number="3.2.3"><span class="header-section-number">3.2.3</span>
Visualización en <em>Pythontutor</em></h3>
<ul>
<li><p><strong>Pythontutor</strong> es una herramienta online muy
interesante y práctica que nos permite ejecutar un <em>script</em> paso
a paso y visualizar sus efectos.</p></li>
<li><p>Muestra la pila de control, los marcos dentro de ésta, las
ligaduras dentro de éstos y los datos almacenados en el
montículo.</p></li>
<li><p>Entrando en <a
href="http://pythontutor.com/visualize.html">http://pythontutor.com/visualize.html</a>
se abre un área de texto donde se puede teclear (o copiar y pegar) el
código fuente del <em>script</em> a ejecutar.</p></li>
<li><p>Pulsando en «<em>Visualize Execution</em>» se pone en marcha,
pudiendo ejecutar todo el <em>script</em> de una vez o hacerlo paso a
paso.</p></li>
<li><p>Conviene elegir las siguientes opciones:</p>
<ul>
<li><p><em>Hide exited frames (default)</em></p></li>
<li><p><em>Render all objects on the heap (Python/Java)</em></p></li>
<li><p><em>Draw pointers as arrows (default)</em></p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.3.0.1">

<p><a
href="http://pythontutor.com/visualize.html#code=w%20%3D%202%0Af%20%3D%20lambda%20x,%20y%3A%205%20%2B%20%28lambda%20z%3A%20z%20%2B%203%29%28x%20%2B%20y%29%0Ar%20%3D%20f%282,%204%29%0Am%20%3D%20%28lambda%20x%3A%20x%20**%202%29%283%29%0A&amp;cumulative=false&amp;curInstr=0&amp;heapPrimitives=true&amp;mode=display&amp;origin=opt-frontend.js&amp;py=3&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false"
target="_blank">Visualizar el <em>script</em> anterior en
Pythontutor</a></p>
</section>
<section id="ejercicio" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejercicio</h5>
<ol class="example" type="1">
<li><p>En el <em>script</em> anterior:</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode numberSource python number-lines"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1"></a>w <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb25-2"><a href="#cb25-2"></a>f <span class="op">=</span> <span class="kw">lambda</span> x, y: <span class="dv">5</span> <span class="op">+</span> (<span class="kw">lambda</span> z: z <span class="op">+</span> <span class="dv">3</span>)(x <span class="op">+</span> y)</span>
<span id="cb25-3"><a href="#cb25-3"></a>r <span class="op">=</span> f(<span class="dv">2</span>, <span class="dv">4</span>)</span>
<span id="cb25-4"><a href="#cb25-4"></a>m <span class="op">=</span> (<span class="kw">lambda</span> x: x <span class="op">**</span> <span class="dv">2</span>)(<span class="dv">3</span>)</span></code></pre></div>
<p>indicar:</p>
<ol type="a">
<li>Los identificadores.</li>
<li>Los ámbitos.</li>
<li>Los entornos, marcos y ligaduras en cada línea de código.</li>
<li>Los ámbitos de cada ligadura.</li>
<li>La visibilidad de cada ligadura.</li>
<li>El tiempo de vida de cada ligadura.</li>
<li>El almacenamiento de cada ligadura.</li>
<li>Los ámbitos de cada aparición de cada identificador.</li>
<li>Las ligaduras sombreadas y los identificadores sombreados.</li>
<li>Los identificadores y ligaduras que hacen sombra.</li>
</ol></li>
</ol>
</section>


<section id="resolución-de-atributos-de-objetos"
class="title-slide slide level2" data-number="3.3">
<h2 data-number="3.3"><span class="header-section-number">3.3</span>
Resolución de atributos de objetos</h2>
<ul>
<li><p>Ya estudiamos que el acceso a un atributo de un objeto suponía
buscar la correspondiente ligadura únicamente en el espacio de nombres
asociado a ese objeto, y no en ningún otro.</p></li>
<li><p>Por tanto, dicha resolución requiere de un mecanismo algo
distinto a lo visto hasta ahora, ya que las ligaduras que ligan el
nombre del atributo con su valor se almacenan en el propio objeto, no en
un marco.</p></li>
<li><p>En consecuencia, el acceso a un atributo de un objeto usando el
operador punto (<code>.</code>), como en la expresión <code
class="sourceCode python">math.pi</code> de este ejemplo:</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> math.pi <span class="op">*</span> <span class="dv">2</span></span></code></pre></div>
<p>no requiere usar el entorno.</p></li>
<li><p>De hecho, el lenguaje ni siquiera tiene por qué tener entornos.
Recordemos que los lenguajes compilados no usan entornos para resolver
identificadores y pueden resolver perfectamente los atributos de los
objetos.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.0.0.1">

<ul>
<li><p>Concretamente, resolver el identificador <code>pi</code> en la
expresión <code class="sourceCode python">math.pi</code> requerirá de
los siguientes pasos:</p>
<ol>
<li><p>Se busca el valor de <code>math</code> en el entorno, que
devuelve el objeto que representa al módulo <code>math</code>.</p></li>
<li><p>Una vez que sabemos que el operando izquierdo del operador punto
(<code>.</code>) es un objeto, procedemos a resolver el identificador
<code>pi</code>, pero para ello sólo se considera el espacio de nombres
asociado al objeto <code>math</code>.</p>
<p>Es decir: buscamos el valor de <code>pi</code> en el espacio de
nombres de <code>math</code>, y sólo ahí.</p></li>
<li><p>Una vez localizado, se devolverá el valor ligado al nombre
<code>pi</code> en el espacio de nombres de <code>math</code>, o se
lanzará un error <code
class="sourceCode python"><span class="pp">NameError</span></code> en
caso de que no haya ninguna ligadura para <code>pi</code> en
<code>math</code>.</p></li>
</ol></li>
<li><p>Como se puede observar, en ningún momento se usa el entorno para
resolver el identificador <code>pi</code> dentro de
<code>math</code>.</p></li>
</ul>
</section>
</section>
<section>
<section id="la-pila-de-control" class="title-slide slide level1"
data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> La pila
de control</h1>

</section>
<section id="la-pila-de-control-1" class="title-slide slide level2"
data-number="4.1">
<h2 data-number="4.1"><span class="header-section-number">4.1</span> La
pila de control</h2>
<ul>
<li><p>La <strong>pila de control</strong> es una estructura de datos
que utiliza el intérprete para llevar la cuenta de las
<strong>ejecuciones <em>activas</em></strong> que hay en un determinado
momento de la ejecución del programa.</p></li>
<li><p>Las <strong>ejecuciones activas</strong> son aquellas llamadas a
funciones (o ejecuciones de <em>scripts</em>) que aún no han terminado
de ejecutarse.</p></li>
<li><p>La pila de control es, básicamente, un <strong>almacén de
marcos</strong>.</p></li>
<li><p>El marco que hay en el fondo de la pila siempre es el <em>marco
global</em> y se corresponde con el espacio de nombres del
<em>script</em> actual.</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.1.0.0.1">

<ul>
<li><p>Cada vez que se hace una nueva llamada a una función:</p>
<ol type="1">
<li><p>la ejecución actual se detiene,</p></li>
<li><p>el marco correspondiente a esa llamada <strong>se almacena en la
cima de la pila</strong> sobre los demás marcos que pudiera haber
y</p></li>
<li><p>se continúa la ejecución en la función llamada.</p></li>
</ol></li>
<li><p>Ese marco representa por dónde va la ejecución del programa en
este momento.</p></li>
<li><p>Según ésto, si un marco <em>A</em> está justo debajo de otro
marco <em>B</em>, es porque el código correspondiente a <em>A</em> está
esperando a que termine el código correspondiente a <em>B</em>
(normalmente, una función).</p></li>
<li><p>Ese marco además es el primero de la secuencia de marcos que
forman el entorno de la función, que también estarán almacenados en la
pila, más abajo.</p></li>
<li><p>Los marcos se enlazan entre sí para representar los entornos que
actúan en las distintas llamadas activas.</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.1.0.0.2">

<ul>
<li><p>El intérprete almacena en el marco cualquier información que
necesite para gestionar las llamadas a funciones, incluyendo:</p>
<ul>
<li><p>Las ligaduras entre los parámetros y sus valores (por
supuesto).</p></li>
<li><p>La ligadura que apunta al valor de retorno de la
función.</p></li>
<li><p>Cuál es el siguiente marco que le sigue en el entorno.</p></li>
<li><p>El punto de retorno, dentro del programa, al que debe devolverse
el control cuando finalice la ejecución de la función.</p></li>
</ul></li>
<li><p>Un marco almacenado en la pila también se denomina
<strong>registro de activación</strong>. Por tanto, también podemos
decir que la pila de control almacena registros de activación.</p></li>
<li><p>Cada llamada activa está representada por su correspondiente
marco en la pila.</p></li>
<li><p>En cuanto la llamada finaliza, su marco se saca de la pila y se
transfiere el control a la llamada que está inmediatamente debajo (si es
que hay alguna).</p></li>
</ul>
</section>
<section id="ejemplos-1" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejemplos</h5>
<div class="columns">
<div class="column">
<div class="sourceCode" id="cb27"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>uno <span class="op">=</span> <span class="kw">lambda</span> x: <span class="dv">1</span> <span class="op">+</span> dos(<span class="dv">2</span> <span class="op">*</span> x, <span class="dv">4</span>)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>dos <span class="op">=</span> <span class="kw">lambda</span> y, z: tres(y <span class="op">+</span> z <span class="op">+</span> g)</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>tres <span class="op">=</span> <span class="kw">lambda</span> w: <span class="st">&quot;W vale &quot;</span> <span class="op">+</span> <span class="bu">str</span>(w)</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>uno(<span class="dv">3</span>)</span></code></pre></div>
</div><div class="column">
<div class="centered">
<figure>
<img data-src="images/pila-control.svg" class="plain"
style="width:40.0%"
alt="Pila de control con la llamada a la función tres activada" />
<figcaption aria-hidden="true">Pila de control con la llamada a la
función <code>tres</code> activada</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section class="slide level5" data-number="4.1.0.0.3">

<ul>
<li><p>Del análisis del diagrama del ejemplo anterior se pueden deducir
las siguientes conclusiones:</p>
<ul>
<li><p>En un momento dado, dentro del ámbito global se ha llamado a la
función <code class="sourceCode python">uno</code>, la cual ha llamado a
la función <code class="sourceCode python">dos</code>, la cual ha
llamado a la función <code class="sourceCode python">tres</code>, la
cual aún no ha terminado de ejecutarse.</p></li>
<li><p>El entorno en la función <code
class="sourceCode python">uno</code> empieza por el marco de <code
class="sourceCode python">uno</code>, el cual apunta al marco
global.</p></li>
<li><p>El entorno en la función <code
class="sourceCode python">dos</code> empieza por el marco de <code
class="sourceCode python">dos</code>, el cual apunta al marco
global.</p></li>
<li><p>El entorno en la función <code
class="sourceCode python">tres</code> empieza por el marco de <code
class="sourceCode python">tres</code>, el cual apunta al marco
global.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="4.1.0.0.4">

<ul>
<li><p>Si tenemos ámbitos anidados, los marcos se apuntarán entre sí en
el entorno. Por ejemplo:</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>uno <span class="op">=</span> <span class="kw">lambda</span> x: dos(x <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>dos <span class="op">=</span> <span class="kw">lambda</span> y: <span class="dv">1</span> <span class="op">+</span> (<span class="kw">lambda</span> z: z <span class="op">*</span> <span class="dv">2</span>)(y <span class="op">**</span> <span class="dv">3</span>)</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>uno(<span class="dv">3</span>)</span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="4.1.0.0.5">

<div class="centered">
<figure>
<img data-src="images/pila-control-ambitos-anidados.svg" class="plain"
style="width:30.0%"
alt="Pila de control con ámbitos anidados y la función dos activada" />
<figcaption aria-hidden="true">Pila de control con ámbitos anidados y la
función <code>dos</code> activada</figcaption>
</figure>
</div>
</section>
<section class="slide level5" data-number="4.1.0.0.6">

<ul>
<li><p>Hemos dicho que habrá un marco por cada nueva llamada que se
realice a una función, y que ese marco se mantendrá en la pila hasta que
la llamada finalice.</p></li>
<li><p>Por tanto, en el caso de una función recursiva, tendremos un
marco por cada llamada recursiva.</p></li>
</ul>
<div class="sourceCode" id="cb29"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>fact <span class="op">=</span> <span class="kw">lambda</span> n: <span class="dv">1</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> n <span class="op">*</span> fact(n <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>fact(<span class="dv">4</span>)</span></code></pre></div>
</section>
<section class="slide level5" data-number="4.1.0.0.7">

<div class="centered">
<figure>
<img data-src="images/pila-control-factorial.svg" class="plain"
style="width:30.0%"
alt="Pila de control tras tres activaciones desde fact(4)" />
<figcaption aria-hidden="true">Pila de control tras tres activaciones
desde <code>fact(4)</code></figcaption>
</figure>
</div>
</section>
<section class="slide level5" data-number="4.1.0.0.8">

<ul>
<li><p>Los <strong>traductores que optimizan la recursividad
final</strong> lo que hacen es sustituir cada llamada recursiva por la
nueva llamada recursiva a la misma función.</p></li>
<li><p>De esta forma, el marco que genera cada nueva llamada recursiva
no se apila sobre los marcos anteriores en la pila, sino que sustituye
al marco de la llamada que la ha llamado a ella.</p></li>
<li><p>Por ejemplo, en el siguiente caso:</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>fact_iter <span class="op">=</span> <span class="kw">lambda</span> cont, acc: acc <span class="cf">if</span> cont <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="op">\</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>                              fact_iter(cont <span class="op">-</span> <span class="dv">1</span>, acc <span class="op">*</span> cont)</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>fact <span class="op">=</span> <span class="kw">lambda</span> n: fact_iter(n, <span class="dv">1</span>)</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>fact(<span class="dv">5</span>)</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> fact_iter(<span class="dv">5</span>, <span class="dv">1</span>)</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> fact_iter(<span class="dv">4</span>, <span class="dv">5</span>)</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> fact_iter(<span class="dv">3</span>, <span class="dv">20</span>)</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> fact_iter(<span class="dv">2</span>, <span class="dv">60</span>)</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> fact_iter(<span class="dv">1</span>, <span class="dv">120</span>)</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> fact_iter(<span class="dv">0</span>, <span class="dv">120</span>)</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">120</span></span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="4.1.0.0.9">

<ul>
<li><p><code
class="sourceCode python">fact_iter(<span class="dv">4</span>, <span class="dv">5</span>)</code>
llama a <code
class="sourceCode python">fact_iter(<span class="dv">3</span>, <span class="dv">20</span>)</code>
y devuelve directamente el resultado de ésta.</p></li>
<li><p>Es decir: <code
class="sourceCode python">fact_iter(<span class="dv">4</span>, <span class="dv">5</span>) <span class="op">==</span> fact_iter(<span class="dv">3</span>, <span class="dv">20</span>)</code>,
así que hacer <code
class="sourceCode python">fact_iter(<span class="dv">4</span>, <span class="dv">5</span>)</code>
es lo mismo que hacer <code
class="sourceCode python">fact_iter(<span class="dv">3</span>, <span class="dv">20</span>)</code>.</p></li>
<li><p>Por tanto, la llamada a <code
class="sourceCode python">fact_iter(<span class="dv">4</span>, <span class="dv">5</span>)</code>
se puede sustituir por la llamada a <code
class="sourceCode python">fact_iter(<span class="dv">3</span>, <span class="dv">20</span>)</code>.</p></li>
<li><p>Un intérprete que optimiza la recursividad final no apilaría el
marco de la segunda llamada sobre el marco de la primera, sino que el
marco de la segunda sustituiría al marco de la primera dentro de la
pila.</p></li>
<li><p>Así se haría también con las demás llamadas recursivas a <code
class="sourceCode python">fact_iter(<span class="dv">2</span>, <span class="dv">60</span>)</code>,
<code
class="sourceCode python">fact_iter(<span class="dv">1</span>, <span class="dv">120</span>)</code>
y <code
class="sourceCode python">fact_iter(<span class="dv">0</span>, <span class="dv">120</span>)</code>.</p></li>
<li><p>De este modo, la pila no crecería con cada nueva llamada
recursiva.</p></li>
</ul>
</section>
</section>
<section>
<section id="estrategias-de-evaluación" class="title-slide slide level1"
data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span>
Estrategias de evaluación</h1>

</section>
<section id="estrategias-de-evaluación-1"
class="title-slide slide level2" data-number="5.1">
<h2 data-number="5.1"><span class="header-section-number">5.1</span>
Estrategias de evaluación</h2>
<ul>
<li><p>A la hora de evaluar una expresión (cualquier expresión) existen
varias <strong>estrategias</strong> diferentes que se pueden
adoptar.</p></li>
<li><p>Cada lenguaje implementa sus propias estrategias de evaluación
que están basadas en las que vamos a ver aquí.</p></li>
<li><p>Básicamente se trata de decidir, en cada paso de reducción, qué
subexpresión hay que reducir, en función de:</p>
<ul>
<li><p>El orden de evaluación:</p>
<ul>
<li><p>De fuera adentro o de dentro afuera.</p></li>
<li><p>De izquierda a derecha o de derecha a izquierda.</p></li>
</ul></li>
<li><p>La necesidad o no de evaluar dicha subexpresión.</p></li>
</ul></li>
</ul>
</section>
<section id="orden-de-evaluación" class="title-slide slide level3"
data-number="5.1.1">
<h3 data-number="5.1.1"><span class="header-section-number">5.1.1</span>
Orden de evaluación</h3>
<ul>
<li><p>En un lenguaje de programación funcional puro se cumple la
<strong>transparencia referencial</strong>, según la cual el valor de
una expresión depende sólo del valor de sus subexpresiones (también
llamadas <em>redexes</em>, del inglés, <em>reducible
expression</em>).</p></li>
<li><p>Pero eso también implica que <strong>no importa el orden en el
que se evalúen las subexpresiones</strong>: el resultado debe ser
siempre el mismo.</p></li>
<li><p>Gracias a ello podemos usar nuestro modelo de sustitución como
modelo computacional.</p></li>
<li><p>Hay dos <strong>estrategias básicas de evaluación</strong>:</p>
<ul>
<li><p><strong>Orden aplicativo</strong>: reducir siempre el
<em>redex</em> más <strong>interno</strong> (y más a la
izquierda).</p></li>
<li><p><strong>Orden normal</strong>: reducir siempre el <em>redex</em>
más <strong>externo</strong> (y más a la izquierda).</p></li>
</ul></li>
<li><p><strong>Python usa el orden aplicativo</strong>, salvo
excepciones.</p></li>
</ul>
</section>
<section id="orden-aplicativo" class="title-slide slide level4"
data-number="5.1.1.1">
<h4 data-number="5.1.1.1"><span
class="header-section-number">5.1.1.1</span> Orden aplicativo</h4>
<ul>
<li><p>El <strong>orden aplicativo</strong> consiste en evaluar las
expresiones <em>de dentro afuera</em>, es decir, empezando por el
<em>redex</em> más <strong>interno</strong> y a la izquierda.</p></li>
<li><p>El <em>redex</em> más interno es el que no contiene a otros
<em>redexes</em>. Si existe más de uno que cumpla esa condición, se
elige el que está más a la izquierda.</p></li>
<li><p>Eso implica que los operandos y los argumentos se evalúan
<strong>antes</strong> que los operadores y las aplicaciones de
funciones.</p></li>
<li><p>Corresponde a lo que en muchos lenguajes de programación se
denomina <strong>paso de argumentos por valor</strong>
(<em>call-by-value</em>).</p></li>
</ul>
</section>
<section class="slide level5" data-number="5.1.1.1.1">

<ul>
<li><p>Por ejemplo, si tenemos la siguiente función:</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>cuadrado <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> x</span></code></pre></div>
<p>según el orden aplicativo, la expresión <code
class="sourceCode python">cuadrado(<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)</code>
se reduce así:</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>cuadrado(<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)               <span class="co"># definición de cuadrado</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="kw">lambda</span> x: x <span class="op">*</span> x)(<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)    <span class="co"># evalúa 3 y devuelve 3</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="kw">lambda</span> x: x <span class="op">*</span> x)(<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)    <span class="co"># evalúa 4 y devuelve 4</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="kw">lambda</span> x: x <span class="op">*</span> x)(<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)    <span class="co"># evalúa 3 + 4 y devuelve 7</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="kw">lambda</span> x: x <span class="op">*</span> x)(<span class="dv">7</span>)        <span class="co"># aplicación a 7</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">7</span> <span class="op">*</span> <span class="dv">7</span>)                     <span class="co"># evalúa (7 * 7) y devuelve 49</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">49</span></span></code></pre></div></li>
</ul>
</section>

<section id="orden-normal" class="title-slide slide level4"
data-number="5.1.1.2">
<h4 data-number="5.1.1.2"><span
class="header-section-number">5.1.1.2</span> Orden normal</h4>
<ul>
<li><p>El <strong>orden normal</strong> consiste en evaluar las
expresiones <em>de fuera adentro</em>, es decir, empezando siempre por
el <em>redex</em> más <strong>externo</strong> y a la
izquierda.</p></li>
<li><p>El <em>redex</em> más externo es el que no está contenido en
otros <em>redexes</em>. Si existe más de uno que cumpla esa condición,
se elige el que está más a la izquierda.</p></li>
<li><p>Eso implica que los operandos y los argumentos se evalúan
<strong>después</strong> de las aplicaciones de los operadores y las
funciones.</p></li>
<li><p>Por tanto, los argumentos que se pasan a las funciones lo hacen
<strong>sin evaluarse</strong> previamente.</p></li>
<li><p>Corresponde a lo que en muchos lenguajes de programación se
denomina <strong>paso de argumentos por nombre</strong>
(<em>call-by-name</em>).</p></li>
</ul>
</section>
<section class="slide level5" data-number="5.1.1.2.1">

<ul>
<li><p>Por ejemplo, si tenemos la siguiente función:</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>cuadrado <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> x</span></code></pre></div>
<p>según el orden normal, la expresión <code
class="sourceCode python">cuadrado(<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)</code>
se reduce así:</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>cuadrado(<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)               <span class="co"># definición de cuadrado</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="kw">lambda</span> x: x <span class="op">*</span> x)(<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)    <span class="co"># aplicación a (3 + 4)</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> ((<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>) <span class="op">*</span> (<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>))         <span class="co"># evalúa 3 y devuelve 3</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> ((<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>) <span class="op">*</span> (<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>))         <span class="co"># evalúa 4 y devuelve 4</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> ((<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>) <span class="op">*</span> (<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>))         <span class="co"># evalúa (3 + 4) y devuelve 7</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)                 <span class="co"># evalúa 3 y devuelve 3</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)                 <span class="co"># evalúa 4 y devuelve 4</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)                 <span class="co"># evalúa (3 + 4) y devuelve 7</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> <span class="dv">7</span>                       <span class="co"># evalúa 7 * 7 y devuelve 49</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">49</span></span></code></pre></div></li>
</ul>
</section>


<section id="evaluación-estricta-y-no-estricta"
class="title-slide slide level3" data-number="5.1.2">
<h3 data-number="5.1.2"><span class="header-section-number">5.1.2</span>
Evaluación estricta y no estricta</h3>
<ul>
<li><p>Existe otra forma de ver la evaluación de una expresión:</p>
<ul>
<li><p><strong>Evaluación estricta o <em>impaciente</em></strong>:
Reducir todos los <em>redexes</em> aunque no hagan falta para calcular
el valor de la expresión.</p></li>
<li><p><strong>Evaluación no estricta o <em>perezosa</em></strong>:
Reducir sólo los <em>redexes</em> que sean estrictamente necesarios para
calcular el valor de la expresión.</p></li>
</ul></li>
</ul>
</section>
<section id="ejemplo-3" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejemplo</h5>
<ul>
<li><p>Sabemos que la expresión <code
class="sourceCode python"><span class="dv">1</span> <span class="op">/</span> <span class="dv">0</span></code>
da un error de <em>división por cero</em>:</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="dv">1</span> <span class="op">/</span> <span class="dv">0</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>Traceback (most recent call last):</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="pp">ZeroDivisionError</span>: division by zero</span></code></pre></div></li>
<li><p>Supongamos que tenemos la siguiente definición:</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>primero <span class="op">=</span> <span class="kw">lambda</span> x, y: x</span></code></pre></div>
<p>de forma que <code class="sourceCode python">primero</code> es una
función que simplemente devuelve el primero de sus argumentos.</p></li>
<li><p>Es evidente que la función <code
class="sourceCode python">primero</code> no necesita evaluar nunca su
segundo argumento, ya que no lo utiliza (simplemente devuelve el primero
de ellos). Por ejemplo, <code
class="sourceCode python">primero(<span class="dv">4</span>, <span class="dv">3</span>)</code>
devuelve <code
class="sourceCode python"><span class="dv">4</span></code>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="5.1.2.0.1">

<ul>
<li><p>Sabiendo eso… ¿qué valor devolvería la siguiente expresión?</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>primero(<span class="dv">4</span>, <span class="dv">1</span> <span class="op">/</span> <span class="dv">0</span>)</span></code></pre></div></li>
<li><p>Curiosamente, el resultado dependerá de si la evaluación es
estricta o perezosa:</p>
<ul>
<li><p><strong>Si es estricta</strong>, el intérprete evaluará todos los
argumentos de la expresión lambda aunque no se utilicen luego en su
cuerpo. Por tanto, al evaluar <code
class="sourceCode python"><span class="dv">1</span> <span class="op">/</span> <span class="dv">0</span></code>
devolverá un error.</p>
<p>Es lo que ocurre cuando se evalúa siguiendo el <strong>orden
aplicativo</strong>.</p></li>
<li><p>En cambio, <strong>si es perezosa</strong>, el intérprete
evaluará únicamente aquellos argumentos que se usen en el cuerpo de la
expresión lambda, y en este caso sólo se usa el primero, así que dejará
sin evaluar el segundo, no dará error y devolverá directamente <code
class="sourceCode python"><span class="dv">4</span></code>.</p>
<p>Es lo que ocurre cuando se evalúa siguiendo el <strong>orden
normal</strong>:</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>primero(<span class="dv">4</span>, <span class="dv">1</span> <span class="op">/</span> <span class="dv">0</span>) <span class="op">=</span> (<span class="kw">lambda</span> x, y: x)(<span class="dv">4</span>, <span class="dv">1</span> <span class="op">/</span> <span class="dv">0</span>) <span class="op">=</span> (<span class="dv">4</span>) <span class="op">=</span> <span class="dv">4</span></span></code></pre></div></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="5.1.2.0.2">

<ul>
<li><p>Hay un resultado teórico que avala lo que acabamos de
observar:</p>
<div class="caja">
<p><strong>Teorema de estandarización:</strong></p>
<p>Si una expresión tiene forma normal, el <strong>orden normal</strong>
de evaluación conduce seguro a la misma.</p>
</div></li>
<li><p>En cambio, el orden aplicativo es posible que no encuentre la
forma normal de la expresión.</p></li>
</ul>
</section>
<section class="slide level5" data-number="5.1.2.0.3">

<ul>
<li><p>En <strong>Python</strong> la evaluación es
<strong>estricta</strong>, salvo algunas excepciones:</p>
<ul>
<li><p>El operador ternario:</p>
<div class="line-block"><span
style="color:teal">⟨<em>expr_condicional</em>⟩</span> ::= <span
style="color:teal">⟨<em>valor_si_cierto</em>⟩</span>
<strong><code>if</code></strong> <span
style="color:teal">⟨<em>condición</em>⟩</span>
<strong><code>else</code></strong> <span
style="color:teal">⟨<em>valor_si_falso</em>⟩</span></div>
<p>evalúa perezosamente <span
style="color:teal">⟨<em>valor_si_cierto</em>⟩</span> y <span
style="color:teal">⟨<em>valor_si_falso</em>⟩</span> dependiendo del
valor de la <span
style="color:teal">⟨<em>condición</em>⟩</span>.</p></li>
<li><p>Los operadores lógicos <code
class="sourceCode python"><span class="kw">and</span></code> y <code
class="sourceCode python"><span class="kw">or</span></code> también son
perezosos (se dice que evalúan <strong>en cortocircuito</strong>):</p>
<ul>
<li><p><code
class="sourceCode python"><span class="va">True</span> <span class="kw">or</span></code>
 <span class="math inline">\;\underline{x}</span></p>
<p>siempre es igual a <code
class="sourceCode python"><span class="va">True</span></code>, valga lo
que valga <span class="math inline">\underline{x}</span>.</p></li>
<li><p><code
class="sourceCode python"><span class="va">False</span> <span class="kw">and</span></code>
 <span class="math inline">\;\underline{x}</span></p>
<p>siempre es igual a <code
class="sourceCode python"><span class="va">False</span></code>, valga lo
que valga <span class="math inline">\underline{x}</span>.</p></li>
</ul>
<p>En ambos casos no es necesario evaluar <span
class="math inline">\underline{x}</span>.</p></li>
</ul></li>
<li><p>En Java también existe un operador ternario (<code>?</code>
<code>:</code>) y unos operadores lógicos (<code>||</code> y
<code>&amp;&amp;</code>) que se evalúan de igual forma que en
Python.</p></li>
</ul>
</section>
<section class="slide level5" data-number="5.1.2.0.4">

<ul>
<li><p>La mayoría de los lenguajes de programación usan evaluación
estricta y paso de argumentos por valor (siguen el orden
aplicativo).</p></li>
<li><p><strong>Haskell</strong>, por ejemplo, es un lenguaje funcional
puro que usa evaluación perezosa y sigue el orden normal.</p></li>
<li><p>La evaluación perezosa en Haskell permite resultados muy
interesantes, como la posibilidad de manipular estructuras de datos
infinitas.</p></li>
</ul>
</section>

</section>
<section id="bibliografía"
class="title-slide slide level1 unnumbered unlisted">
<h1 class="unnumbered unlisted">Bibliografía</h1>
<div id="refs" class="references csl-bib-body hanging-indent"
data-entry-spacing="0" role="list">
<div id="ref-abelson_structure_1996" class="csl-entry" role="listitem">
Abelson, Harold, Gerald Jay Sussman, and Julie Sussman. 1996.
<em>Structure and Interpretation of Computer Programs</em>. 2nd ed.
Cambridge, Mass. : New York: MIT Press ; McGraw-Hill.
</div>
</div>
</section>
    </div>
  </div>

  <script src="./reveal.js/dist/reveal.js"></script>

  <!-- reveal.js plugins -->
  <script src="./reveal.js/plugin/notes/notes.js"></script>
  <script src="./reveal.js/plugin/search/search.js"></script>
  <script src="./reveal.js/plugin/zoom/zoom.js"></script>
  <script src="./reveal.js/plugin/reveal.js-menu/menu.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
        // Display controls in the bottom right corner
        controls: true,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: true,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'bottom-right',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: true,

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: false,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'default',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: true,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'slide',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'fade',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1280,

        height: 1080,
        // The display mode that will be used to show slides
        display: 'block',

        menu: {
          hideMissingTitles: true,
        },

        dependencies: [
          { src: './reveal.js/plugin/reveal.js-quiz/quiz/js/quiz.js', async: true, callback: function() { prepareQuizzes({preventUnanswered: true, checkAnswerText: 'Comprueba la respuesta', nextQuestionText: 'Siguiente &raquo;', backButtonText: '&laquo; Anterior', tryAgainText: 'Prueba de nuevo', preventUnansweredText: 'Selecciona una respuesta', questionCountText: 'Pregunta %current de %total', skipStartButton: true}); } }
        ],

        // reveal.js plugins
        plugins: [
          RevealMenu,
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    <script type="text/javascript">
       var title = document.getElementsByClassName('title')[0];
       title = title != null ? title.innerHTML : '';
       var author = document.getElementsByClassName('author')[0];
       author = author != null ? author.innerHTML : '';
       var date = document.getElementsByClassName('date')[0];
       date = date != null ? date.innerHTML : '';
       document.getElementById('header-left').innerHTML = '<a href="#/title-slide">' + title + '</a>';
       document.getElementById('footer-left').innerHTML = '<a href="https://pro.iesdonana.org">&copy; ' + author + ' (' + date + ')</a>';

       function updateHeader(nd) {
           var hr = document.getElementById('header-right');
           while (hr.children.length > 0) {
               hr.removeChild(hr.lastChild);
           }
           buscar(nd, 3, hr);
           buscar(nd, 2, hr);
           buscar(nd, 1, hr);
           hr.style.fontSize = Math.round(50 * Reveal.getScale()) + '%';
           hr.style.fontSize = Math.max(Number.parseInt(getComputedStyle(hr).fontSize), 12) + 'px';
           var hl = document.getElementById('header-left');
           hl.style.fontSize = hr.style.fontSize;
       }

       function buscar(nd, level, hr) {
           if (!nd.classList.contains('level' + (level - 1))) {
               for (var n = nd; n != null; n = n.previousSibling) {
                   if (n.nodeType == Node.TEXT_NODE) {
                       continue;
                   }
                   var cl = n.classList;
                   if (cl.contains('level' + level)) {
                       var h = n.querySelector('h' + level);
                   } else if (cl.contains('level' + (level - 1))) {
                       break;
                   } else {
                       continue;
                   }
                   if (h == null || Reveal.getCurrentSlide().id == 'title-slide') {
                       hr.innerHTML = '';
                   } else {
                       var el = document.createElement('a');
                       var href = '#/' + n.id;
                       el.href = href;
                       el.innerHTML = h.innerHTML;
                       var a = el.querySelector('a');
                       if (a !== null) {
                           a.href = href;
                       }
                       if (hr.innerHTML != '') {
                           hr.innerHTML = ' &mdash; ' + hr.innerHTML;
                       }
                       hr.insertBefore(el, hr.firstChild);
                   }
                   break;
               }
           }
       }

       // On Reveal.js ready event, copy header/footer <div>
       // into each `.slide-background` <div>
       Reveal.on('ready', event => {
           var header = document.getElementById('header');
           document.querySelector('.reveal').appendChild(header);
           updateHeader(Reveal.getCurrentSlide());
       });

       Reveal.on('slidechanged', event => {
           // event.previousSlide, event.currentSlide, event.indexh, event.indexv
           updateHeader(event.currentSlide);
       });
    </script>
    </body>
</html>
