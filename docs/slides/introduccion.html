<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Ricardo Pérez López">
  <title>Introducción</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="./reveal.js/dist/reset.css">
  <link rel="stylesheet" href="./reveal.js/dist/reveal.css">
  <style>
    .reveal .sourceCode {  /* see #7635 */
      overflow: visible;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      { color: #268bd2;  }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #cb4b16; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #d33682; } /* BaseN */
    code span.bu { color: #4070a0; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #dc322f; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #93a1a1; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #6c71c4; } /* DataType */
    code span.dv { color: #d33682; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #d33682; } /* Float */
    code span.fu { color: #4070a0; } /* Function */
    code span.im { font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #268bd2; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #a57800; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #2aa198; } /* SpecialString */
    code span.st { color: #2aa198; } /* String */
    code span.va { color: #6c71c4; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    /* CSS for citations */
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
      margin-bottom: 0em;
    }
    .hanging-indent div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }  </style>
  <link rel="stylesheet" href="./reveal.js/dist/theme/solarized.css" id="theme">
  <link rel="stylesheet" href="custom.css"/>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css" />
  <link href="https://fonts.googleapis.com/css?family=Lato&display=swap" rel="stylesheet">
  <style type="text/css">
      #header-left {
          position: absolute;
          font-size: 25%;
          top: 0%;
          left: 0%;
          margin-left: 10px;
          margin-top: 10px;
      }
      #header-right {
          position: absolute;
          font-size: 25%;
          top: 0%;
          right: 0%;
          margin-right: 10px;
          margin-top: 10px;
      }
      #footer-left {
          position: absolute;
          font-size: 25%;
          bottom: 0%;
          left: 0%;
          margin-left: 10px;
          margin-bottom: 10px;
      }
  </style>
</head>
<body>
<div id="hidden" style="display:none;">
    <div id="header">
        <div id="header-left"></div>
        <div id="header-right"></div>
        <div id="footer-left"></div>
    </div>
</div>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">Introducción</h1>
  <p class="author">Ricardo Pérez López</p>
  <p class="date">IES Doñana, curso 2025/2026</p>
</section>
<section id="TOC">
<nav role="doc-toc"> 
<ul>
<li><a href="#/conceptos-básicos" id="/toc-conceptos-básicos"><span
class="toc-section-number">1</span> Conceptos básicos</a></li>
<li><a href="#/paradigmas-de-programación"
id="/toc-paradigmas-de-programación"><span
class="toc-section-number">2</span> Paradigmas de programación</a></li>
<li><a href="#/resolución-de-problemas-mediante-programación"
id="/toc-resolución-de-problemas-mediante-programación"><span
class="toc-section-number">3</span> Resolución de problemas mediante
programación</a></li>
</ul>
</nav>
</section>

<section>
<section id="conceptos-básicos" class="title-slide slide level1"
data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span>
Conceptos básicos</h1>
<!--

---

```{=html}
<script data-quiz>
quiz = {"info":{"name":"","main":""},"questions":[{"q":"What number is the letter A in the English alphabet?","a":[{"option":"8","correct":false},{"option":"14","correct":false},{"option":"1","correct":true},{"option":"23","correct":false}],"correct":"<p><span>\u00a1Eso es!</span>The letter A is the first letter in the alphabet!</p>","incorrect":"<p><span>Mmmm... no.</span>It's the first letter of the alphabet. Did you actually <em>go</em> to kindergarden?</p>"}]}</script>
```

-->
</section>
<section id="informática" class="title-slide slide level2"
data-number="1.1">
<h2 data-number="1.1"><span class="header-section-number">1.1</span>
Informática</h2>
<ul>
<li><p>Definición:</p>
<div class="caja">
<p><strong>Informática</strong>:</p>
<p>La ciencia que estudia los sistemas de procesamiento automático de la
información, también llamados <strong>sistemas
informáticos</strong>.</p>
</div></li>
<li><p>Estos sistemas están formados por:</p>
<ul>
<li><p>Elementos físicos (<strong>hardware</strong>).</p></li>
<li><p>Elementos lógicos (<strong>software</strong>).</p></li>
<li><p>Elementos humanos (profesionales y usuarios).</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="1.1.0.0.1">

<ul>
<li><p>El <em>hardware</em> es todo aquello que podemos tocar:</p>
<ul>
<li><p>Ordenadores</p></li>
<li><p>Soportes de almacenamiento</p></li>
<li><p>Redes de comunicaciones</p></li>
<li><p>…</p></li>
</ul></li>
<li><p>El <em>software</em> es todo lo que <strong>no</strong> podemos
tocar:</p>
<ul>
<li><p>Datos</p></li>
<li><p>Programas</p></li>
</ul></li>
<li><p>Pero en este módulo, cuando hablemos de <em>software</em> en
general, nos estaremos refiriendo a <strong>programas</strong>.</p></li>
</ul>
</section>
<section id="procesamiento-automático" class="title-slide slide level3"
data-number="1.1.1">
<h3 data-number="1.1.1"><span class="header-section-number">1.1.1</span>
Procesamiento automático</h3>
<ul>
<li>El procesamiento automático de la información siempre tiene el mismo
esquema de funcionamiento:</li>
</ul>
<div class="centered">
<p><img data-src="images/procesamiento-automatico.svg" class="plain"
style="width:80.0%" /></p>
</div>
<ul>
<li><p>El <strong>objetivo</strong> del procesamiento automático de la
información es <strong>convertir los <em>datos de entrada</em> en
<em>datos de salida</em></strong> mediante un <em>hardware</em> que
ejecuta las instrucciones definidas por un <em>software</em>
(<strong>programas</strong>).</p></li>
<li><p>Los programas gobiernan el funcionamiento del <em>hardware</em>,
indicándole qué tiene que hacer y cómo.</p></li>
</ul>
<div class="caja">
<p>La <strong>Programación</strong> es la ciencia y el arte de diseñar
dichos programas.</p>
</div>
</section>
<section id="ejemplos" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejemplos</h5>
<ul>
<li><p>Calcular la suma de cinco números:</p>
<ul>
<li><p><strong>Entrada</strong>: los cinco números.</p></li>
<li><p><strong>Proceso</strong>: sumar cada número con el siguiente
hasta acumular el resultado final.</p></li>
<li><p><strong>Salida</strong>: la suma calculada.</p></li>
</ul></li>
<li><p>Dada una lista de alumnos con sus calificaciones finales, obtener
otra lista ordenada de mayor a menor por la calificación obtenida y que
muestre sólo los alumnos aprobados:</p>
<ul>
<li><p><strong>Entrada</strong>: Una lista de pares <em>(Nombre del
alumno, Calificación)</em>.</p></li>
<li><p><strong>Proceso</strong>: Eliminar de la lista los pares que
tengan una calificación menor que cinco y ordenar la lista resultante de
mayor a menor según la calificación.</p></li>
<li><p><strong>Salida</strong>: la lista ordenada de alumnos
aprobados.</p></li>
</ul></li>
</ul>
</section>
<section id="ejercicio" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejercicio</h5>
<ol class="example" type="1">
<li><p>Identificar la entrada, el proceso y la salida en los siguientes
supuestos:</p>
<ol type="a">
<li><p>Convertir una temperatura en grados Fahrenheit a
Celsius.</p></li>
<li><p>Calcular el área de un triángulo a partir de su base y su
altura.</p></li>
<li><p>Calcular el perímetro de un cuadrado.</p></li>
<li><p>Determinar si una llamada entrante en un teléfono móvil es
sospechosa de <em>spam</em>.</p></li>
</ol></li>
</ol>
</section>


<section id="ordenador" class="title-slide slide level2"
data-number="1.2">
<h2 data-number="1.2"><span class="header-section-number">1.2</span>
Ordenador</h2>

</section>
<section id="definición" class="title-slide slide level3"
data-number="1.2.1">
<h3 data-number="1.2.1"><span class="header-section-number">1.2.1</span>
Definición</h3>
<div class="caja">
<p><strong>Ordenador</strong>:</p>
<p>Un ordenador es una máquina que procesa información automáticamente
de acuerdo con un programa almacenado.</p>
</div>
<ul>
<li><p>Es una <em>máquina</em>.</p></li>
<li><p>Su función es <em>procesar información</em>.</p></li>
<li><p>El procesamiento se realiza de forma
<em>automática</em>.</p></li>
<li><p>El procesamiento se realiza siguiendo un <em>programa</em>
(<em>software</em>).</p></li>
<li><p>Este programa está <em>almacenado</em> en una memoria interna del
mismo ordenador (arquitectura de <strong>Von Neumann</strong>).</p></li>
</ul>
</section>

<section id="funcionamiento-básico" class="title-slide slide level3"
data-number="1.2.2">
<h3 data-number="1.2.2"><span class="header-section-number">1.2.2</span>
Funcionamiento básico</h3>

</section>
<section id="elementos-funcionales" class="title-slide slide level4"
data-number="1.2.2.1">
<h4 data-number="1.2.2.1"><span
class="header-section-number">1.2.2.1</span> Elementos funcionales</h4>
<ul>
<li><p>Un ordenador consta de tres componentes principales:</p>
<ol type="1">
<li><p><strong>Unidad central de proceso (CPU) o procesador</strong></p>
<ul>
<li><p><em>Unidad aritmético-lógica (ALU)</em></p></li>
<li><p><em>Unidad de control (UC)</em></p></li>
</ul></li>
<li><p><strong>Memoria</strong></p>
<ul>
<li><p><em>Memoria principal</em> o central</p>
<ul>
<li><p><em>Memoria de acceso aleatorio (RAM)</em></p></li>
<li><p><em>Memoria de sólo lectura (ROM)</em></p></li>
</ul></li>
<li><p><em>Memoria secundaria</em> o externa</p></li>
</ul></li>
<li><p><strong>Dispositivos de E/S</strong></p>
<ul>
<li><p><em>Dispositivos de entrada</em></p></li>
<li><p><em>Dispositivos de salida</em></p></li>
</ul></li>
</ol></li>
</ul>
</section>

<section id="unidad-central-de-proceso-cpu-o-procesador"
class="title-slide slide level4" data-number="1.2.2.2">
<h4 data-number="1.2.2.2"><span
class="header-section-number">1.2.2.2</span> Unidad central de proceso
(CPU) o procesador</h4>
<ul>
<li><p><strong>Unidad aritmético-lógica (ALU)</strong>:</p>
<p>Realiza los cálculos y el procesamiento numérico y lógico.</p></li>
<li><p><strong>Unidad de control (UC)</strong>:</p>
<p>Ejecuta de las instrucciones enviando las señales a las distintas
unidades funcionales involucradas.</p></li>
</ul>
</section>

<section id="memoria" class="title-slide slide level4"
data-number="1.2.2.3">
<h4 data-number="1.2.2.3"><span
class="header-section-number">1.2.2.3</span> Memoria</h4>
<ul>
<li><p><strong>Memoria principal</strong> o central:</p>
<p>Almacena los datos y los programas que los manipulan.</p>
<p>Ambos (datos y programas) deben estar en la memoria principal para
que la CPU pueda acceder a ellos.</p>
<p>Dos tipos:</p>
<ul>
<li><p><strong>Memoria de acceso aleatorio (RAM)</strong>:</p>
<p>Su contenido se borra al apagar el ordenador.</p></li>
<li><p><strong>Memoria de sólo lectura (ROM)</strong>:</p>
<p>Información permanente (ni se borra ni se puede cambiar).</p>
<p>Contiene la información esencial (datos y software) para que el
ordenador pueda arrancar.</p></li>
</ul></li>
<li><p><strong>Memoria secundaria</strong> o externa:</p>
<p>La información no se pierde al apagar el ordenador.</p>
<p>Más lenta que la memoria principal, pero de mucha más
capacidad.</p></li>
</ul>
</section>

<section id="dispositivos-de-es" class="title-slide slide level4"
data-number="1.2.2.4">
<h4 data-number="1.2.2.4"><span
class="header-section-number">1.2.2.4</span> Dispositivos de E/S</h4>
<ul>
<li><p><strong>Dispositivos de entrada</strong>:</p>
<p>Introducen datos en el ordenador (<em>ejemplos</em>: teclado, ratón,
escáner…)</p></li>
<li><p><strong>Dispositivos de salida</strong>:</p>
<p>Vuelcan datos fuera del ordenador (<em>ejemplos</em>: pantalla,
impresora…)</p></li>
<li><p><strong>Dispositivos de entrada/salida</strong>:</p>
<p>Actúan simultáneamente como dispositivos de entrada y de salida
(<em>ejemplos</em>: pantalla táctil, adaptador de red…)</p></li>
<li><p>Los dispositivos que acceden a <strong>soportes de almacenamiento
masivo</strong> (las <strong>memorias secundarias</strong>) también se
pueden considerar dispositivos de E/S:</p>
<ul>
<li><p>Los soportes de <strong>sólo lectura</strong> se leen con
dispositivos de entrada (<em>ejemplo</em>: discos ópticos).</p></li>
<li><p>Los soportes de <strong>lectura/escritura</strong> operan como
dispositivos de entrada/salida (<em>ejemplos</em>: discos duros,
pendrives, tarjetas SD…).</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="1.2.2.4.1">

<div class="centered">
<figure>
<img data-src="images/esquema-basico.svg" class="plain"
style="width:80.0%" alt="Esquema básico de un ordenador" />
<figcaption aria-hidden="true">Esquema básico de un
ordenador</figcaption>
</figure>
</div>
<ul>
<li><p>El programa se <strong>carga</strong> de la memoria secundaria a
la memoria principal.</p></li>
<li><p>Una vez allí, la CPU va <strong>extrayendo</strong> las
instrucciones que forman el programa y las va
<strong>ejecutando</strong> paso a paso, en un bucle continuo que se
denomina <strong>ciclo de instrucción</strong>.</p></li>
<li><p>Durante la ejecución del programa, la CPU recogerá los datos de
entrada desde los dispositivos de entrada y los almacenará en la memoria
principal, para que las instrucciones puedan operar con ellos.</p></li>
<li><p>Finalmente, los datos de salida se volcarán hacia los
dispositivos de salida.</p></li>
</ul>
</section>

<section id="ciclo-de-instrucción" class="title-slide slide level4"
data-number="1.2.2.5">
<h4 data-number="1.2.2.5"><span
class="header-section-number">1.2.2.5</span> Ciclo de instrucción</h4>
<ul>
<li><p>En la <strong>arquitectura Von Neumann</strong>, los programas se
almacenan en la memoria principal junto con los datos (por eso también
se denomina «arquitectura de <strong>programa
almacenado</strong>»).</p></li>
<li><p>Una vez que el programa está cargado en memoria, la CPU repite
siempre los mismos pasos:</p>
<ol>
<li><p>(<strong>Fetch</strong>) Busca la siguiente instrucción en la
memoria principal.</p></li>
<li><p>(<strong>Decode</strong>) Decodifica la instrucción (identifica
qué instrucción es y se prepara para su ejecución).</p></li>
<li><p>(<strong>Execute</strong>) Ejecuta la instrucción (envía las
señales de control necesarias a las distintas unidades
funcionales).</p></li>
</ol></li>
</ul>
</section>
<section class="slide level5" data-number="1.2.2.5.1">

<div class="centered">
<figure>
<img data-src="images/ciclo-instruccion.svg" class="plain"
style="width:80.0%" alt="Ciclo de instrucción" />
<figcaption aria-hidden="true">Ciclo de instrucción</figcaption>
</figure>
</div>
</section>

<section id="representación-de-información"
class="title-slide slide level4" data-number="1.2.2.6">
<h4 data-number="1.2.2.6"><span
class="header-section-number">1.2.2.6</span> Representación de
información</h4>
<ul>
<li><p>En un sistema informático, toda la información se almacena y se
manipula en forma de números.</p></li>
<li><p>Por tanto, para que un sistema informático pueda procesar
información, primero hay que representar dicha información usando
números, proceso que se denomina <strong>codificación</strong>.</p>
<div class="caja">
<p><strong>Codificación</strong>:</p>
<p>Proceso mediante el cual se representa información dentro de un
sistema informático, asociando a cada dato uno o más valores
numéricos.</p>
</div></li>
<li><p>Una codificación, por tanto, es una correspondencia entre un
conjunto de datos y un conjunto de números llamado
<strong>código</strong>. Al codificar, lo que hacemos es asociar a cada
dato un determinado número dentro del código.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.2.2.6.1">

<ul>
<li><p>Hay muchos tipos de información (textos, sonidos, imágenes,
valores numéricos…) y eso hace que pueda haber muchas formas de
codificación.</p></li>
<li><p>Incluso un mismo tipo de dato (un número entero, por ejemplo)
puede tener distintas codificaciones, cada una con sus características y
propiedades.</p></li>
<li><p>Distinguimos la forma en la que se representa la información
<em>internamente</em> en el sistema informático (<strong>codificación
interna</strong>) de la que usamos para comunicar dicha información
<em>desde y hacia el exterior</em> (<strong>codificación
externa</strong> o <strong>de E/S</strong>).</p></li>
</ul>
<div class="centered">
<p><img data-src="images/codificaciones.svg" class="plain"
style="width:80.0%" /></p>
</div>
</section>

<section id="codificación-interna" class="title-slide slide level4"
data-number="1.2.2.7">
<h4 data-number="1.2.2.7"><span
class="header-section-number">1.2.2.7</span> Codificación interna</h4>
<ul>
<li><p>Los ordenadores son <strong>sistemas electrónicos
digitales</strong> que trabajan conmutando entre varios posibles estados
de una determinada magnitud física (voltaje, intensidad de corriente,
etc.).</p></li>
<li><p>Lo más sencillo y práctico es usar únicamente dos estados
posibles.</p>
<p>Por ejemplo:</p>
<ul>
<li><p>0 V y 5 V de voltaje.</p></li>
<li><p>0 mA y 100 mA de intensidad de corriente.</p></li>
</ul></li>
<li><p>A cada uno de los dos posibles estados le hacemos corresponder
(arbitrariamente) un valor numérico <strong>0</strong> ó
<strong>1</strong>. A ese valor se le denomina <strong>bit</strong>
(contracción de <em>binary digit</em>, dígito binario).</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.2.2.7.1">

<ul>
<li><p>Por ejemplo, la memoria principal de un ordenador está formada
por millones de celdas, parecidas a microscópicos condensadores. Cada
uno de estos condensadores puede estar cargado o descargado y, por
tanto, es capaz de almacenar un bit:</p>
<ul>
<li>Condensador cargado: bit a 1</li>
<li>Condensador descargado: bit a 0</li>
</ul>
<div class="caja">
<p><strong>Bit</strong>:</p>
<p>Un bit es, por tanto, la unidad mínima de información que es capaz de
almacenar y procesar un ordenador, y equivale a un <strong>dígito
binario</strong>.</p>
</div></li>
<li><p>En la práctica, se usan unidades múltiplos del bit:</p>
<ul>
<li>1 byte = 8 bits</li>
<li>1 Kibibyte (KiB) = <span class="math inline">2^{10}</span> bytes =
1024 bytes</li>
<li>1 Mebibyte (MiB) = <span class="math inline">2^{20}</span> bytes =
1024 Kibibytes</li>
<li>1 Gibibyte (GiB) = <span class="math inline">2^{30}</span> bytes =
1024 Mebibytes</li>
<li>1 Tebibyte (TiB) = <span class="math inline">2^{40}</span> bytes =
1024 Gibibytes</li>
</ul></li>
</ul>
</section>

<section id="sistema-binario" class="title-slide slide level4"
data-number="1.2.2.8">
<h4 data-number="1.2.2.8"><span
class="header-section-number">1.2.2.8</span> Sistema binario</h4>
<ul>
<li><p>El sistema de numeración que usamos habitualmente los seres
humanos es el <strong>decimal</strong> o sistema <strong>en base
diez</strong>.</p></li>
<li><p>En ese sistema disponemos de diez dígitos distintos (0, 1, 2, 3,
4, 5, 6, 7, 8 y 9) y cada dígito en un determinado número tiene un peso
que es múltiplo de una potencia de diez.</p>
<p>Por ejemplo: <span class="math display">243 = 2 \times 10^2 + 4
\times 10^1 + 3 \times 10^0</span></p></li>
<li><p>El sistema de numeración que usan los ordenadores es el
<strong>sistema binario</strong> o sistema <strong>en base dos</strong>,
en el cual disponemos sólo de dos dígitos (0 y 1) y cada peso es
múltiplo de una potencia de dos.</p>
<p>Por ejemplo: <span class="math display">101 = 1 \times 2^2 + 0 \times
2^1 + 1 \times 2^0</span></p></li>
</ul>
</section>
<section class="slide level5" data-number="1.2.2.8.1">

<ul>
<li><p>Generalmente, los <strong>números naturales</strong> se codifican
internamente mediante su representación en binario.</p></li>
<li><p>Los <strong>números enteros</strong> se suelen codificar
mediante:</p>
<ul>
<li><p>Bit de signo (signo y magnitud)</p></li>
<li><p>Complemento a uno</p></li>
<li><p>Complemento a dos</p></li>
</ul></li>
<li><p>Los <strong>números reales</strong> se pueden codificar
mediante:</p>
<ul>
<li><p>Coma fija</p></li>
<li><p>Coma flotante</p>
<ul>
<li><p>Simple precisión</p></li>
<li><p>Doble precisión</p></li>
</ul></li>
<li><p>Decimal codificado en binario (BCD)</p></li>
</ul></li>
</ul>
</section>

<section id="codificación-externa" class="title-slide slide level4"
data-number="1.2.2.9">
<h4 data-number="1.2.2.9"><span
class="header-section-number">1.2.2.9</span> Codificación externa</h4>
<ul>
<li><p>La información enviada desde y hacia el exterior del sistema
informático se representa en forma de <strong>cadenas de
caracteres</strong>.</p></li>
<li><p>Para representar cadenas de caracteres y comunicarse con el
exterior, el ordenador utiliza <strong>códigos de E/S</strong> o
<strong>códigos externos</strong>.</p></li>
<li><p>A cada carácter (letra, dígito, signo de puntuación, símbolo
especial…) le corresponde un <em>código</em> (que es un número) dentro
de un <strong>conjunto de caracteres</strong>.</p></li>
<li><p>Existen conjuntos de caracteres:</p>
<ul>
<li><p>De <strong>longitud fija</strong>: a todos los caracteres les
corresponden un código, y todos los códigos tienen la misma longitud
(mismo número de bytes).</p></li>
<li><p>De <strong>longitud variable</strong>: en el mismo conjunto de
caracteres hay códigos más largos y más cortos (por tanto, hay
caracteres que ocupan más bytes que otros).</p></li>
</ul></li>
</ul>
</section>

<section id="ascii" class="title-slide slide level4"
data-number="1.2.2.10">
<h4 data-number="1.2.2.10"><span
class="header-section-number">1.2.2.10</span> ASCII</h4>
<ul>
<li><p><em>American Standard Code for Information
Interchange</em>.</p></li>
<li><p>El conjunto de caracteres ASCII (o <strong>código ASCII</strong>)
es el más implantado en el <em>hardware</em> de los equipos
informáticos.</p></li>
<li><p>Es la base de otros códigos más modernos, como el ISO-8859-1 o el
Unicode.</p></li>
<li><p>Es un código de 7 bits:</p>
<ul>
<li><p>Cada carácter ocupa 7 bits.</p></li>
<li><p>Hay <span class="math inline">2^7 = 128</span> caracteres
posibles.</p></li>
<li><p>Los 32 primeros códigos (del 0 al 31) son no imprimibles (códigos
de control).</p></li>
</ul></li>
<li><p>El ISO-8859-1 es un código de 8 bits que extiende el ASCII con un
bit más para contener caracteres latinos.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.2.2.10.1">

<ul>
<li><p>Tabla de caracteres ASCII estándar de 7 bits:</p>
<div class="caja">
<pre><code>Dec Hex Car    Dec Hex Car    Dec Hex Car    Dec Hex Car
--- --- ---    --- --- ---    --- --- ---    --- --- ---
32  20         56  38   8     80  50   P     104 68   h
33  21   !     57  39   9     81  51   Q     105 69   i
34  22   &quot;     58  3A   :     82  52   R     106 6A   j
35  23   #     59  3B   ;     83  53   S     107 6B   k
36  24   $     60  3C   &lt;     84  54   T     108 6C   l
37  25   %     61  3D   =     85  55   U     109 6D   m
38  26   &amp;     62  3E   &gt;     86  56   V     110 6E   n
39  27   &#39;     63  3F   ?     87  57   W     111 6F   o
40  28   (     64  40   @     88  58   X     112 70   p
41  29   )     65  41   A     89  59   Y     113 71   q
42  2A   *     66  42   B     90  5A   Z     114 72   r
43  2B   +     67  43   C     91  5B   [     115 73   s
44  2C   ,     68  44   D     92  5C   \     116 74   t
45  2D   -     69  45   E     93  5D   ]     117 75   u
46  2E   .     70  46   F     94  5E   ^     118 76   v
47  2F   /     71  47   G     95  5F   _     119 77   w
48  30   0     72  48   H     96  60   `     120 78   x
49  31   1     73  49   I     97  61   a     121 79   y
50  32   2     74  4A   J     98  62   b     122 7A   z
51  33   3     75  4B   K     99  63   c     123 7B   {
52  34   4     76  4C   L     100 64   d     124 7C   |
53  35   5     77  4D   M     101 65   e     125 7D   }
54  36   6     78  4E   N     102 66   f     126 7E   ~
55  37   7     79  4F   O     103 67   g</code></pre>
</div></li>
</ul>
</section>

<section id="unicode" class="title-slide slide level4"
data-number="1.2.2.11">
<h4 data-number="1.2.2.11"><span
class="header-section-number">1.2.2.11</span> Unicode</h4>
<ul>
<li><p>Con 8 bits (y con 7 bits aún menos) no es posible representar
todos los posibles caracteres de todos los sistemas de escritura usados
en el mundo.</p></li>
<li><p>Unicode es el estándar de codificación de caracteres más completo
y universal en la actualidad.</p></li>
<li><p>Cada carácter en Unicode se define mediante un identificador
numérico llamado <em>code point</em>.</p></li>
<li><p>Unicode define tres formas de codificación:</p>
<ul>
<li><p><strong>UTF-8</strong>: codificación de 8 bits, de longitud
variable (cada <em>code point</em> puede ocupar de 1 a 4 bytes).
<strong>El más usado en la actualidad.</strong></p></li>
<li><p><strong>UTF-16</strong>: codificación de 16 bits, de longitud
variable (cada <em>code point</em> puede ocupar 1 ó 2 palabras de 16
bits).</p></li>
<li><p><strong>UTF-32</strong>: codificación de 32 bits, de longitud
fija (cada <em>code point</em> ocupa 1 palabra de 32 bits).</p></li>
</ul></li>
</ul>
</section>



<section id="problema" class="title-slide slide level2"
data-number="1.3">
<h2 data-number="1.3"><span class="header-section-number">1.3</span>
Problema</h2>
<ul>
<li><p>Escribimos programas para que el ordenador procese información de
forma automática.</p></li>
<li><p>Pero ese procesamiento automático se lleva a cabo por una razón:
<strong>resolver un problema</strong> usando un ordenador.</p></li>
<li><p>Si un problema es <strong>resoluble</strong> usando un ordenador
(<em>no todos lo son</em>), podremos escribir un programa que lo
resuelva.</p></li>
<li><p>Estos son los problemas que nos interesa estudiar en
Programación.</p></li>
</ul>
</section>
<section id="generalización" class="title-slide slide level3"
data-number="1.3.1">
<h3 data-number="1.3.1"><span class="header-section-number">1.3.1</span>
Generalización</h3>
<ul>
<li><p>En Programación nos interesa siempre resolver problemas generales
y no casos particulares.</p></li>
<li><p>Por ejemplo, el problema de calcular la suma de 4 y 3 es un
<strong>problema particular</strong>, porque una solución al problema
sólo servirá para resolver <em>ese</em> problema en concreto, y no
servirá para sumar otro par de números (el 9 y 5, por ejemplo).</p></li>
<li><p>En cambio, el problema de calcular la suma de cualquier par de
números enteros es un <strong>problema general</strong>, ya que una
solución al problema serviría para resolver cualquier caso particular de
ese problema general.</p>
<ul>
<li>Por ejemplo, esa solución al problema general me serviría para
calcular la suma de 4 y 3, de 9 y 5, de 12 y 38, … De hecho, infinitos
casos particulares.</li>
</ul></li>
</ul>
</section>

<section id="ejemplares-de-un-problema" class="title-slide slide level3"
data-number="1.3.2">
<h3 data-number="1.3.2"><span class="header-section-number">1.3.2</span>
Ejemplares de un problema</h3>
<ul>
<li><p>A los casos particulares de un problema general se les denomina
<strong>ejemplares</strong> del problema.</p>
<ul>
<li>Por ejemplo, la pareja <span class="math inline">(4, 3)</span> es un
ejemplar del problema general de sumar dos números enteros.</li>
</ul></li>
<li><p>Normalmente, un problema consistirá en una colección infinita de
ejemplares.</p>
<ul>
<li>Pero también hay problemas finitos (aunque muy grandes) como el de
jugar perfectamente al ajedrez.</li>
</ul></li>
<li><p>La solución a un problema debe resolver correctamente todos los
ejemplares del mismo, es decir, debe resolver el problema general de
forma que sirva para todos sus ejemplares.</p></li>
</ul>
</section>

<section id="dominio-de-definición" class="title-slide slide level3"
data-number="1.3.3">
<h3 data-number="1.3.3"><span class="header-section-number">1.3.3</span>
Dominio de definición</h3>
<ul>
<li><p>El <strong>dominio de definición</strong> de un problema describe
con precisión el conjunto de sus ejemplares.</p>
<ul>
<li>Por ejemplo: en el problema de sumar dos números enteros, sus
ejemplares serán cualquier pareja de números enteros (no vale que los
números sean reales o fracciones). Ese es su dominio de definición.</li>
</ul></li>
<li><p>La solución al problema debe centrarse en el dominio de
definición del problema, y no está obligado a resolver ejemplares que se
encuentren fuera de dicho dominio de definición.</p>
<ul>
<li>Por ejemplo: un programa que resuelva correctamente el problema de
sumar dos números enteros no tiene por qué funcionar correctamente si
intentamos usarlo para sumar dos fracciones.</li>
</ul></li>
</ul>
</section>

<section id="jerarquías-de-generalización"
class="title-slide slide level3" data-number="1.3.4">
<h3 data-number="1.3.4"><span class="header-section-number">1.3.4</span>
Jerarquías de generalización</h3>
<ul>
<li><p>Se dice que un problema <span class="math inline">P</span> es
<strong>más general</strong> que un problema <span
class="math inline">Q</span> (o bien, que es una
<strong>generalización</strong> del problema <span
class="math inline">Q</span>) si los ejemplares de <span
class="math inline">Q</span> también son ejemplares de <span
class="math inline">P</span>, y además hay ejemplares de <span
class="math inline">P</span> que no lo son de <span
class="math inline">Q</span>.</p>
<ul>
<li>Es otra forma de decir que el conjunto de ejemplares de <span
class="math inline">Q</span> es un <em>subconjunto propio</em> del
conjunto de ejemplares de <span class="math inline">P</span>.</li>
</ul></li>
<li><p>Igualmente, se dice que <span class="math inline">Q</span> es un
problema <strong>menos general</strong> o <strong>más
particular</strong> que el problema <span class="math inline">P</span>
(o bien, que es una <strong>especialización</strong> del problema <span
class="math inline">P</span>).</p></li>
<li><p>Este concepto resulta interesante porque, si tenemos una solución
al problema <span class="math inline">P</span>, podremos usarla para
resolver el problema <span class="math inline">Q</span>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.3.4.0.1">

<div class="centered">
<figure>
<img data-src="images/jerarquias-generalizacion.svg" class="plain"
style="width:50.0%" alt="P es un problema más general que Q" />
<figcaption aria-hidden="true"><span class="math inline">P</span> es un
problema más general que <span class="math inline">Q</span></figcaption>
</figure>
</div>
</section>
<section class="slide level5" data-number="1.3.4.0.2">

<ul>
<li><p>Por ejemplo, el problema de calcular la suma de <em>tres</em>
números enteros es un problema <strong>más general</strong> que el de
sumar <em>dos</em> números enteros, porque éste último se puede
considerar un caso particular del primero (haciendo que uno de los tres
números a sumar valga cero).</p></li>
<li><p>Por tanto, si tenemos un método para resolver el problema más
general (el de sumar tres números) podemos usarlo para resolver uno
menos general (el de sumar dos números).</p></li>
<li><p>En este caso, basta con hacer que uno de los tres números sea
cero y los otros dos sean los números a sumar:</p></li>
</ul>
<div class="centered">
<figure>
<img data-src="images/sumar-dos-numeros.svg" class="plain"
style="width:50.0%"
alt="Sumar dos números es un caso particular de sumar tres" />
<figcaption aria-hidden="true">Sumar dos números es un caso particular
de sumar tres</figcaption>
</figure>
</div>
</section>
<section id="ejercicios" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejercicios</h5>
<ol start="2" class="example" type="1">
<li><p>Con cada uno de los siguientes problemas, dar al menos un
ejemplar del mismo e inventar un problema más general:</p>
<ol type="a">
<li><p>Calcular cuántos días han pasado entre dos fechas del mismo
año.</p></li>
<li><p>Calcular el perímetro de un cuadrado a partir de la longitud de
uno de sus lados.</p></li>
</ol></li>
<li><p>Inventar un problema más particular para el problema de sumar dos
fracciones de números enteros y dar dos ejemplares distintos de cada uno
de los dos problemas.</p></li>
<li><p>Dado el siguiente problema: «Calcular cuántos picos y cuántas
patas hay en una granja con <span class="math inline">X</span> gallinas
y <span class="math inline">Y</span> cerdos», determinar si los
siguientes casos son <em>ejemplares</em> del problema o bien son
<em>especializaciones</em> del problema:</p>
<ol type="a">
<li><p>Calcular cuántos picos y cuántas patas hay en una granja con 5
gallinas y 7 cerdos.</p></li>
<li><p>Calcular cuántas patas hay en una granja con <span
class="math inline">Z</span> cerdos.</p></li>
</ol></li>
</ol>
</section>


<section id="algoritmo" class="title-slide slide level2"
data-number="1.4">
<h2 data-number="1.4"><span class="header-section-number">1.4</span>
Algoritmo</h2>

</section>
<section id="definición-1" class="title-slide slide level3"
data-number="1.4.1">
<h3 data-number="1.4.1"><span class="header-section-number">1.4.1</span>
Definición</h3>
<div class="caja">
<p><strong>Algoritmo</strong>:</p>
<p>Un algoritmo es un método para resolver un problema.</p>
</div>
<ul>
<li><p>Está formado por una secuencia de pasos o
<strong>instrucciones</strong> que se deben seguir (o
<strong>ejecutar</strong>) para resolver el problema.</p></li>
<li><p>La palabra «algoritmo» proviene de <strong>Mohammed
Al-Khowârizmi</strong>, matemático persa que vivió durante el siglo IX y
reconocido por definir una serie de reglas paso a paso para sumar,
restar, multiplicar y dividir números decimales.</p></li>
<li><p><strong>Euclides</strong>, el gran matemático griego (del siglo
IV a. C.) que inventó un método para encontrar el máximo común divisor
de dos números, se considera con Al-Khowârizmi el otro gran padre de la
Algorítmica (la ciencia que estudia los algoritmos).</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.4.1.0.1">

<ul>
<li><p>El estudio de los algoritmos es importante porque la resolución
de un problema exige el diseño de un algoritmo que lo resuelva.</p></li>
<li><p>Puede haber muchas formas distintas de resolver el mismo
problema, por lo que <strong>pueden existir muchos algoritmos distintos
que resuelvan el mismo problema</strong>.</p>
<p>Un algoritmo será mejor que otro si es más claro o más
eficiente.</p></li>
<li><p>Una vez diseñado el algoritmo, se traduce a un programa
informático usando un <em>lenguaje de programación</em>.</p></li>
<li><p>Finalmente, un ordenador ejecuta dicho programa.</p></li>
</ul>
<div class="centered">
<figure>
<img data-src="images/resolucion-problema.svg" class="plain"
style="width:80.0%" alt="Resolución de un problema" />
<figcaption aria-hidden="true">Resolución de un problema</figcaption>
</figure>
</div>
</section>
<section class="slide level5" data-number="1.4.1.0.2">

<script data-quiz>
quiz = {"info":{"name":"","main":""},"questions":[{"q":"\u00bfQu\u00e9 es lo primero que hay que hacer a la hora de resolver un problema mediante un programa inform\u00e1tico?","a":[{"option":"Dise\u00f1ar el algoritmo","correct":false},{"option":"Estudiar el problema","correct":true},{"option":"Ejecutar el programa","correct":false},{"option":"Escribir el programa","correct":false}],"correct":"<p><span>\u00a1Eso es!</span>Lo primero que hay que hacer es estudiar el problema que hay que resolver.</p>","incorrect":"<p><span>Mmmm... no.</span>Hay algo que debes hacer antes.</p>"},{"q":"\u00bfY lo segundo?","a":[{"option":"Ejecutar el programa","correct":false},{"option":"Estudiar el problema","correct":false},{"option":"Escribir el programa","correct":false},{"option":"Dise\u00f1ar el algoritmo","correct":true}],"correct":"<p><span>\u00a1Eso es!</span>Lo segundo es dise\u00f1ar el algoritmo que resuelva el problema.</p>","incorrect":"<p><span>Mmmm... no.</span>No es correcto.</p>"},{"q":"\u00bfY lo tercero?","a":[{"option":"Estudiar el problema","correct":false},{"option":"Ejecutar el programa","correct":false},{"option":"Escribir el programa","correct":true},{"option":"Dise\u00f1ar el algoritmo","correct":false}],"correct":"<p><span>\u00a1Eso es!</span>Lo tercero es traducir el algoritmo en un programa usando un lenguaje de programaci\u00f3n.</p>","incorrect":"<p><span>Mmmm... no.</span>No es correcto.</p>"},{"q":"\u00bfY por \u00faltimo?","a":[{"option":"Escribir el programa","correct":false},{"option":"Ejecutar el programa","correct":true},{"option":"Estudiar el problema","correct":false},{"option":"Dise\u00f1ar el algoritmo","correct":false}],"correct":"<p><span>\u00a1Eso es!</span>Por \u00faltimo, se ejecuta el programa en un ordenador.</p>","incorrect":"<p><span>Mmmm... no.</span>Eso se debe hacer antes.</p>"}]}</script>
</section>

<section id="características" class="title-slide slide level3"
data-number="1.4.2">
<h3 data-number="1.4.2"><span class="header-section-number">1.4.2</span>
Características</h3>
<ul>
<li><p>Un algoritmo debe ser:</p>
<ul>
<li><p><strong>Preciso</strong>: debe expresarse de forma no ambigua. La
precisión afecta por igual a dos aspectos:</p>
<ul>
<li><p>Al <em>orden</em> de los pasos que han de llevarse a
cabo.</p></li>
<li><p>Al <em>contenido</em> de los pasos, pues en cada uno hay que
saber qué hacer exactamente.</p></li>
</ul></li>
<li><p><strong>Determinado</strong>: si se sigue un algoritmo dos veces,
se debe obtener el mismo resultado cada vez.</p></li>
<li><p><strong>Finito</strong>: debe terminar en algún momento, es
decir, debe tener un número finito de pasos.</p></li>
</ul></li>
</ul>
</section>

<section id="representación" class="title-slide slide level3"
data-number="1.4.3">
<h3 data-number="1.4.3"><span class="header-section-number">1.4.3</span>
Representación</h3>
<div class="columns">
<div class="column" style="width:47%;">
<ul>
<li><p>Un algoritmo se puede describir usando el <strong>lenguaje
natural</strong>, es decir, cualquier idioma humano.</p></li>
<li><p>¿Qué <span style="color:red">problema</span> tiene esta forma de
representación?</p>
<div class="centered">
<p><span style="color:red"><strong>Ambigüedad</strong></span></p>
</div></li>
<li><p>En ciertos contextos la ambigüedad es asumible, pero
<strong>NO</strong> cuando el destinatario es un ordenador.</p></li>
<li><p>¿Podemos decir que esta receta de cocina es un
algoritmo?</p></li>
</ul>
</div><div class="column" style="width:3%;">

</div><div class="column" style="width:47%;">
<div class="caja">
<div style="font-size: 90%">
<p><strong>Instrucciones para hacer una tortilla</strong>:</p>
<ol type="1">
<li>Coger dos huevos.</li>
<li>Encender el fuego.</li>
<li>Echar aceite a la sartén.</li>
<li>Batir los huevos.</li>
<li>Echar los huevos batidos en la sartén.</li>
<li>Esperar a que se haga por debajo.</li>
<li>Dar la vuelta a la tortilla.</li>
<li>Esperar de nuevo.</li>
<li>Sacar cuando esté lista.</li>
</ol>
<p><strong>Fin</strong></p>
</div>
</div>
</div>
</div>
</section>
<section id="ordinograma" class="title-slide slide level4"
data-number="1.4.3.1">
<h4 data-number="1.4.3.1"><span
class="header-section-number">1.4.3.1</span> Ordinograma</h4>
<ul>
<li><p>Representación gráfica que describe un algoritmo en forma de
diagrama de flujo.</p></li>
<li><p>Las flechas indican el orden de ejecución de las
instrucciones.</p></li>
<li><p>Los nodos condicionales (los rombos) indican que la ejecución se
bifurca a uno u otro camino dependiendo de si se cumple o no una
condición.</p></li>
</ul>
</section>
<section id="ejemplo" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejemplo</h5>
<p>Determinar cuál es el máximo de dos números</p>
<div class="centered">
<p><img data-src="images/maximo.svg" class="plain"
style="width:50.0%" /></p>
</div>
</section>

<section id="pseudocódigo" class="title-slide slide level4"
data-number="1.4.3.2">
<h4 data-number="1.4.3.2"><span
class="header-section-number">1.4.3.2</span> Pseudocódigo</h4>
<ul>
<li><p>Es un <strong>lenguaje <em>semi-formal</em></strong>, a medio
camino entre el lenguaje natural y el lenguaje que entendería un
ordenador (lenguaje de programación).</p></li>
<li><p>Está pensado para ser interpretado por una persona y no por un
ordenador.</p></li>
<li><p>En general, no se tienen en cuenta las limitaciones impuestas por
el <em>hardware</em> (CPU, memoria…) o el <em>software</em> (tamaño
máximo de los datos, codificación interna…), siempre y cuando no sea
importante el estudio de la eficiencia o la complejidad del
algoritmo.</p></li>
<li><p>En ese sentido, se usa como un lenguaje de programación
<em>idealizado</em>, es decir, una <em>abstracción</em> de un lenguaje
de programación real en el que no se tienen en cuenta ciertos detalles
que resultan innecesarios para entender el funcionamiento del
algoritmo.</p></li>
<li><p>Por ejemplo, en general no nos tenemos que preocupar de si el
resultado de sumar dos números enteros sobrepasa el tamaño máximo
establecido para almacenar un entero.</p></li>
</ul>
</section>
<section id="ejemplo-1" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejemplo</h5>
<div class="line-block"><strong>Algoritmo</strong>: Obtener el mayor de
dos números<br />
<br />
1. <span class="math inline">X \leftarrow</span> <strong>leer</strong>
número<br />
2. <span class="math inline">Y \leftarrow</span> <strong>leer</strong>
número<br />
3. <strong>si</strong> <span class="math inline">X &gt; Y</span>
<strong>entonces</strong> <strong>saltar</strong> al paso 6<br />
4. <strong>escribir</strong> “Y es mayor que X”<br />
5. <strong>saltar</strong> al paso 7<br />
6. <strong>escribir</strong> “X es mayor que Y”<br />
7. <strong>fin</strong></div>
</section>
<section class="slide level5" data-number="1.4.3.2.1">

<ul>
<li><p>No existe un único <em>pseudocódigo</em>.</p></li>
<li><p>A la hora de usar un pseudocódigo para representar un algoritmo,
el diseñador del mismo decidirá qué instrucciones son válidas en ese
pseudocódigo y qué estilo de programación (lo que luego llamaremos
<em>paradigma</em>) seguirá el mismo.</p></li>
<li><p>Además, es importante es que no haya ninguna duda posible sobre
cómo interpretar las instrucciones del pseudocódigo.</p></li>
<li><p>Lo más apropiado sería usar un pseudocódigo que se parezca lo más
posible al lenguaje de programación con el que finalmente se escribirá
el programa, de forma que la tarea de traducir el algoritmo en su
correspondiente programa sea lo más fácil y directa posible.</p></li>
<li><p>Por ejemplo, el algoritmo anterior sería relativamente fácil de
traducir a <em>lenguaje ensamblador</em> o <em>lenguaje máquina</em>, ya
que las instrucciones que se usan en ese pseudocódigo (lecturas,
escrituras, saltos…) son fáciles de adaptar a esos lenguajes.</p></li>
<li><p>En cambio, sería bastante más complicado traducirlo a un lenguaje
funcional como Haskell, donde no existen esas instrucciones.</p></li>
</ul>
</section>


<section id="cualidades-deseables" class="title-slide slide level3"
data-number="1.4.4">
<h3 data-number="1.4.4"><span class="header-section-number">1.4.4</span>
Cualidades deseables</h3>
<ul>
<li><p><strong>Corrección</strong>: El algoritmo debe solucionar
correctamente el problema.</p></li>
<li><p><strong>Claridad</strong>: Debe ser legible y comprensible para
el ser humano.</p></li>
<li><p><strong>Generalidad</strong>: Un algoritmo debe resolver
problemas generales. Por ejemplo, un algoritmo que sume dos números
enteros debe servir para sumar cualquier pareja de números enteros, y
no, solamente, para sumar dos números determinados, como pueden ser el 3
y el 5.</p></li>
<li><p><strong>Eficiencia</strong>: Un algoritmo es mejor cuanto menos
recursos (tiempo, espacio…) necesita para resolver el problema. Por eso
no debe realizar pasos innecesarios ni recordar más información de la
necesaria.</p></li>
<li><p><strong>Sencillez</strong>: Hay que intentar que la solución sea
sencilla, aun a costa de perder un poco de eficiencia; es decir, se
tiene que buscar un equilibrio entre la claridad y la
eficiencia.</p></li>
<li><p><strong>Modularidad</strong>: Un algoritmo puede formar parte de
la solución a un problema mayor. A su vez, dicho algoritmo puede
descomponerse en otros si esto favorece a la claridad del
mismo.</p></li>
</ul>
</section>

<section id="computabilidad" class="title-slide slide level3"
data-number="1.4.5">
<h3 data-number="1.4.5"><span class="header-section-number">1.4.5</span>
Computabilidad</h3>
<ul>
<li><p>¿Todos los problemas pueden resolverse de forma
algorítmica?</p></li>
<li><p>Dicho de otra forma, queremos saber lo siguiente:</p>
<div class="caja centered">
<p>Dado un problema, ¿existe un algoritmo que lo resuelva?</p>
</div></li>
</ul>
</section>
<section class="slide level5" data-number="1.4.5.0.1">

<ul>
<li><p>Todo problema <span class="math inline">P</span> lleva asociada
una función <span class="math inline">f_P: D \rightarrow R</span>,
donde:</p>
<ul>
<li><p><span class="math inline">D</span> es el conjunto de los datos de
entrada.</p></li>
<li><p><span class="math inline">R</span> es el conjunto de los
resultados del problema.</p></li>
</ul></li>
<li><p>Asimismo, todo algoritmo <span class="math inline">A</span> lleva
asociada una función <span class="math inline">f_A</span>.</p></li>
<li><p>La pregunta es: ¿existe un algoritmo A tal que <span
class="math inline">f_A = f_P</span>?</p></li>
<li><p>Y de ahí vamos a la pregunta general:</p>
<div class="caja centered">
<p>¿Toda función <span class="math inline">f</span> es computable
(resoluble algorítmicamente)?</p>
</div></li>
</ul>
</section>
<section class="slide level5" data-number="1.4.5.0.2">

<p>La respuesta es que <strong>NO</strong>.</p>
<ul>
<li>Se puede demostrar que hay más funciones que algoritmos, por lo que
<strong>existen funciones que no se pueden computar mediante un
algoritmo</strong> (no son computables).</li>
</ul>
</section>
<section class="slide level5" data-number="1.4.5.0.3">

<ul>
<li><p>La dificultad que tiene estudiar la computabilidad de funciones
está en que no tenemos una definición formal de
«<em>algoritmo</em>».</p></li>
<li><p>A comienzos del S. XX, se crearon (independientemente uno del
otro) dos formalismos matemáticos para representar el concepto de
<em>algoritmo</em>:</p>
<ul>
<li><p>Alonzo Church creó el <strong>cálculo lambda</strong>.</p></li>
<li><p>Alan Turing creó la <strong>máquina de Turing</strong>.</p></li>
</ul></li>
<li><p>Posteriormente se demostró que los dos formalismos eran
totalmente equivalentes y eran, además, equivalentes a las
<strong>gramáticas formales</strong>.</p></li>
<li><p>Esto llevó a formular la llamada <strong>tesis de
Church-Turing</strong>, que dice que</p>
<div class="caja centered">
<p>«<em>Todo algoritmo es equivalente a una máquina de Turing.</em>»</p>
</div></li>
<li><p>La tesis de Church-Turing es indemostrable pero prácticamente
toda la comunidad científica la acepta como verdadera.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.4.5.0.4">

<ul>
<li><p>Usando esos formalismos, se pudo demostrar que hay problemas que
no se pueden resolver mediante algoritmos.</p></li>
<li><p>Uno de los problemas que no tienen una solución algorítmica es el
llamado <strong>problema de la parada</strong>:</p>
<div class="caja">
<p><strong>Problema de la parada</strong>:</p>
<p>Dado un algoritmo y un posible dato de entrada, determinar (a priori,
sin ejecutarlo previamente) si el algoritmo se detendrá y producirá un
valor de salida.</p>
</div></li>
<li><p>Nunca podremos hacer un algoritmo que resuelva el problema de la
parada en términos generales (en casos particulares sí se
puede).</p></li>
</ul>
</section>

<section id="corrección" class="title-slide slide level3"
data-number="1.4.6">
<h3 data-number="1.4.6"><span class="header-section-number">1.4.6</span>
Corrección</h3>
<ul>
<li><p>¿Cómo sabemos si un algoritmo es
<strong>correcto</strong>?</p></li>
<li><p>¿Qué significa eso de que un algoritmo sea correcto?</p></li>
<li><p>Supongamos que, para un problema <span
class="math inline">P</span>, existe un algoritmo <span
class="math inline">A</span>. Lo que tenemos que averiguar es si se
cumple: <span class="math display">f_P = f_A</span></p></li>
<li><p>¿Cómo lo hacemos?</p>
<ul>
<li><p>Si el conjunto <span class="math inline">D</span> de datos de
entrada es <strong>finito</strong>, podríamos comparar todos los
resultados de salida con los resultados esperados y ver si coinciden
(<strong>pruebas exhaustivas</strong>). Normalmente es
imposible.</p></li>
<li><p>Si <span class="math inline">D</span> es
<strong>infinito</strong>, es imposible realizar una comprobación
empírica de la corrección del algoritmo (se pueden realizar
<strong>pruebas no exhaustivas</strong> que comprueban algunos datos de
entrada pero no todos, por lo que no demuestran que el algoritmo es
correcto pero sí pueden demostrar que es incorrecto).</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="1.4.6.0.1">

<ul>
<li><p>Lo mejor (pero más difícil) es recurrir a <strong>métodos
formales</strong>:</p>
<ul>
<li><p><strong>Diseño a priori</strong>: se construye el algoritmo en
base a una demostración (lo que se denomina también <strong>demostración
constructiva</strong>).</p></li>
<li><p><strong>Diseño a posteriori</strong>: se construye el algoritmo
de forma más o menos intuitiva y, una vez diseñado, tratar de demostrar
su corrección.</p></li>
</ul></li>
<li><p>En ambos casos, es importante definir con mucha precisión qué
problema queremos resolver.</p></li>
<li><p>Para ello, se describe el problema mediante una
<strong>especificación formal</strong>.</p></li>
</ul>
</section>

<section id="complejidad" class="title-slide slide level3"
data-number="1.4.7">
<h3 data-number="1.4.7"><span class="header-section-number">1.4.7</span>
Complejidad</h3>
<ul>
<li><p>¿Cómo de <strong>eficiente</strong> es un algoritmo?</p></li>
<li><p>La eficiencia de un algoritmo se mide en función del
<strong>consumo de recursos</strong> que necesita el algoritmo para su
ejecución.</p>
<ul>
<li>Los principales recursos son el <strong>tiempo</strong> y el
<strong>espacio</strong>.</li>
</ul></li>
<li><p>Dados dos algoritmos distintos que resuelvan el mismo problema,
en general nos interesará usar el más eficiente de ellos (al margen de
otras consideraciones, como la claridad, la legibilidad, la
mantenibilidad, la reusabilidad, etc.)</p></li>
<li><p>¿Cómo medimos la eficiencia de un algoritmo?</p></li>
<li><p>¿Cómo comparamos la eficiencia de dos algoritmos?</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.4.7.0.1">

<ul>
<li><p>El <strong>análisis de algoritmos</strong> estudia la eficiencia
de un algoritmo desde un punto de vista abstracto (independiente de la
máquina, el lenguaje de programación, la carga de trabajo,
etc.).</p></li>
<li><p>Define el consumo de recursos <strong>en función del tamaño del
ejemplar del problema a resolver</strong>.</p></li>
<li><p>Por ejemplo:</p>
<ul>
<li><p>Supongamos el problema de comprobar cuántas vocales hay en una
frase.</p></li>
<li><p>La <strong>entrada</strong> al algoritmo será la frase (una
cadena de caracteres).</p></li>
<li><p>La <strong>salida</strong> será el número de vocales que hay en
la cadena.</p></li>
<li><p>Cada una de las posibles cadenas de entrada representan un
<strong>ejemplar</strong> del problema a resolver.</p></li>
<li><p>Cabe esperar que el algoritmo tarde más en dar el resultado
cuanto más larga sea la cadena de entrada.</p></li>
<li><p>Por tanto, el <strong>tamaño del ejemplar</strong> será la
longitud de la cadena.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="1.4.7.0.2">

<ul>
<li><p>Si tenemos dos algoritmos <span class="math inline">A</span> y
<span class="math inline">B</span> (que resuelven el mismo problema
anterior) con tiempos de ejecución <span class="math display">t_A(n)
\simeq 3n^2</span> y <span class="math display">t_B(n) \simeq
4n</span> siendo <span class="math inline">n</span> la longitud de la
cadena de entrada, el algoritmo <span class="math inline">B</span> se
considera más eficiente que <span class="math inline">A</span> ya que su
tiempo de ejecución es menor a medida que aumenta <span
class="math inline">n</span>.</p></li>
<li><p>Esto es así aunque hay algún caso (como el de <span
class="math inline">n = 1</span>) donde el algoritmo <span
class="math inline">A</span> es más eficiente que <span
class="math inline">B</span>, ya que la constante multiplicativa 3 que
aparece en <span class="math inline">t_A(n)</span> es más pequeña que la
constante 4 que aparece en <span
class="math inline">t_B(n)</span>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.4.7.0.3">

<div class="centered">
<figure>
<img data-src="images/grafica-funciones.svg" class="plain"
style="width:60.0%" alt="Representación gráfica de 3n^2 y 4n" />
<figcaption aria-hidden="true">Representación gráfica de <span
class="math inline">3n^2</span> y <span
class="math inline">4n</span></figcaption>
</figure>
</div>
</section>
<section class="slide level5" data-number="1.4.7.0.4">

<ul>
<li><p>En general, no estamos interesados en las constantes concretas
que puedan aparecer en las <span class="math inline">t(n)</span>, ni en
el valor que éstas puedan tomar para un <span
class="math inline">n</span> concreto, sino que tan sólo nos interesa la
<strong>forma</strong> que puedan tener las funciones <span
class="math inline">t(n)</span> y cómo crecen a medida que aumenta <span
class="math inline">n</span>.</p></li>
<li><p>Por eso, clasificamos el consumo de recursos usando una
<strong>notación asintótica</strong>, con la cual podemos ordenar las
funciones <span class="math inline">t(n)</span> según determinados
<em>órdenes de crecimiento</em> cuando <span
class="math inline">n</span> crece hasta el infinito.</p></li>
<li><p>En el ejemplo anterior, tenemos <span class="math display">t_A(n)
\in O(n^2)</span> que se lee «<span class="math inline">t_A(n)</span> es
del orden de <span class="math inline">n^2</span>», y <span
class="math display">t_B(n) \in O(n)</span> que se lee «<span
class="math inline">t_B(n)</span> es del orden de <span
class="math inline">n</span>». Podemos decir también que <span
class="math inline">A</span> tiene <strong>tiempo cuadrático</strong> y
<span class="math inline">B</span> <strong>tiempo
lineal</strong>.</p></li>
<li><p>Como <span class="math inline">O(n) \subset O(n^2)</span> (porque
<span class="math inline">n^2</span> crece más deprisa que <span
class="math inline">n</span>), podemos concluir que <span
class="math inline">t_B(n) &lt; t_A(n)</span> para un valor de <span
class="math inline">n</span> suficientemente grande (o sea,
<em>asintóticamente</em>). Por tanto, <span class="math inline">B</span>
es un algoritmo más eficiente que <span
class="math inline">A</span>.</p></li>
</ul>
</section>


<section id="programa" class="title-slide slide level2"
data-number="1.5">
<h2 data-number="1.5"><span class="header-section-number">1.5</span>
Programa</h2>
<ul>
<li><p>Definición:</p>
<div class="caja">
<p><strong>Programa</strong>:</p>
<p>Un programa es la codificación de un algoritmo en un lenguaje de
programación.</p>
</div></li>
<li><p>Si el algoritmo está bien definido, <em>traducir</em> ese
algoritmo en un programa equivalente puede resultar trivial.</p></li>
<li><p>El texto del programa escrito en ese lenguaje de programación se
denomina <strong>código fuente</strong>. Programar, al final, consiste
en escribir (<em>codificar</em>) el código fuente de nuestro
programa.</p></li>
<li><p>Los algoritmos están pensados para ser entendidos por un ser
humano, mientras que los programas se escriben para ser interpretados y
ejecutados por un ordenador.</p></li>
<li><p>Por ello, toda posible ambigüedad que pudiera quedar en el
algoritmo debe eliminarse al codificarlo en forma de programa.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.5.0.0.1">

<ul>
<li><p>Programar depende mucho de las características del lenguaje de
programación elegido.</p></li>
<li><p>Lo ideal es usar un lenguaje que se parezca lo más posible al
<em>pseudolenguaje</em> utilizado para describir el correspondiente
algoritmo.</p></li>
<li><p>En un programa también hay que considerar <strong>aspectos y
limitaciones</strong> que no se suelen tener en cuenta en un
algoritmo:</p>
<ul>
<li><p><strong>El tamaño de los datos en memoria:</strong> por ejemplo,
en un lenguaje de programación suele haber límites en cuanto a la
cantidad de dígitos que puede tener un número o su precisión
decimal.</p></li>
<li><p><strong>Restricciones en los datos:</strong> dependiendo del tipo
de los datos, pueden ser mutables o inmutables, de tamaño fijo o
variable, etc.</p></li>
<li><p><strong>La semántica de las instrucciones:</strong> un símbolo
usado en un algoritmo puede tener otro significado distinto en el
programa, o puede que sólo pueda usarse en el programa bajo ciertas
condiciones que no hace falta considerar en el algoritmo.</p></li>
</ul></li>
</ul>
</section>
</section>
<section>
<section id="paradigmas-de-programación"
class="title-slide slide level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span>
Paradigmas de programación</h1>

</section>
<section id="definición-2" class="title-slide slide level2"
data-number="2.1">
<h2 data-number="2.1"><span class="header-section-number">2.1</span>
Definición</h2>
<div class="caja">
<p><strong>Paradigma de programación</strong>:</p>
<p>Es un <strong><em>estilo</em></strong> de desarrollar programas, es
decir, un <strong>modelo</strong> para resolver problemas
computacionales.</p>
</div>
</section>
<section class="slide level5" data-number="2.1.0.0.1">

<ul>
<li><p>Cada paradigma entiende la programación desde una perspectiva
diferente, partiendo de unos conceptos básicos diferentes y con unas
reglas diferentes.</p></li>
<li><p>Cuando diseñamos un algoritmo o escribimos un programa, lo
hacemos siguiendo un determinado paradigma, y éste impregna por completo
la forma en la que describimos la solución al problema en el que estamos
trabajando.</p></li>
<li><p>No existe un único paradigma de programación y cada uno tiene sus
peculiaridades que lo hacen diferente.</p></li>
<li><p>Un <strong>lenguaje de programación (o pseudocódigo)</strong> se
dice que <strong><em>soporta</em> un determinado paradigma</strong>
cuando con dicho lenguaje se pueden escribir algoritmos o programas
según el «estilo» que impone dicho paradigma.</p></li>
<li><p>Incluso existen <strong>lenguajes
<em>multiparadigma</em></strong> capaces de soportar varios paradigmas
al mismo tiempo.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.1.0.0.2">

<ul>
<li>Los paradigmas de programación más importantes son:</li>
</ul>
<p><br></p>
<p><span class="math display">\text{Paradigmas} \begin{cases}
\text{Imperativo} \begin{cases}
                    \text{Estructurado} \\
                    \text{Orientado a objetos}
                  \end{cases} \\
\\
\text{Declarativo} \begin{cases}
                     \text{Funcional} \\
                     \text{Lógico} \\
                     \text{De bases de datos}
                   \end{cases}
\end{cases}</span></p>
</section>
<section class="slide level5" data-number="2.1.0.0.3">

<div class="centered">
<figure>
<img data-src="images/paradigmas.png" style="width:100.0%"
alt="Principales paradigmas © 2008 Peter Van Roy" />
<figcaption aria-hidden="true">Principales paradigmas © 2008 Peter Van
Roy</figcaption>
</figure>
</div>
</section>

<section id="imperativo" class="title-slide slide level2"
data-number="2.2">
<h2 data-number="2.2"><span class="header-section-number">2.2</span>
Imperativo</h2>
<ul>
<li><p>El <strong>paradigma imperativo</strong> está basado en el
concepto de <strong>sentencia</strong>. Un programa imperativo está
formado por una sucesión de sentencias que se ejecutan en orden y que
llevan a cabo una de estas acciones:</p>
<ul>
<li><p><strong>Cambiar el estado</strong> interno del programa,
usualmente mediante la sentencia de <em>asignación</em>.</p></li>
<li><p>Cambiar el <strong>flujo de control</strong> del programa,
haciendo que la ejecución se bifurque (<em>salte</em>) a otra parte del
mismo.</p></li>
</ul></li>
<li><p>La ejecución de un programa imperativo, por tanto, consiste en
una sucesión de cambios de estado controlados por mecanismos de control
y que dependen del orden en el que se realizan.</p></li>
<li><p>Existen varios paradigmas con las características del paradigma
imperativo, por lo que podemos decir que <strong>existen varios
paradigmas imperativos</strong>.</p></li>
</ul>
</section>
<section id="estructurado" class="title-slide slide level3"
data-number="2.2.1">
<h3 data-number="2.2.1"><span class="header-section-number">2.2.1</span>
Estructurado</h3>
<ul>
<li><p>El <strong>paradigma estructurado</strong> es un paradigma
imperativo en el que el flujo de control del programa se define mediante
las denominadas <strong>estructuras de control</strong>.</p></li>
<li><p>Se apoya a nivel teórico en los resultados del conocido
<strong>teorema de Böhm y Jacopini</strong>, que establece que cualquier
programa útil se puede escribir usando solamente tres estructuras
básicas:</p>
<ul>
<li>Secuencia</li>
<li>Selección</li>
<li>Iteración</li>
</ul></li>
<li><p>Con estas tres estructuras conseguimos que los programas se
puedan leer de arriba abajo como compuestos por <strong>bloques anidados
o independientes</strong> que se leen como un todo conjunto.</p></li>
<li><p>Su aparición llevó asociada la aparición de una
<strong>metodología de desarrollo</strong> según la cual los programas
se escriben por niveles de abstracción mediante refinamientos sucesivos
y usando en cada nivel sólo las tres estructuras básicas.</p></li>
</ul>
</section>

<section id="orientado-a-objetos" class="title-slide slide level3"
data-number="2.2.2">
<h3 data-number="2.2.2"><span class="header-section-number">2.2.2</span>
Orientado a objetos</h3>
<ul>
<li><p>El <strong>paradigma orientado a objetos</strong> se apoya en los
conceptos de <strong>objeto</strong> y
<strong>mensaje</strong>.</p></li>
<li><p>Un programa orientado a objetos está formado por una colección de
objetos que se intercambian mensajes entre sí.</p></li>
<li><p>Los objetos son entidades que existen dentro del programa y que
poseen un cierto <strong>estado interno</strong>.</p></li>
<li><p>Cuando un objeto envía un mensaje a otro, el objeto que recibe el
mensaje reaccionará llevando a cabo alguna acción, que probablemente
provocará un <strong>cambio en su estado interno</strong> y que,
posiblemente, provocará también el envío de mensajes a otros
objetos.</p></li>
<li><p>La programación orientada a objetos está vista como una forma
natural de entender la programación y es, con diferencia, <strong>el
paradigma más usado en la actualidad</strong>.</p></li>
</ul>
</section>


<section id="declarativo" class="title-slide slide level2"
data-number="2.3">
<h2 data-number="2.3"><span class="header-section-number">2.3</span>
Declarativo</h2>
<ul>
<li><p>La <strong>programación declarativa</strong> engloba a una
familia de paradigmas de programación de muy alto nivel.</p></li>
<li><p>En programación declarativa se describe la solución a un problema
definiendo las <strong>propiedades</strong> que debe cumplir dicha
solución en lugar de definir las <strong>instrucciones</strong> que se
deben ejecutar para resolver el problema.</p></li>
<li><p>Se dice que un programa imperativo describe <strong>cómo</strong>
resolver el problema, mientras que un programa declarativo describe
<strong>qué</strong> forma debe tener la solución al problema.</p></li>
<li><p>Para dar forma a la solución, se utilizan formalismos abstractos
matemáticos y lógicos, lo que da lugar a los dos grandes paradigmas
declarativos: la <strong>programación funcional</strong> y <strong>la
programación lógica</strong>.</p></li>
</ul>
</section>
<section id="funcional" class="title-slide slide level3"
data-number="2.3.1">
<h3 data-number="2.3.1"><span class="header-section-number">2.3.1</span>
Funcional</h3>
<ul>
<li><p>La <strong>programación funcional</strong> es un paradigma de
programación declarativa basado en el uso de
<strong>definiciones</strong>, <strong>expresiones</strong> y
<strong>funciones matemáticas</strong>.</p></li>
<li><p>Tiene su origen teórico en el <strong>cálculo lambda</strong>, un
sistema matemático creado en 1930 por Alonzo Church.</p></li>
<li><p>Los lenguajes funcionales se pueden considerar <em>azúcar
sintáctico</em> (es decir, una forma equivalente pero sintácticamente
más sencilla) del cálculo lambda.</p></li>
<li><p>En programación funcional, una función define un cálculo a
realizar a partir de unos datos de entrada, con la propiedad de que el
resultado de la función sólo puede depender de esos datos de
entrada.</p></li>
<li><p>Eso significa que una función no puede tener estado interno ni su
resultado puede depender del estado del programa.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.3.1.0.1">

<ul>
<li><p>Además, una función no puede producir ningún efecto observable
fuera de ella (los llamados <strong>efectos laterales</strong>), salvo
calcular y devolver su resultado.</p></li>
<li><p>Esto quiere decir que en programación funcional no existen los
efectos laterales, o se dan de forma muy localizada en partes muy
concretas e imprescindibles del programa.</p></li>
<li><p>Por todo lo expuesto anteriormente, se dice que las funciones en
programación funcional son <strong>funciones puras</strong>.</p></li>
<li><p>En consecuencia, es posible sustituir cualquier expresión por su
valor, propiedad que se denomina <strong>transparencia
referencial</strong>.</p></li>
<li><p>La programación funcional es un paradigma cada vez más utilizado,
y hasta los lenguajes que no son funcionales están incorporando
características propias de este paradigma.</p></li>
<li><p>Esto se debe a que demostrar la corrección de un programa
funcional o paralelizar su ejecución es <strong>mucho más fácil</strong>
que con un programa imperativo.</p></li>
</ul>
</section>

<section id="lógico" class="title-slide slide level3"
data-number="2.3.2">
<h3 data-number="2.3.2"><span class="header-section-number">2.3.2</span>
Lógico</h3>
<ul>
<li><p>La <strong>programación lógica</strong> es un paradigma de
programación declarativa que usa la <strong>lógica matemática</strong>
como lenguaje de programación.</p></li>
<li><p>Básicamente, un programa lógico es una colección de definiciones
que forman un conjunto de <strong>axiomas</strong> en un sistema de
<strong>deducción lógica</strong>.</p></li>
<li><p>Ejecutar un programa lógico equivale a poner en marcha un
mecanismo deductivo que trata de <strong>demostrar un teorema</strong> a
partir de los axiomas.</p></li>
<li><p>Se usa principalmente en <strong>inteligencia
artificial</strong>, en <strong>demostración automática</strong> y en
<strong>procesamiento del lenguaje natural</strong>.</p></li>
<li><p>El más conocido de los lenguajes de programación lógica es
<strong>Prolog</strong>.</p></li>
</ul>
</section>

<section id="de-bases-de-datos" class="title-slide slide level3"
data-number="2.3.3">
<h3 data-number="2.3.3"><span class="header-section-number">2.3.3</span>
De bases de datos</h3>
<ul>
<li><p>Los sistemas de gestión de bases de datos relacionales (SGBDR)
disponen de un lenguaje que permite al usuario consultar y manipular la
información almacenada.</p></li>
<li><p>A esos lenguajes se los denomina <strong>lenguajes de bases de
datos</strong> o <strong>lenguajes de consulta</strong>.</p></li>
<li><p>El lenguaje de consulta más conocido es el
<strong>SQL</strong>.</p></li>
<li><p>Los SGBDR se basan en el <em>modelo relacional</em>, que es un
modelo matemático.</p></li>
<li><p>SQL es, básicamente, una implementación del <strong>álgebra
relacional</strong>.</p></li>
<li><p>Los lenguajes de consulta se consideran lenguajes declarativos
porque con ellos el usuario indica <em>qué</em> desea obtener (qué
propiedades debe cumplir la solución) y el SGBDR determina
automáticamente el mejor camino para alcanzar dicho objetivo.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.3.3.0.1">

<script data-quiz>
quiz = {"info":{"name":"","main":""},"questions":[{"q":"El paradigma funcional es un paradigma...","a":[{"option":"Imperativo","correct":false},{"option":"Declarativo","correct":true}],"correct":"<p><span>\u00a1Eso es!</span>El paradigma funcional es un paradigma declarativo de gran auge hoy en d\u00eda.</p>","incorrect":"<p><span>Mmmm... no.</span>El paradigma funcional <em>NO</em> es un paradigma imperativo.</p>"},{"q":"Entre los paradigmas imperativos tenemos...","a":[{"option":"El paradigma de bases de datos","correct":false},{"option":"El paradigma l\u00f3gico","correct":false},{"option":"El paradigma orientado a objetos","correct":true}],"correct":"<p><span>\u00a1Eso es!</span>El paradigma orientado a objetos es un paradigma imperativo porque los objetos cambian su estado al enviarse mensajes entre ellos.</p>","incorrect":"<p><span>Mmmm... no.</span>No es correcto.</p>"}]}</script>
</section>
<section id="ejercicios-1" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejercicios</h5>
<ol start="5" class="example" type="1">
<li><p>¿Qué paradigmas de programación soportan los lenguajes Python y
Java?</p></li>
<li><p>¿Hay más paradigmas de programación? Busca en Internet un par de
ejemplos de paradigmas que no se hayan nombrado aquí. Para cada uno,
describe en una sola frase sus características básicas.</p></li>
</ol>
</section>

</section>
<section>
<section id="resolución-de-problemas-mediante-programación"
class="title-slide slide level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span>
Resolución de problemas mediante programación</h1>

</section>
<section id="introducción" class="title-slide slide level2"
data-number="3.1">
<h2 data-number="3.1"><span class="header-section-number">3.1</span>
Introducción</h2>
<ul>
<li><p>El proceso de resolución de un problema con un ordenador pasa por
escribir y ejecutar un programa.</p></li>
<li><p>Aunque diseñar programas es, esencialmente, un proceso creativo,
se puede considerar una serie de fases o pasos comunes, que generalmente
deben seguir todos los programadores.</p></li>
<li><p>Si bien se han ordenado según un esquema lógico, hay que
considerar que algunos de esos pasos se repiten a lo largo del
desarrollo del programa siguiendo un esquema iterativo e incremental, y
otros (como la documentación) se deben realizar continuamente a lo largo
de todo el proceso y no sólo al final como un paso más del
mismo.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.1.0.0.1">

<ul>
<li><p>Los pasos para la resolución de un problema mediante programación
son los siguientes:</p>
<ol>
<li><p>Especificación.</p></li>
<li><p>Análisis del problema.</p></li>
<li><p>Diseño del algoritmo.</p></li>
<li><p>Verificación.</p></li>
<li><p>Estudio de la eficiencia.</p></li>
<li><p>Codificación.</p></li>
<li><p>Traducción y ejecución.</p></li>
<li><p>Pruebas.</p></li>
<li><p>Depuración.</p></li>
<li><p>Documentación.</p></li>
<li><p>Mantenimiento.</p></li>
</ol></li>
</ul>
</section>

<section id="especificación" class="title-slide slide level2"
data-number="3.2">
<h2 data-number="3.2"><span class="header-section-number">3.2</span>
Especificación</h2>
<ul>
<li><p>La <strong>especificación de un <em>problema</em></strong>
describe <strong>qué</strong> problema hay que resolver sin entrar a
detallar <strong>cómo</strong> hay que resolverlo.</p></li>
<li><p>La <strong>especificación de un <em>programa</em></strong>
describe <strong>qué</strong> tiene que hacer el programa para resolver
un problema sin detallar aún <strong>cómo</strong> va a
resolverlo.</p></li>
<li><p>En esta fase, se ve al programa como una <strong>caja
negra</strong> de la que se sabe <em>qué</em> debe hacer pero aún no
sabemos <em>cómo</em> va a hacerlo.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.0.0.1">

<ul>
<li><p>La especificación define con precisión (cuanto más formal
mejor):</p>
<ul>
<li><p>Cuál es la <strong>entrada requerida</strong>:</p>
<ul>
<li><p>Qué datos de entrada se necesitan y qué propiedades deben
cumplir.</p></li>
<li><p>Con esto se determina el <strong>dominio de definición</strong>
del problema, es decir, el conjunto de sus ejemplares.</p></li>
</ul></li>
<li><p>Cuál es la <strong>salida deseada</strong>:</p>
<ul>
<li><p>Básicamente, es el resultado que se desea obtener como solución
al problema.</p></li>
<li><p>Normalmente se describe en función de los datos de
entrada.</p></li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="ejemplo-2" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejemplo</h5>
<ul>
<li><p>Se desea determinar el máximo de dos números enteros.</p>
<ul>
<li><p><em>Entrada</em>: los dos números enteros (llamémosles <span
class="math inline">n_1</span> y <span
class="math inline">n_2</span>).</p></li>
<li><p><em>Salida</em>: el mayor de los dos números.</p></li>
</ul></li>
<li><p>Se representaría esquemáticamente así:</p>
<p><span class="math display">\begin{cases}
  \text{\textbf{Entrada}}: n_1, n_2 \in \mathbb{Z} \\
  \text{\textit{Máximo}} \\
  \text{\textbf{Salida}}: \text{el mayor de ambos}
\end{cases}</span></p></li>
<li><p>En las especificaciones está permitido usar operaciones
(funciones, por ejemplo) siempre y cuando estén perfectamente
especificadas, aunque no estén implementadas en el lenguaje de
programación.</p></li>
<li><p>A esas operaciones se las denomina <strong>operaciones
auxiliares</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.0.0.2">

<ul>
<li><p>Por ejemplo, si disponemos de la función auxiliar <span
class="math inline">max</span> que devuelve el máximo de dos números,
nuestra especificación podría quedar así:</p>
<p><span class="math display">\begin{cases}
  \text{\textbf{Entrada}}: n_1, n_2 \in \mathbb{Z} \\
  \text{\textit{Máximo}} \\
  \text{\textbf{Salida}}: max(n_1, n_2)
\end{cases}</span></p></li>
<li><p>Con esta especificación estamos describiendo que, si se reciben
como datos de entrada dos números enteros cualesquiera, el programa
<em>Máximo</em> calculará y devolverá a la salida el mayor de
ellos.</p></li>
<li><p>Si los datos de entrada no satisfacen los requisitos necesarios,
el programa tiene derecho a responder de cualquier manera, o a no
responder en absoluto.</p></li>
</ul>
</section>

<section id="análisis-del-problema" class="title-slide slide level2"
data-number="3.3">
<h2 data-number="3.3"><span class="header-section-number">3.3</span>
Análisis del problema</h2>
<ul>
<li><p>A partir de la especificación, se estudia detalladamente el
problema a resolver, los requisitos que se deben cumplir y las posibles
restricciones que pueda tener la solución.</p></li>
<li><p>En el ejemplo anterior:</p>
<ul>
<li>Hay que comparar el valor de los dos números y devolver el mayor de
ellos.</li>
<li>Si los dos números son iguales, se puede devolver cualquiera de los
dos.</li>
</ul></li>
</ul>
</section>

<section id="diseño-del-algoritmo" class="title-slide slide level2"
data-number="3.4">
<h2 data-number="3.4"><span class="header-section-number">3.4</span>
Diseño del algoritmo</h2>
<ul>
<li><p>Una vez analizado el problema con detalle, se diseña un algoritmo
que lo resuelva, cumpliendo con todas las posibles restricciones y
satisfaciendo la especificación del problema.</p></li>
<li><p>El algoritmo se representa con cualquier herramienta adecuada
para ello (ordinogramas, pseudocódigo, etc.) la cual depende del
paradigma utilizado.</p></li>
<li><p>El paradigma usado para describir el algoritmo debería ir acorde
con el paradigma del lenguaje de programación que se usará luego para
codificar el algoritmo en forma de programa.</p>
<p>Por ejemplo, se podría usar un ordinograma para representar un
algoritmo imperativo pero no es apropiado para uno funcional.</p></li>
<li><p>Igualmente, hay distintos pseudocódigos y cada uno sigue un
determinado paradigma y posee un determinado juego de instrucciones
válidas, por lo que ciertos pseudocódigos serán más apropiados que otros
para ser traducidos luego a un determinado lenguaje de
programación.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.4.0.0.1">

<ul>
<li><p>Por ejemplo, un algoritmo descrito en pseudocódigo siguiendo un
estilo estructurado podría ser:</p>
<div class="line-block"><strong>Algoritmo:</strong> Cálculo del máximo
de dos números<br />
<strong>Entrada:</strong> <span class="math inline">n_1, n_2 \in
\mathbb{Z}</span><br />
<strong>Salida:</strong> el mayor de ambos<br />
<br />
<strong>inicio</strong><br />
    <strong>si</strong> <span class="math inline">n_1 &gt; n_2</span>
<strong>entonces</strong><br />
        <strong>devolver</strong> <span
class="math inline">n_1</span><br />
    <strong>sino</strong><br />
        <strong>devolver</strong> <span
class="math inline">n_2</span><br />
<strong>fin</strong></div></li>
<li><p>Por tanto, este algoritmo, así representado, sería muy apropiado
para traducirlo luego a un programa escrito en un lenguaje estructurado
(como Python o Java), pero no tanto para traducirlo a un lenguaje
funcional como Haskell.</p></li>
</ul>
</section>

<section id="verificación" class="title-slide slide level2"
data-number="3.5">
<h2 data-number="3.5"><span class="header-section-number">3.5</span>
Verificación</h2>
<ul>
<li><p>Es el proceso por el cual se intenta <strong>demostrar</strong>
que el algoritmo diseñado es <strong>correcto</strong>.</p></li>
<li><p>Un algoritmo es correcto cuando <strong>satisface su
especificación</strong>.</p></li>
<li><p>Es un proceso basado en las matemáticas y la lógica, y consiste
en considerar que el algoritmo es un <strong>teorema</strong> a
demostrar en un sistema deductivo lógico en el que hay <em>axiomas</em>
y <em>reglas de inferencia</em>.</p></li>
<li><p>Puede resultar muy difícil incluso en casos sencillos.</p></li>
<li><p>En la práctica, su uso se reduce a bloques pequeños y críticos
del programa.</p></li>
</ul>
</section>

<section id="estudio-de-la-eficiencia" class="title-slide slide level2"
data-number="3.6">
<h2 data-number="3.6"><span class="header-section-number">3.6</span>
Estudio de la eficiencia</h2>
<ul>
<li><p>Cuando disponemos de un algoritmo correcto que resuelve el
problema, podemos optar por estudiar la eficiencia del mismo (es decir,
la cantidad de recursos que consume).</p></li>
<li><p>Si el algoritmo es correcto pero ineficiente, no suele resultar
práctico, y se debe optar por diseñar otro algoritmo más
eficiente.</p></li>
<li><p>Los algoritmos ineficientes sólo resultan útiles cuando el tamaño
del problema es relativamente pequeño.</p></li>
<li><p>Hay que tener en cuenta que existen problemas para los que no se
conoce ningún algoritmo eficiente.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.6.0.0.1">

<ul>
<li><p>También puede resultar muy interesante estudiar la eficiencia
cuando tenemos varios algoritmos que resuelven el mismo problema y
queremos determinar cuál de ellos es <em>mejor</em>.</p></li>
<li><p>En ese sentido, la eficiencia sería un criterio (entre otros) a
la hora de comparar algoritmos para determinar si un algoritmo es mejor
que otro.</p></li>
<li><p>Otros criterios importantes son la claridad, la elegancia o la
reusabilidad.</p></li>
<li><p>Es importante recordar que hay una regla no escrita que dice que
un algoritmo más eficiente suele ser menos claro o elegante, y
viceversa.</p></li>
</ul>
</section>

<section id="codificación" class="title-slide slide level2"
data-number="3.7">
<h2 data-number="3.7"><span class="header-section-number">3.7</span>
Codificación</h2>
<ul>
<li><p>Una vez diseñado y verificado, <strong>el algoritmo se codifica
en un lenguaje de programación</strong> usando un editor de textos o un
IDE (<em>Entorno Integrado de Desarrollo</em>).</p></li>
<li><p>Se considera una tarea casi mecanizable, pero aún hay decisiones
que pueden influir a la hora de codificar un programa y que sólo puede
tomar un programador experimentado.</p></li>
<li><p>El lenguaje de programación utilizado es una decisión de diseño
que hay que justificar.</p></li>
<li><p>En teoría, el diseño del algoritmo debería ser independiente del
lenguaje de programación en el que se vaya a codificar posteriormente el
programa, pero el <em>estilo</em> (paradigma) utilizado influye
mucho.</p></li>
<li><p>Por tanto, en la práctica se procura que el algoritmo esté
escrito en el mismo paradigma que sigue el lenguaje de programación que
se va a usar para codificar el programa.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.7.0.0.1">

<ul>
<li><p>Por otra parte, el lenguaje de programación o la arquitectura
hardware donde se va a ejecutar el programa pueden incorporar
<strong>restricciones o condiciones</strong> que hasta ahora no se
habían tenido en cuenta al diseñar el algoritmo.</p></li>
<li><p>Por ejemplo, es muy común que los lenguajes de programación
impongan un tamaño máximo de almacenamiento de los datos que
maneja.</p></li>
<li><p>En el caso del problema de sumar dos números enteros, eso
significa que el programa podría no admitir números demasiado grandes,
lo que habría que tenerlo en cuenta a la hora de escribir el
programa.</p></li>
<li><p>Ese detalle no lo consideramos al diseñar el algoritmo, ya que
<strong>los algoritmos son <em>ideales</em> y se representan con
herramientas <em>ideales</em></strong> (los pseudocódigos).</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.7.0.0.2">

<ul>
<li><p>Un programador experimentado podría saltarse el paso de
representar el algoritmo usando pseudocódigo y podría pasar directamente
a escribir el correspondiente programa en un lenguaje de
programación.</p></li>
<li><p>En el pasado, los lenguajes de programación eran poco expresivos
y poco ricos en tipos de instrucciones y estructuras de datos, lo que
hacía que traducir un algoritmo escrito en pseudocódigo a un programa
resultara una trabajo más costoso y menos directo.</p></li>
<li><p>Asimismo, el programa resultante era mucho menos claro y difícil
de entender que su algoritmo equivalente escrito en
pseudocódigo.</p></li>
<li><p>Hoy día existen lenguajes de programación de alto nivel muy
expresivos y con una sintaxis muy clara y legible que funcionan casi
como «pseudocódigos directamente interpretables por el
ordenador».</p></li>
<li><p>Python, por ejemplo, se considera un ejemplo de este tipo de
lenguajes.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.7.0.0.3">

<ul>
<li><p>Codificación del algoritmo anterior en lenguaje Python:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> maximo(n1, n2):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;&quot;&quot;Calcula el máximo de dos números enteros.&quot;&quot;&quot;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n1 <span class="op">&gt;</span> n2:</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> n1</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> n2</span></code></pre></div>
<p><br></p></li>
<li><p>Codificación en lenguaje Java:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * Calcula el máximo de dos números enteros.</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">maximo</span><span class="op">(</span><span class="dt">int</span> n1<span class="op">,</span> <span class="dt">int</span> n2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n1 <span class="op">&gt;</span> n2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> n1<span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> n2<span class="op">;</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="3.7.0.0.4">

<ul>
<li><p>Codificación en lenguaje Haskell:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Calcula el máximo de dos números enteros.</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="fu">max</span><span class="ot"> ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="fu">max</span> a b</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> a <span class="op">&gt;</span> b     <span class="ot">=</span> a</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> b</span></code></pre></div>
<p><br></p></li>
<li><p>Codificación en lenguaje Scheme:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">; Calcula el máximo de dos números enteros.</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(maximo n1 n2)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">cond</span> ((<span class="op">&gt;</span> n1 n2) n1)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">else</span> n2)))</span></code></pre></div></li>
</ul>
</section>
<section id="implementación" class="title-slide slide level3"
data-number="3.7.1">
<h3 data-number="3.7.1"><span class="header-section-number">3.7.1</span>
Implementación</h3>
<ul>
<li><p>El concepto de <strong>implementación</strong> es muy importante
en Programación.</p></li>
<li><p>Está muy relacionado con los conceptos de
<em>especificación</em>, <em>diseño</em> y
<em>codificación</em>.</p></li>
<li><p>En esencia:</p>
<ul>
<li><p>La <em>especificación</em> describe <em>qué</em> hay que
hacer.</p></li>
<li><p>La <em>implementación</em>, en cambio, describe <em>cómo</em> hay
que hacerlo.</p></li>
</ul></li>
<li><p>Cuando lo que se está especificando es un <em>programa</em> (es
decir, cuando la especificación describe lo que tiene que hacer un
programa), la <em>implementación</em> es el <em>algoritmo</em> o
<em>programa</em> que hace lo que la especificación dice que hay que
hacer.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.7.1.0.1">

<ul>
<li><p>En ese sentido, <em>implementar</em> puede verse como sinónimo de
<em>realizar</em>, <em>diseñar</em> o <em>codificar</em>.</p></li>
<li><p>Por tanto, <em>programar</em> consiste en: primero,
<em>especificar</em> y después <em>implementar</em>.</p></li>
<li><p>En ese sentido, la implementación va asociada siempre a una
especificación, ya que debe satisfacer a ésta.</p></li>
<li><p>Decimos que <strong>una implementación <em>satisface</em> a una
especificación</strong> cuando dicha implementación hace lo que exige
esa especificación, es decir, cuando la implementación proporciona la
salida deseada a partir de los datos de entrada requeridos.</p>
<p>Recordemos que los datos de entrada y la salida deseada vienen
descritos en la especificación.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.7.1.0.2">

<ul>
<li><p>En Programación podemos implementar algoritmos o programas (y
también otras cosas que ya veremos posteriormente).</p></li>
<li><p>«<em>Implementar un algoritmo</em>» e «<em>implementar un
programa</em>» son expresiones que a veces se suelen usar
indistintamente, ya que tienen un significado similar o casi
idéntico.</p></li>
<li><p>Por ejemplo, podemos decir que «implementamos un algoritmo»
cuando diseñamos un algoritmo a partir de una especificación y lo
representamos usando una herramienta apropiada (pseudocódigo, diagramas,
etc.). En este caso, se está usando «implementar» como sinónimo de
«diseñar un algoritmo».</p></li>
<li><p>Pero también podemos decir que «implementamos un algoritmo»
cuando ya tenemos un algoritmo y lo codificamos en un determinado
lenguaje de programación, creando así un programa. En este caso, se está
usando «implementar» como sinónimo de «codificar».</p></li>
<li><p>Y también podemos decir que «implementamos un programa» cuando el
producto resultante es un programa, ya sea a partir de una
especificación o de un algoritmo ya diseñado a partir de esa
especificación.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.7.1.0.3">

<ul>
<li><p>Por tanto, «implementar» es el acto de crear algo a partir de una
especificación. El producto resultante (la implementación) puede ser un
algoritmo, un programa o más cosas que ya veremos en su
momento.</p></li>
<li><p>Puede haber varias implementaciones (algoritmos) que satisfagan
la misma especificación.</p></li>
<li><p>Asimismo, puede haber varias implementaciones (programas) del
mismo algoritmo.</p></li>
<li><p>Separar el <em>qué</em> hace (la <em>especificación</em>) del
<em>cómo</em> lo hace (la <em>implementación</em>) es una de las tareas
más importantes del buen programador.</p></li>
<li><p>Esta separación es útil tanto si se trata de especificar grandes
programas o sistemas como si se trata de pequeñas piezas de software que
puedan usarse como partes de un programa más grande.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.7.1.0.4">

<ul>
<li><p>Llamaremos <strong>usuario</strong> de un software al entorno
externo del software especificado, es decir, a los posibles usuarios
humanos o a los posibles programas que podrían utilizar los servicios
del software especificado y que, en principio, están interesados en
saber <em>qué</em> hace el programa, pero no <em>cómo</em> lo
hace.</p></li>
<li><p>La especificación de un software tiene un doble destinatario:</p>
<ul>
<li><p>Los <em>usuarios</em> del software. En este sentido, debe recoger
todo lo necesario para poder usarlo conrrectamente.</p></li>
<li><p>El <em>implementador</em> del software. En este sentido, describe
los requisitos que cualquier implementación válida debe satisfacer; es
decir, las obligaciones del implementador. Ha de dejar suficiente
libertad para que éste pueda escoger la implementación que estime más
adecuada con los recursos disponibles. Por eso, la especificación no
debería entrar en detalles de <em>cómo</em> se debe implementar el
software, ya que entonces el implementador tendría menos libertad crear
su implementación.</p></li>
</ul></li>
<li><p>La especificación actúa, por tanto, como una <em>barrera</em> y
como un <em>contrato</em> entre los usuarios y el
implementador.</p></li>
</ul>
</section>


<section id="traducción-y-ejecución" class="title-slide slide level2"
data-number="3.8">
<h2 data-number="3.8"><span class="header-section-number">3.8</span>
Traducción y ejecución</h2>
<ul>
<li><p>Una vez escrito el programa, se procede a su ejecución. Para
ello:</p>
<ul>
<li><p>Si el lenguaje es <strong>compilado</strong>: se compila, se
genera el código objeto y se ejecuta éste.</p></li>
<li><p>Si el lenguaje es <strong>interpretado</strong>: se ejecuta el
código fuente directamente por medio del intérprete del
lenguaje.</p></li>
</ul></li>
<li><p>Si durante la compilación (o ejecución, en el caso de un lenguaje
interpretado) el traductor muestra <strong>errores en el programa
fuente</strong>, hay que volver a editar el programa, corregir los
errores e intentar de nuevo.</p></li>
<li><p>Los errores que un traductor puede detectar son,
principalmente:</p>
<ul>
<li><p>Errores <strong>sintácticos</strong> (por ejemplo, falta o sobra
un paréntesis).</p></li>
<li><p>Errores <strong>de semántica estática</strong> (por ejemplo, se
intenta sumar una cadena a un número, detectable mediante un
<strong>chequeo de tipos</strong>).</p></li>
</ul></li>
</ul>
</section>
<section id="ejercicio-1" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejercicio</h5>
<ol start="7" class="example" type="1">
<li>Desde el punto de vista de la detección de errores sintácticos o de
semántica estática, ¿qué resulta más interesante: un compilador o un
intérprete? Razona la respuesta.</li>
</ol>
</section>

<section id="pruebas" class="title-slide slide level2"
data-number="3.9">
<h2 data-number="3.9"><span class="header-section-number">3.9</span>
Pruebas</h2>
<ul>
<li><p>Para determinar que el programa funciona correctamente, se
determina una <strong>batería de pruebas</strong> que debe superar el
mismo para concluir que se comporta como debe.</p></li>
<li><p>Esas baterías de prueba (o <strong>casos de prueba</strong>)
consisten en una serie de <strong>datos de entrada</strong> con los que
se estimula al programa, emparejados a una serie de <strong>resultados
esperables</strong> que se comparan con los resultados reales que el
programa genera a partir de los datos de entrada.</p></li>
<li><p>Si los resultados obtenidos coinciden con los esperables, se
concluye que el programa está funcionando
<strong>correctamente</strong>.</p></li>
<li><p>En caso contrario, decimos que el programa <strong>falla</strong>
y debemos localizar el error (o errores) que provocan el mal
funcionamiento.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.9.0.0.1">

<ul>
<li><p><strong>Las pruebas pueden detectar la presencia de errores, pero
nunca pueden garantizar la ausencia de los mismos.</strong></p></li>
<li><p>La verificación formal es la única forma de garantizar la
ausencia de errores en un programa.</p></li>
<li><p>Entonces, ¿por qué hacemos pruebas?</p>
<ul>
<li><p>Para comprobar que no se han <em>colado</em> errores al codificar
el algoritmo (aunque hayamos verificado la corrección del algoritmo, se
nos puede haber colado un error al codificarlo en el programa).</p></li>
<li><p>A veces, simplemente, no verificamos, y lo único que tenemos son
las pruebas.</p></li>
<li><p>También es importante comprobar la <strong>eficiencia</strong>
del programa con ejecuciones <em>reales</em>.</p></li>
</ul></li>
</ul>
</section>

<section id="depuración" class="title-slide slide level2"
data-number="3.10">
<h2 data-number="3.10"><span class="header-section-number">3.10</span>
Depuración</h2>
<ul>
<li><p>La <strong>depuración</strong> es el proceso de
<strong>encontrar</strong> los errores del programa y
<strong>corregir</strong> o eliminar dichos errores.</p></li>
<li><p>En caso de ser <strong>errores sintácticos o de semántica
estática</strong>, el traductor facilita mucho la tarea de localizar la
posición concreta del mismo en el programa fuente, gracias a los
<strong>mensajes de error</strong> que genera durante la compilación o
interpretación del programa.</p></li>
<li><p>Si tenemos un <strong>error lógico</strong> (un error en la
lógica del programa que provoca que éste produzca resultados
incorrectos), normalmente resulta más difícil de localizar.</p></li>
<li><p>A esos errores lógicos también se les denomina
<strong><em>bugs</em></strong> («bichos», en inglés). Por eso, el
proceso de depuración se denomina <strong><em>debug</em></strong> o
<em>debugging</em> en inglés.</p></li>
</ul>
</section>

<section id="documentación" class="title-slide slide level2"
data-number="3.11">
<h2 data-number="3.11"><span class="header-section-number">3.11</span>
Documentación</h2>
<ul>
<li><p>La documentación es el proceso por el cual incorporamos al código
fuente del programa de toda la información que pueda ayudar en la
comprensión y el mantenimiento del mismo.</p></li>
<li><p>La documentación de un programa puede ser interna o externa:</p>
<ul>
<li><p>La <strong>documentación interna</strong> forma parte del código
fuente del programa y se refiere al uso de <strong>comentarios</strong>,
identificadores descriptivos, indentación, <strong>reglas de
estilo</strong>, etc. Todo orientado a ayudar a entender el código
cuando lo lea un humano.</p></li>
<li><p>La <strong>documentación externa</strong> va fuera del código
fuente e incluye análisis, diagramas de flujo y/o pseudocódigos,
manuales de usuario con instrucciones para ejecutar el programa y para
interpretar los resultados.</p></li>
</ul></li>
</ul>
</section>

<section id="mantenimiento" class="title-slide slide level2"
data-number="3.12">
<h2 data-number="3.12"><span class="header-section-number">3.12</span>
Mantenimiento</h2>
<ul>
<li><p>La vida útil de un programa rara vez termina cuando se ha acabado
de programar y los usuarios comienzan a usarlo, sino que a partir de ese
momento comienza una de las etapas más importantes y probablemente más
costosas en tiempo y esfuerzo: el
<strong>mantenimiento</strong>.</p></li>
<li><p>Mantener un programa consiste en realizar acciones encaminadas
a:</p>
<ul>
<li><p>Corregir los fallos que puedan aparecer como consecuencia del uso
del programa (fallos que no se localizaron previamente en la fase de
pruebas).</p></li>
<li><p>Adaptar el programa a nuevas condiciones de utilización (nuevos
sistemas operativos, nuevas plataformas <em>hardware</em>…)</p></li>
<li><p>Mejorar el programa incorporando nuevas funcionalidades.</p></li>
</ul></li>
<li><p>Para ello, es fundamental que el programa esté correctamente
documentado.</p></li>
</ul>
</section>

<section id="ingeniería-del-software" class="title-slide slide level2"
data-number="3.13">
<h2 data-number="3.13"><span class="header-section-number">3.13</span>
Ingeniería del software</h2>
<ul>
<li><p>En los años 60, los problemas a resolver son cada vez más
complejos y los ordenadores son cada vez más potentes pero los
programadores son incapaces de escribir programas que aprovechen esa
potencia y que sean fiables.</p></li>
<li><p>Además resulta difícil estimar el presupuesto y el tiempo
necesarios para desarrollar programas.</p></li>
<li><p>En 1968, Fiedrich Bauer habla por primera vez de la
<strong>crisis del software</strong> en la primera Conferencia sobre
Ingeniería del Software de la OTAN en Garmish (Alemania).</p></li>
<li><p>Se llega a la conclusión de que no basta con tener mejores
herramientas (lenguajes), sino que hay que dar un enfoque más industrial
y sistemático al desarrollo de software.</p></li>
<li><p>Aparece la <strong>ingeniería del software</strong> como
disciplina.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.13.0.0.1">

<ul>
<li><p>La ingeniería del software no considera a la programación como
una disciplina científica o como un arte, sino como un proceso
sistemático que va más allá de escribir código.</p></li>
<li><p>Cuando el programa a desarrollar es grande, escribir código es
sólo una de las tareas que hay que realizar. También hay que:</p>
<ul>
<li><p>Realizar un análisis del sistema.</p></li>
<li><p>Estimar y planificar el tiempo y el esfuerzo necesarios para
desarrollar la solución.</p></li>
<li><p>Aplicar procedimientos estandarizados.</p></li>
<li><p>Elaborar documentación.</p></li>
<li><p>Medir la calidad del producto resultante.</p></li>
</ul></li>
<li><p>El desarrollo de software complejo requiere pasar por varias
etapas que, juntas, forman lo que se llama el <strong>ciclo de
vida</strong> del software.</p></li>
</ul>
</section>
</section>
<section id="bibliografía"
class="title-slide slide level1 unnumbered unlisted">
<h1 class="unnumbered unlisted">Bibliografía</h1>
<div id="refs" class="references csl-bib-body hanging-indent"
data-entry-spacing="0" role="list">
<div id="ref-aguilar_fundamentos_2008" class="csl-entry"
role="listitem">
Aguilar, Luis Joyanes. 2008. <em>Fundamentos de Programación</em>.
Aravaca: McGraw-Hill Interamericana de España.
</div>
<div id="ref-pareja_flores_desarrollo_1997" class="csl-entry"
role="listitem">
Pareja Flores, Cristóbal, Manuel Ojeda Aciego, Ángel Andeyro Quesada,
and Carlos Rossi Jiménez. 1997. <em>Desarrollo de Algoritmos y Técnicas
de Programación En <span>Pascal</span></em>. Madrid: Ra-Ma.
</div>
<div id="ref-van-roy_concepts_2004" class="csl-entry" role="listitem">
Van-Roy, Peter, and Seif Haridi. 2004. <em>Concepts, Techniques, and
Models of Computer Programming</em>. Cambridge, Mass: MIT Press.
</div>
</div>
</section>
    </div>
  </div>

  <script src="./reveal.js/dist/reveal.js"></script>

  <!-- reveal.js plugins -->
  <script src="./reveal.js/plugin/notes/notes.js"></script>
  <script src="./reveal.js/plugin/search/search.js"></script>
  <script src="./reveal.js/plugin/zoom/zoom.js"></script>
  <script src="./reveal.js/plugin/reveal.js-menu/menu.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
        // Display controls in the bottom right corner
        controls: true,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: true,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'bottom-right',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: true,

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: false,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'default',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: true,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'slide',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'fade',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1280,

        height: 1080,
        // The display mode that will be used to show slides
        display: 'block',

        menu: {
          hideMissingTitles: true,
        },

        dependencies: [
          { src: './reveal.js/plugin/reveal.js-quiz/quiz/js/quiz.js', async: true, callback: function() { prepareQuizzes({preventUnanswered: true, checkAnswerText: 'Comprueba la respuesta', nextQuestionText: 'Siguiente &raquo;', backButtonText: '&laquo; Anterior', tryAgainText: 'Prueba de nuevo', preventUnansweredText: 'Selecciona una respuesta', questionCountText: 'Pregunta %current de %total', skipStartButton: true}); } }
        ],

        // reveal.js plugins
        plugins: [
          RevealMenu,
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    <script type="text/javascript">
       var title = document.getElementsByClassName('title')[0];
       title = title != null ? title.innerHTML : '';
       var author = document.getElementsByClassName('author')[0];
       author = author != null ? author.innerHTML : '';
       var date = document.getElementsByClassName('date')[0];
       date = date != null ? date.innerHTML : '';
       document.getElementById('header-left').innerHTML = '<a href="#/title-slide">' + title + '</a>';
       document.getElementById('footer-left').innerHTML = '<a href="https://pro.iesdonana.org">&copy; ' + author + ' (' + date + ')</a>';

       function updateHeader(nd) {
           var hr = document.getElementById('header-right');
           while (hr.children.length > 0) {
               hr.removeChild(hr.lastChild);
           }
           buscar(nd, 3, hr);
           buscar(nd, 2, hr);
           buscar(nd, 1, hr);
           hr.style.fontSize = Math.round(50 * Reveal.getScale()) + '%';
           hr.style.fontSize = Math.max(Number.parseInt(getComputedStyle(hr).fontSize), 12) + 'px';
           var hl = document.getElementById('header-left');
           hl.style.fontSize = hr.style.fontSize;
       }

       function buscar(nd, level, hr) {
           if (!nd.classList.contains('level' + (level - 1))) {
               for (var n = nd; n != null; n = n.previousSibling) {
                   if (n.nodeType == Node.TEXT_NODE) {
                       continue;
                   }
                   var cl = n.classList;
                   if (cl.contains('level' + level)) {
                       var h = n.querySelector('h' + level);
                   } else if (cl.contains('level' + (level - 1))) {
                       break;
                   } else {
                       continue;
                   }
                   if (h == null || Reveal.getCurrentSlide().id == 'title-slide') {
                       hr.innerHTML = '';
                   } else {
                       var el = document.createElement('a');
                       var href = '#/' + n.id;
                       el.href = href;
                       el.innerHTML = h.innerHTML;
                       var a = el.querySelector('a');
                       if (a !== null) {
                           a.href = href;
                       }
                       if (hr.innerHTML != '') {
                           hr.innerHTML = ' &mdash; ' + hr.innerHTML;
                       }
                       hr.insertBefore(el, hr.firstChild);
                   }
                   break;
               }
           }
       }

       // On Reveal.js ready event, copy header/footer <div>
       // into each `.slide-background` <div>
       Reveal.on('ready', event => {
           var header = document.getElementById('header');
           document.querySelector('.reveal').appendChild(header);
           updateHeader(Reveal.getCurrentSlide());
       });

       Reveal.on('slidechanged', event => {
           // event.previousSlide, event.currentSlide, event.indexh, event.indexv
           updateHeader(event.currentSlide);
       });
    </script>
    </body>
</html>
