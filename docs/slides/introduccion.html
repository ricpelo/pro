<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Ricardo Pérez López">
  <title>Introducción</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="shortcut icon" type="image/png" href="/assets/icons/icon.png">
  <link rel="stylesheet" href="reveal.js/css/reveal.css">
  <style type="text/css">
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #cb4b16; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #d33682; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #dc322f; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #93a1a1; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #268bd2; } /* DataType */
code span.dv { color: #d33682; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #d33682; } /* Float */
code span.fu { color: #268bd2; } /* Function */
code span.im { font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #268bd2; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #a57800; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #2aa198; } /* SpecialString */
code span.st { color: #2aa198; } /* String */
code span.va { color: #6c71c4; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="reveal.js/css/theme/solarized.css" id="theme">
  <link rel="stylesheet" href="custom.css"/>
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
    var mathElements = document.getElementsByClassName("math");
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") { katex.render(texText.data, mathElements[i], { displayMode: mathElements[i].classList.contains("display"), throwOnError: false } );
    }}});</script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css" />
  <link href="https://fonts.googleapis.com/css?family=Lato&display=swap" rel="stylesheet">
  <style type="text/css">
      #header-left {
          position: absolute;
          font-size: 25%;
          top: 0%;
          left: 0%;
          margin-left: 10px;
          margin-top: 10px;
      }
      #header-right {
          position: absolute;
          font-size: 25%;
          top: 0%;
          right: 0%;
          margin-right: 10px;
          margin-top: 10px;
      }
      #footer-left {
          position: absolute;
          font-size: 25%;
          bottom: 0%;
          left: 0%;
          margin-left: 10px;
          margin-bottom: 10px;
      }
  </style>
</head>
<body>
<div id="hidden" style="display:none;">
    <div id="header">
        <div id="header-left"></div>
        <div id="header-right"></div>
        <div id="footer-left"></div>
    </div>
</div>
<script type="text/javascript">
    document.addEventListener("DOMContentLoaded", function(event) {
        var title = document.getElementsByClassName('title')[0];
        title = title != null ? title.innerHTML : '';
        var author = document.getElementsByClassName('author')[0];
        author = author != null ? author.innerHTML : '';
        var date = document.getElementsByClassName('date')[0];
        date = date != null ? date.innerHTML : '';
        var el = document.createElement('a');
        var href = '#/title-slide';
        el.href = href;
        el.innerHTML = title;
        document.getElementById('header-left').appendChild(el);
        document.getElementById('footer-left').innerHTML = '&copy; ' + author + ' (' + date + ')';

        function updateHeader(nd) {
            var hr = document.getElementById('header-right');
            while (hr.children.length > 0) {
                hr.removeChild(hr.lastChild);
            }
            buscar(nd, 3, hr);
            buscar(nd, 2, hr);
            buscar(nd, 1, hr);
            hr.style.fontSize = Math.round(50 * Reveal.getScale()) + '%';
            hr.style.fontSize = Math.max(Number.parseInt(getComputedStyle(hr).fontSize), 12) + 'px';
            var hl = document.getElementById('header-left');
            hl.style.fontSize = hr.style.fontSize;
        }

        function buscar(nd, level, hr) {
            if (!nd.classList.contains('level' + (level - 1))) {
                for (var n = nd; n != null; n = n.previousSibling) {
                    var cl = n.classList;
                    if (cl.contains('level' + level)) {
                        var h = n.querySelector('h' + level);
                    } else if (cl.contains('level' + (level - 1))) {
                        break;
                    } else {
                        continue;
                    }
                    if (h == null || Reveal.getCurrentSlide().id == 'title-slide') {
                        hr.innerHTML = '';
                    } else {
                        var el = document.createElement('a');
                        var href = '#/' + n.id;
                        el.href = href;
                        el.innerHTML = h.innerHTML;
                        var a = el.querySelector('a');
                        if (a !== null) {
                            a.href = href;
                        }
                    }
                    if (hr.innerHTML != '') {
                        hr.innerHTML = ' &mdash; ' + hr.innerHTML;
                    }
                    hr.insertBefore(el, hr.firstChild);
                    break;
                }
            }
        }

        // On Reveal.js ready event, copy header/footer <div>
        // into each `.slide-background` <div>
        Reveal.addEventListener('ready', function(event) {
            var header = document.getElementById('header');
            document.querySelector('.reveal').appendChild(header);
            updateHeader(Reveal.getCurrentSlide());
        });

        Reveal.addEventListener('slidechanged', function(event) {
            // event.previousSlide, event.currentSlide, event.indexh, event.indexv
            updateHeader(event.currentSlide);
        });
    });
</script>
  <div class="reveal">
    <div class="slides">

<section>
<section id="title-slide" class="title-slide slide level1">
  <h1 class="title">Introducción</h1>
  <p class="author">Ricardo Pérez López</p>
  <p class="date">IES Doñana, curso 2019/2020</p>
</section>
<section id="TOC" class="slide level2">
<ul>
<li><a href="#/conceptos-básicos"><span class="toc-section-number">1</span> Conceptos básicos</a></li>
<li><a href="#/paradigmas-de-programación"><span class="toc-section-number">2</span> Paradigmas de programación</a></li>
<li><a href="#/lenguajes-de-programación"><span class="toc-section-number">3</span> Lenguajes de programación</a></li>
<li><a href="#/traductores"><span class="toc-section-number">4</span> Traductores</a></li>
<li><a href="#/resolución-de-problemas-mediante-programación"><span class="toc-section-number">5</span> Resolución de problemas mediante programación</a></li>
<li><a href="#/entornos-integrados-de-desarrollo"><span class="toc-section-number">6</span> Entornos integrados de desarrollo</a></li>
<li><a href="#/bibliografía">Bibliografía</a></li>
</ul>
</section>
</section>

<section><section id="conceptos-básicos" class="title-slide slide level1"><h1><span class="header-section-number">1</span> Conceptos básicos</h1><!--

---

```{=html}
<script data-quiz>
quiz = {"info":{"name":"","main":""},"questions":[{"q":"What number is the letter A in the English alphabet?","a":[{"option":"8","correct":false},{"option":"14","correct":false},{"option":"1","correct":true},{"option":"23","correct":false}],"correct":"<p><span>\u00a1Eso es!</span>The letter A is the first letter in the alphabet!</p>","incorrect":"<p><span>Mmmm... no.</span>It's the first letter of the alphabet. Did you actually <em>go</em> to kindergarden?</p>"}]}</script>
```

--></section><section id="informática" class="title-slide slide level2"><h2><span class="header-section-number">1.1</span> Informática</h2><ul>
<li><p>Definición:</p>
<div class="caja">
<p><strong>Informática</strong>:</p>
<p>La ciencia que estudia los sistemas de procesamiento automático de la información, también llamados <strong>sistemas informáticos</strong>.</p>
</div></li>
<li><p>Estos sistemas están formados por:</p>
<ul>
<li>elementos físicos (<strong>hardware</strong>)</li>
<li>elementos lógicos (<strong>software</strong>) y</li>
<li>elementos humanos (profesionales y usuarios).</li>
</ul></li>
</ul></section><section class="slide level4">

<ul>
<li><p>El <em>hardware</em> es todo aquello que podemos tocar:</p>
<ul>
<li><p>Ordenadores</p></li>
<li><p>Soportes de almacenamiento</p></li>
<li><p>Redes de comunicaciones</p></li>
<li><p>…</p></li>
</ul></li>
<li><p>El <em>software</em> es todo lo que <strong>no</strong> podemos tocar:</p>
<ul>
<li><p>Datos</p></li>
<li><p>Programas</p></li>
</ul></li>
<li><p>Pero en este módulo, cuando hablemos de <em>software</em> en general, nos estaremos refiriendo a <strong>programas</strong>.</p></li>
</ul>
</section><section id="procesamiento-automático" class="title-slide slide level3"><h3><span class="header-section-number">1.1.1</span> Procesamiento automático</h3><ul>
<li>El procesamiento automático de la información siempre tiene el mismo esquema de funcionamiento:</li>
</ul>
<p><img data-src="images/procesamiento-automatico.svg" class="plain" style="width:80.0%" /></p>
<p></p>
<ul>
<li><p>El <strong>objetivo</strong> del procesamiento automático de la información es <strong>convertir los <em>datos de entrada</em> en <em>datos de salida</em></strong> mediante un <em>hardware</em> que ejecuta las instrucciones definidas por un <em>software</em> (<strong>programas</strong>).</p></li>
<li><p>Los programas gobiernan el funcionamiento del <em>hardware</em>, indicándole qué tiene que hacer y cómo.</p></li>
</ul>
<div class="caja">
<p>La <strong>Programación</strong> es la ciencia y el arte de diseñar dichos programas.</p>
</div></section><section id="ejemplos" class="slide level4">
<h4><span class="header-section-number">1.1.1.1</span> Ejemplos</h4>
<ul>
<li><p>Calcular la suma de cinco números:</p>
<ul>
<li><p><strong>Entrada</strong>: los cinco números.</p></li>
<li><p><strong>Proceso</strong>: sumar cada número con el siguiente hasta acumular el resultado final.</p></li>
<li><p><strong>Salida</strong>: la suma calculada.</p></li>
</ul></li>
<li><p>Dada una lista de alumnos con sus calificaciones finales, obtener otra lista ordenada de mayor a menor por la calificación obtenida y que muestre sólo los alumnos aprobados:</p>
<ul>
<li><p><strong>Entrada</strong>: Una lista de pares <em>(Nombre alumno, Calificación)</em>.</p></li>
<li><p><strong>Proceso</strong>: Eliminar de la lista los pares que tengan una calificación menor que cinco y ordenar la lista resultante de mayor a menor según la calificación.</p></li>
<li><p><strong>Salida</strong>: la lista ordenada de alumnos aprobados.</p></li>
</ul></li>
</ul>
</section><section id="ordenador" class="title-slide slide level2"><h2><span class="header-section-number">1.2</span> Ordenador</h2></section><section id="definición" class="title-slide slide level3"><h3><span class="header-section-number">1.2.1</span> Definición</h3><div class="caja">
<p><strong>Ordenador</strong>:</p>
<p>Un ordenador es una máquina que procesa información automáticamente de acuerdo con un programa almacenado.</p>
</div>
<ul>
<li><p>Es una <em>máquina</em>.</p></li>
<li><p>Su función es <em>procesar información</em>.</p></li>
<li><p>El procesamiento se realiza de forma <em>automática</em>.</p></li>
<li><p>El procesamiento se realiza siguiendo un <em>programa</em> (<em>software</em>).</p></li>
<li><p>Este programa está <em>almacenado</em> en una memoria interna del mismo ordenador (arquitectura de <strong>Von Neumann</strong>).</p></li>
</ul></section><section id="funcionamiento-básico" class="title-slide slide level3"><h3><span class="header-section-number">1.2.2</span> Funcionamiento básico</h3></section><section id="elementos-funcionales" class="slide level4">
<h4><span class="header-section-number">1.2.2.1</span> Elementos funcionales</h4>
<ul>
<li><p>Un ordenador consta de tres componentes principales:</p>
<ol type="1">
<li><p><strong>Unidad central de proceso (CPU) o procesador</strong></p>
<ul>
<li><p><em>Unidad aritmético-lógica (ALU)</em></p></li>
<li><p><em>Unidad de control (UC)</em></p></li>
</ul></li>
<li><p><strong>Memoria</strong></p>
<ul>
<li><p><em>Memoria principal</em> o central</p>
<ul>
<li><p><em>Memoria de acceso aleatorio (RAM)</em></p></li>
<li><p><em>Memoria de sólo lectura (ROM)</em></p></li>
</ul></li>
<li><p><em>Memoria secundaria</em> o externa</p></li>
</ul></li>
<li><p><strong>Dispositivos de E/S</strong></p>
<ul>
<li><p><em>Dispositivos de entrada</em></p></li>
<li><p><em>Dispositivos de salida</em></p></li>
</ul></li>
</ol></li>
</ul>
</section><section id="unidad-central-de-proceso-cpu-o-procesador" class="slide level4">
<h4><span class="header-section-number">1.2.2.2</span> Unidad central de proceso (CPU) o procesador</h4>
<ul>
<li><p><strong>Unidad aritmético-lógica (ALU)</strong>:</p>
<p>Realiza los cálculos y el procesamiento numérico y lógico.</p></li>
<li><p><strong>Unidad de control (UC)</strong>:</p>
<p>Ejecuta de las instrucciones enviando las señales a las distintas unidades funcionales involucradas.</p></li>
</ul>
</section><section id="memoria" class="slide level4">
<h4><span class="header-section-number">1.2.2.3</span> Memoria</h4>
<ul>
<li><p><strong>Memoria principal</strong> o central:</p>
<p>Almacena los datos y los programas que los manipulan.</p>
<p>Ambos (datos y programas) deben estar en la memoria principal para que la CPU pueda acceder a ellos.</p>
<p>Dos tipos:</p>
<ul>
<li><p><strong>Memoria de acceso aleatorio (RAM)</strong>:</p>
<p>Su contenido se borra al apagar el ordenador.</p></li>
<li><p><strong>Memoria de sólo lectura (ROM)</strong>:</p>
<p>Información permanente (ni se borra ni se puede cambiar).</p>
<p>Contiene la información esencial (datos y software) para que el ordenador pueda arrancar.</p></li>
</ul></li>
<li><p><strong>Memoria secundaria</strong> o externa:</p>
<p>La información no se pierde al apagar el ordenador.</p>
<p>Más lenta que la memoria principal, pero de mucha más capacidad.</p></li>
</ul>
</section><section id="dispositivos-de-es" class="slide level4">
<h4><span class="header-section-number">1.2.2.4</span> Dispositivos de E/S</h4>
<ul>
<li><p><strong>Dispositivos de entrada</strong>:</p>
<p>Introducen datos en el ordenador (<em>ejemplos</em>: teclado, ratón, escáner…)</p></li>
<li><p><strong>Dispositivos de salida</strong>:</p>
<p>Vuelcan datos fuera del ordenador (<em>ejemplos</em>: pantalla, impresora…)</p></li>
<li><p><strong>Dispositivos de entrada/salida</strong>:</p>
<p>Actúan simultáneamente como dispositivos de entrada y de salida (<em>ejemplos</em>: pantalla táctil, adaptador de red…)</p></li>
<li><p>Los dispositivos que acceden a <strong>soportes de almacenamiento masivo</strong> (las <strong>memorias secundarias</strong>) también se pueden considerar dispositivos de E/S:</p>
<ul>
<li><p>Los soportes de <strong>sólo lectura</strong> se leen con dispositivos de entrada (<em>ejemplo</em>: discos ópticos).</p></li>
<li><p>Los soportes de <strong>lectura/escritura</strong> operan como dispositivos de entrada/salida (<em>ejemplos</em>: discos duros, pendrives, tarjetas SD…).</p></li>
</ul></li>
</ul>
</section><section class="slide level4">


<figure>
<img data-src="images/esquema-basico.svg" alt="Esquema básico de un ordenador" class="plain" style="width:80.0%" /><figcaption>Esquema básico de un ordenador</figcaption>
</figure>
<p></p>
<ul>
<li><p>El programa se <strong>carga</strong> de la memoria secundaria a la memoria principal.</p></li>
<li><p>Una vez allí, la CPU va <strong>extrayendo</strong> las instrucciones que forman el programa y las va <strong>ejecutando</strong> paso a paso, en un bucle continuo que se denomina <strong>ciclo de instrucción</strong>.</p></li>
<li><p>Durante la ejecución del programa, la CPU recogerá los datos de entrada desde los dispositivos de entrada y los almacenará en la memoria principal, para que las instrucciones puedan operar con ellos.</p></li>
<li><p>Al finalizar el programa, los datos de salida se volcarán hacia los dispositivos de salida.</p></li>
</ul>
</section><section id="ciclo-de-instrucción" class="slide level4">
<h4><span class="header-section-number">1.2.2.6</span> Ciclo de instrucción</h4>
<ul>
<li><p>En la <strong>arquitectura Von Neumann</strong>, los programas se almacenan en la memoria principal junto con los datos (por eso también se denomina «arquitectura de <strong>programa almacenado</strong>»).</p></li>
<li><p>Una vez que el programa está cargado en memoria, la CPU repite siempre los mismos pasos:</p>
<ol>
<li><p>(<strong>Fetch</strong>) Busca la siguiente instrucción en la memoria principal.</p></li>
<li><p>(<strong>Decode</strong>) Decodifica la instrucción (identifica qué instrucción es y se prepara para su ejecución).</p></li>
<li><p>(<strong>Execute</strong>) Ejecuta la instrucción (envía las señales de control necesarias a las distintas unidades funcionales).</p></li>
</ol></li>
</ul>
</section><section class="slide level4">


<figure>
<img data-src="images/ciclo-instruccion.svg" alt="Ciclo de instrucción" class="plain" style="width:80.0%" /><figcaption>Ciclo de instrucción</figcaption>
</figure>
<p></p>
</section><section id="representación-de-información" class="slide level4">
<h4><span class="header-section-number">1.2.2.8</span> Representación de información</h4>
<ul>
<li><p>En un sistema informático, toda la información se almacena y se manipula en forma de números.</p></li>
<li><p>Por tanto, para que un sistema informático pueda procesar información, primero hay que representar dicha información usando números, proceso que se denomina <strong>codificación</strong>.</p>
<div class="caja">
<p><strong>Codificación</strong>:</p>
<p>Proceso mediante el cual se representa información dentro de un sistema informático, asociando a cada dato (elemental o estructurado) uno o más valores numéricos.</p>
</div></li>
<li><p>Una codificación, por tanto, es una correspondencia entre un conjunto de datos y un conjunto de números llamado <strong>código</strong>. Al codificar, lo que hacemos es asociar a cada dato un determinado número dentro del código.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Hay muchos tipos de información (textos, sonidos, imágenes, valores numéricos…) y eso hace que pueda haber muchas formas de codificación.</p></li>
<li><p>Incluso un mismo tipo de dato (un número entero, por ejemplo) puede tener distintas codificaciones, cada una con sus características y propiedades.</p></li>
<li><p>Distinguimos la forma en la que se representa la información <em>internamente</em> en el sistema informático (<strong>codificación interna</strong>) de la que usamos para comunicar dicha información <em>desde y hacia el exterior</em> (<strong>codificación externa</strong> o <strong>de E/S</strong>).</p></li>
</ul>

<p><img data-src="images/codificaciones.svg" class="plain" style="width:80.0%" /></p>
<p></p>
</section><section id="codificación-interna" class="slide level4">
<h4><span class="header-section-number">1.2.2.10</span> Codificación interna</h4>
<ul>
<li><p>Los ordenadores son <strong>sistemas electrónicos digitales</strong> que trabajan conmutando entre varios posibles estados de una determinada magnitud física (voltaje, intensidad de corriente, etc.).</p></li>
<li><p>Lo más sencillo y práctico es usar únicamente dos estados posibles.</p>
<p>Por ejemplo:</p>
<ul>
<li><p>0 V y 5 V de voltaje.</p></li>
<li><p>0 mA y 100 mA de intensidad de corriente.</p></li>
</ul></li>
<li><p>A cada uno de los dos posibles estados le hacemos corresponder (arbitrariamente) un valor numérico <strong>0</strong> ó <strong>1</strong>. A ese valor se le denomina <strong>bit</strong> (contracción de <em>binary digit</em>, dígito binario).</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Por ejemplo, la memoria principal de un ordenador está formada por millones de celdas, parecidas a microscópicos condensadores. Cada uno de estos condensadores puede estar cargado o descargado y, por tanto, es capaz de almacenar un bit:</p>
<ul>
<li>Condensador cargado: bit a 1</li>
<li>Condensador descargado: bit a 0</li>
</ul>
<div class="caja">
<p><strong>Bit</strong>:</p>
<p>Un bit es, por tanto, la unidad mínima de información que es capaz de almacenar y procesar un ordenador, y equivale a un <strong>dígito binario</strong>.</p>
</div></li>
<li><p>En la práctica, se usan unidades múltiplos del bit:</p>
<ul>
<li>1 byte = 8 bits</li>
<li>1 Kibibyte (KiB) = <span class="math inline">2^{10}</span> = 1024 bytes</li>
<li>1 Mebibyte (MiB) = <span class="math inline">2^{20}</span> bytes = 1024 Kilobytes</li>
<li>1 Gibibyte (GiB) = <span class="math inline">2^{30}</span> bytes = 1024 Mebibytes</li>
<li>1 Tebibyte (TiB) = <span class="math inline">2^{40}</span> bytes = 1024 Gibibytes</li>
</ul></li>
</ul>
</section><section id="sistema-binario" class="slide level4">
<h4><span class="header-section-number">1.2.2.12</span> Sistema binario</h4>
<ul>
<li><p>El sistema de numeración que usamos habitualmente los seres humanos es el <strong>decimal</strong> o sistema <strong>en base diez</strong>.</p></li>
<li><p>En ese sistema disponemos de diez dígitos distintos (0, 1, 2, 3, 4, 5, 6, 7, 8 y 9) y cada dígito en un determinado número tiene un peso que es múltiplo de una potencia de diez.</p>
<p>Por ejemplo: <span class="math display">243 = 2 \times 10^2 + 4 \times 10^1 + 3 \times 10^0</span></p></li>
<li><p>El sistema de numeración que usan los ordenadores es el <strong>sistema binario</strong> o sistema <strong>en base dos</strong>, en el cual disponemos sólo de dos dígitos (0 y 1) y cada peso es múltiplo de una potencia de dos.</p>
<p>Por ejemplo: <span class="math display">101 = 1 \times 2^2 + 0 \times 2^1 + 1 \times 2^0</span></p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Generalmente, los números naturales se codifican internamente mediante su representación en binario.</p></li>
<li><p>Los números enteros se suelen codificar mediante:</p>
<ul>
<li><p>Bit de signo (signo y magnitud)</p></li>
<li><p>Complemento a uno</p></li>
<li><p>Complemento a dos</p></li>
</ul></li>
<li><p>Los números reales se pueden codificar mediante:</p>
<ul>
<li><p>Coma fija</p></li>
<li><p>Coma flotante</p>
<ul>
<li><p>Simple precisión</p></li>
<li><p>Doble precisión</p></li>
</ul></li>
<li><p>Decimal codificado en binario (BCD)</p></li>
</ul></li>
</ul>
</section><section id="codificación-externa" class="slide level4">
<h4><span class="header-section-number">1.2.2.14</span> Codificación externa</h4>
<ul>
<li><p>Para representar cadenas de caracteres y comunicarse con el exterior, el ordenador utiliza <strong>códigos de E/S</strong> o <strong>códigos externos</strong>.</p></li>
<li><p>A cada carácter (letra, dígito, signo de puntuación, símbolo especial…) le corresponde un código (número) dentro de un <strong>conjunto de caracteres</strong>.</p></li>
<li><p>Existen conjuntos de caracteres:</p>
<ul>
<li><p>De <strong>longitud fija</strong>: a todos los caracteres les corresponden un código de igual longitud.</p></li>
<li><p>De <strong>longitud variable</strong>: en el mismo conjunto de caracteres hay códigos más largos y más cortos (por tanto, hay caracteres que ocupan más bytes que otros).</p></li>
</ul></li>
</ul>
</section><section id="ascii" class="slide level4">
<h4><span class="header-section-number">1.2.2.15</span> ASCII</h4>
<ul>
<li><p><em>American Standard Code for Information Interchange</em>.</p></li>
<li><p>El conjunto de caracteres ASCII (o <strong>código ASCII</strong>) es el más implantado en el <em>hardware</em> de los equipos informáticos.</p></li>
<li><p>Es la base de otros códigos más modernos, como el ISO-8859-1 o el Unicode.</p></li>
<li><p>Es un código de 7 bits:</p>
<ul>
<li>Cada carácter ocupa 7 bits.</li>
<li>Hay <span class="math inline">2^7 = 128</span> caracteres posibles.</li>
<li>Los 32 primeros códigos (del 0 al 31) son no imprimibles (códigos de control).</li>
</ul></li>
<li><p>El ISO-8859-1 es un código de 8 bits que extiende el ASCII con un bit más para contener caracteres latinos.</p></li>
</ul>
</section><section id="unicode" class="slide level4">
<h4><span class="header-section-number">1.2.2.16</span> Unicode</h4>
<ul>
<li><p>Con 8 bits (y con 7 bits aún menos) no es posible representar todos los posibles caracteres de todos los sistemas de escritura usados en el mundo.</p></li>
<li><p>Unicode es el estándar de codificación de caracteres más completo y universal en la actualidad.</p></li>
<li><p>Cada carácter en Unicode se define mediante un identificador numérico llamado <em>code point</em>.</p></li>
<li><p>Unicode define tres formas de codificación:</p>
<ul>
<li><strong>UTF-8</strong>: codificación de 8 bits, de longitud variable (cada <em>code point</em> puede ocupar de 1 a 4 bytes). <strong>El más usado en la actualidad.</strong></li>
<li><strong>UTF-16</strong>: codificación de 16 bits, de longitud variable (cada <em>code point</em> puede ocupar 1 ó 2 palabras de 16 bits).</li>
<li><strong>UTF-32</strong>: codificación de 32 bits, de longitud fija (cada <em>code point</em> ocupa 1 palabra de 32 bits).</li>
</ul></li>
</ul>
</section><section id="algoritmo" class="title-slide slide level2"><h2><span class="header-section-number">1.3</span> Algoritmo</h2></section><section id="definición-1" class="title-slide slide level3"><h3><span class="header-section-number">1.3.1</span> Definición</h3><div class="caja">
<p><strong>Algoritmo</strong>:</p>
<p>Un algoritmo es un método para resolver un problema.</p>
</div>
<ul>
<li><p>Está formado por una secuencia de pasos o <strong>instrucciones</strong> que se deben seguir (o <strong>ejecutar</strong>) para resolver el problema.</p></li>
<li><p>La palabra «algoritmo» proviene de <strong>Mohammed Al-Khowârizmi</strong>, matemático persa que vivió durante el siglo IX y reconocido por definir una serie de reglas paso a paso para sumar, restar, multiplicar y dividir números decimales.</p></li>
<li><p><strong>Euclides</strong>, el gran matemático griego (del siglo IV a. C.) que inventó un método para encontrar el máximo común divisor de dos números, se considera con Al-Khowârizmi el otro gran padre de la Algorítmica (la ciencia que estudia los algoritmos).</p></li>
</ul></section><section class="slide level4">

<ul>
<li><p>El estudio de los algoritmos es importante porque la resolución de un problema exige el diseño de un algoritmo que lo resuelva.</p></li>
<li><p>Una vez diseñado el algoritmo, se traduce a un programa informático usando un <em>lenguaje de programación</em>.</p></li>
<li><p>Finalmente, un ordenador ejecuta dicho programa.</p></li>
</ul>

<figure>
<img data-src="images/resolucion-problema.svg" alt="Resolución de un problema" class="plain" style="width:80.0%" /><figcaption>Resolución de un problema</figcaption>
</figure>
<p></p>
</section><section id="características" class="title-slide slide level3"><h3><span class="header-section-number">1.3.2</span> Características</h3><ul>
<li><p>Un algoritmo debe ser:</p>
<ul>
<li><p><strong>Preciso</strong>: debe expresarse de forma no ambigua. La precisión afecta por igual a dos aspectos:</p>
<ul>
<li><p>Al <em>orden</em> de los pasos que han de llevarse a cabo.</p></li>
<li><p>Al <em>contenido</em> de los pasos, pues en cada uno hay que saber qué hacer exactamente.</p></li>
</ul></li>
<li><p><strong>Determinado</strong>: si se sigue un algoritmo dos veces, se debe obtener el mismo resultado cada vez.</p></li>
<li><p><strong>Finito</strong>: debe terminar en algún momento, es decir, debe tener un número finito de pasos.</p></li>
</ul></li>
</ul></section><section id="representación" class="title-slide slide level3"><h3><span class="header-section-number">1.3.3</span> Representación</h3><div class="columns">
<div class="column" style="width:50%;">
<ul>
<li><p>Un algoritmo se puede describir usando el <strong>lenguaje natural</strong>, es decir, cualquier idioma humano.</p></li>
<li><p>¿Qué <span style="color:red">problema</span> tiene esta forma de representación?</p>
<div class="centered">
<p><strong>Ambigüedad</strong></p>
</div></li>
<li><p>En ciertos contextos la ambigüedad es asumible, pero <strong>NO</strong> cuando el destinatario es un ordenador.</p></li>
<li><p>¿Podemos decir que esta receta de cocina es un algoritmo?</p></li>
</ul>
</div><div class="column" style="width:50%;">
<div class="caja">
<div style="font-size: 90%">
<p><strong>Instrucciones para hacer una tortilla</strong>:</p>
<ol type="1">
<li>Coger dos huevos.</li>
<li>Encender el fuego.</li>
<li>Echar aceite a la sartén.</li>
<li>Batir los huevos.</li>
<li>Echar los huevos batidos en la sartén.</li>
<li>Esperar a que se haga por debajo.</li>
<li>Dar la vuelta a la tortilla.</li>
<li>Esperar de nuevo.</li>
<li>Sacar cuando esté lista.</li>
</ol>
<p><strong>Fin</strong></p>
</div>
</div>
</div>
</div></section><section id="ordinograma" class="slide level4">
<h4><span class="header-section-number">1.3.3.1</span> Ordinograma</h4>
<ul>
<li><p>Representación gráfica que describe un algoritmo en forma de diagrama de flujo.</p></li>
<li><p>Las flechas indican el orden de ejecución de las instrucciones.</p></li>
<li><p>Los nodos condicionales (los rombos) indican que la ejecución se bifurca a uno u otro camino dependiendo de una condición.</p></li>
</ul>
</section><section id="ejemplo" class="slide level4">
<h4><span class="header-section-number">1.3.3.2</span> Ejemplo</h4>
<p>Determinar cuál es el máximo de dos números</p>

<p><img data-src="images/maximo.svg" class="plain" style="width:40.0%" /></p>

</section><section id="pseudocódigo" class="slide level4">
<h4><span class="header-section-number">1.3.3.3</span> Pseudocódigo</h4>
<ul>
<li><p>Es un lenguaje semi-formal, a medio camino entre el lenguaje natural y el lenguaje que entendería un ordenador (lenguaje de programación).</p></li>
<li><p>Está pensado para ser interpretado por una persona y no por un ordenador.</p></li>
<li><p>En general, no se tienen en cuenta las limitaciones impuestas por el <em>hardware</em> (CPU, memoria…) o el <em>software</em> (tamaño máximo de los datos, codificación interna…), siempre y cuando no sea importante el estudio de la eficiencia o la complejidad del algoritmo.</p></li>
<li><p>En ese sentido, se usa como un lenguaje de programación <em>idealizado</em>.</p></li>
</ul>
</section><section id="ejemplo-1" class="slide level4">
<h4><span class="header-section-number">1.3.3.4</span> Ejemplo</h4>

<div class="line-block"><strong>Algoritmo</strong>: Obtener el mayor de dos números<br />
<br />
<span class="math inline">X \leftarrow</span> <strong>leer</strong> número<br />
<span class="math inline">Y \leftarrow</span> <strong>leer</strong> número<br />
<strong>si</strong> <span class="math inline">X &gt; Y</span> <strong>entonces</strong><br />
    <strong>escribir</strong> “X es mayor que Y”<br />
<strong>si no</strong><br />
    <strong>escribir</strong> “Y es mayor que X”<br />
<strong>fin</strong></div>

</section><section id="cualidades-deseables" class="title-slide slide level3"><h3><span class="header-section-number">1.3.4</span> Cualidades deseables</h3><ul>
<li><p><strong>Corrección</strong>: El algoritmo debe solucionar correctamente el problema.</p></li>
<li><p><strong>Claridad</strong>: Cuanto más legible y comprensible para el ser humano, mejor.</p></li>
<li><p><strong>Generalidad</strong>: Un algoritmo debe resolver problemas generales. Por ejemplo, un algoritmo que sume dos números enteros debe servir para sumar cualquier pareja de números enteros, y no, solamente, para sumar dos números determinados, como pueden ser el 3 y el 5.</p></li>
<li><p><strong>Eficiencia</strong>: Un algoritmo es mejor cuanto menos recursos (tiempo, espacio…) necesita para resolver el problema. Por eso no debe realizar pasos innecesarios ni recordar más información de la necesaria.</p></li>
<li><p><strong>Sencillez</strong>: Hay que intentar que la solución sea sencilla, aun a costa de perder un poco de eficiencia, es decir, se tiene que buscar un equilibrio entre la claridad y la eficiencia.</p></li>
<li><p><strong>Modularidad</strong>: Un algoritmo puede formar parte de la solución a un problema mayor. A su vez, dicho algoritmo puede descomponerse en otros si esto favorece a la claridad del mismo.</p></li>
</ul></section><section id="computabilidad" class="title-slide slide level3"><h3><span class="header-section-number">1.3.5</span> Computabilidad</h3><ul>
<li><p>¿Todos los problemas pueden resolverse de forma algorítmica?</p></li>
<li><p>Dicho de otra forma, queremos saber lo siguiente:</p>
<div class="caja centered">
<p>Dado un problema, ¿existe un algoritmo que lo resuelva?</p>
</div></li>
</ul></section><section class="slide level4">

<ul>
<li><p>Todo problema <span class="math inline">P</span> lleva asociada una función <span class="math inline">f_P: D \rightarrow R</span>, donde:</p>
<ul>
<li><span class="math inline">D</span> es el conjunto de los datos de entrada.</li>
<li><span class="math inline">R</span> es el conjunto de los resultados del problema.</li>
</ul></li>
<li><p>Asimismo, todo algoritmo <span class="math inline">A</span> lleva asociada una función <span class="math inline">f_A</span>.</p></li>
<li><p>La pregunta es: ¿existe un algoritmo A tal que <span class="math inline">f_A = f_P</span>?</p></li>
<li><p>Y de ahí vamos a la pregunta general:</p>
<div class="caja centered">
<p>¿Toda función <span class="math inline">f</span> es computable (resoluble algorítmicamente)?</p>
</div></li>
</ul>
</section><section class="slide level4">

<p>La respuesta es que <strong>NO</strong></p>
<ul>
<li>Se puede demostrar que hay más funciones que algoritmos, por lo que <strong>existen funciones que no se pueden computar mediante un algoritmo</strong> (no son computables).</li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>La dificultad que tiene estudiar la computabilidad de funciones está en que no tenemos una definición formal de «<em>algoritmo</em>».</p></li>
<li><p>A comienzos del S. XX, se crearon (independientemente uno del otro) dos formalismos matemáticos para representar el concepto de <em>algoritmo</em>:</p>
<ul>
<li><p>Alonzo Church creó el <strong>cálculo lambda</strong>.</p></li>
<li><p>Alan Turing creó la <strong>máquina de Turing</strong>.</p></li>
</ul></li>
<li><p>Posteriormente se demostró que los dos formalismos eran totalmente equivalentes y eran, además, equivalentes a las <strong>gramáticas formales</strong>.</p></li>
<li><p>Esto llevó a formular la llamada <strong>tesis de Church-Turing</strong>, que dice que</p>
<div class="caja centered">
<p>«<em>Todo algoritmo es equivalente a una máquina de Turing.</em>»</p>
</div></li>
<li><p>La tesis de Church-Turing es indemostrable pero prácticamente toda la comunidad científica la acepta como verdadera.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Usando esos formalismos, se pudo demostrar que hay que problemas que no se pueden resolver mediante algoritmos.</p></li>
<li><p>Uno de los problemas que no tienen una solución algorítmica es el llamado <strong>problema de la parada</strong>:</p>
<div class="caja">
<p><strong>Problema de la parada</strong>:</p>
<p>Dado un algoritmo y un posible dato de entrada, determinar (a priori, es decir, sin ejecutarlo previamente) si el algoritmo se detendrá y producirá un valor de salida.</p>
</div></li>
<li><p>Nunca podremos hacer un algoritmo que resuelva el problema de la parada en términos generales (en casos particulares sí se puede).</p></li>
</ul>
</section><section id="corrección" class="title-slide slide level3"><h3><span class="header-section-number">1.3.6</span> Corrección</h3><ul>
<li><p>¿Cómo sabemos si un algoritmo es <strong>correcto</strong>?</p></li>
<li><p>¿Qué significa eso de que un algoritmo sea correcto?</p></li>
<li><p>Supongamos que, para un problema <span class="math inline">P</span>, existe un algoritmo <span class="math inline">A</span>. Lo que tenemos que averiguar es si se cumple: <span class="math display">f_P = f_A</span></p></li>
<li><p>¿Cómo lo hacemos?</p>
<ul>
<li><p>Si el conjunto <span class="math inline">D</span> de datos de entrada es <strong>finito</strong>, podríamos comparar todos los resultados de salida con los resultados esperados y ver si coinciden.</p></li>
<li><p>Si <span class="math inline">D</span> es <strong>infinito</strong>, es imposible realizar una comprobación empírica de la corrección del algoritmo (en cambio, sí se puede demostrar que es incorrecto.)</p></li>
</ul></li>
</ul></section><section class="slide level4">

<ul>
<li><p>Lo mejor es recurrir a <strong>métodos formales</strong>:</p>
<ul>
<li><p><strong>Diseño a priori</strong>: se construye el algoritmo en base a una prueba (lo que se denomina también <strong>demostración constructiva</strong>).</p></li>
<li><p><strong>Diseño a posteriori</strong>: se construye el algoritmo de forma más o menos intuitiva y, una vez diseñado, tratar de demostrar su corrección.</p></li>
</ul></li>
<li><p>En ambos casos, es importante definir con mucha precisión qué problema queremos resolver: se describe el problema mediante una <strong>especificación formal</strong>.</p></li>
</ul>
</section><section id="complejidad" class="title-slide slide level3"><h3><span class="header-section-number">1.3.7</span> Complejidad</h3><ul>
<li><p>¿Cómo de <strong>eficiente</strong> es un algoritmo?</p></li>
<li><p>La eficiencia de un algoritmo se mide en función del <strong>consumo de recursos</strong> que necesita el algoritmo para su ejecución.</p>
<ul>
<li>Los principales recursos son el <strong>tiempo</strong> y el <strong>espacio</strong>.</li>
</ul></li>
<li><p>Dados dos algoritmos distintos que resuelvan el mismo problema, en general nos interesará usar el más eficiente de ellos (al margen de otras consideraciones, como la claridad, la legibilidad, la mantenibilidad, la reusabilidad, etc.)</p></li>
<li><p>¿Cómo medimos la eficiencia de un algoritmo?</p></li>
<li><p>¿Cómo comparamos la eficiencia de dos algoritmos?</p></li>
</ul></section><section class="slide level4">

<ul>
<li><p>El <strong>análisis de algoritmos</strong> estudia la eficiencia de un algoritmo desde un punto de vista abstracto (independiente de la máquina, el lenguaje de programación, la carga de trabajo, etc.).</p></li>
<li><p>Define el consumo de recursos como una función del tamaño del problema.</p>
<ul>
<li>Ejemplo: <span class="math inline">t(n) \simeq 3n^2</span></li>
</ul></li>
<li><p>Finalmente, clasifica dicho consumo según una <strong>notación asintótica</strong>.</p>
<ul>
<li>Ejemplo: <span class="math inline">t(n) \in O(n^2)</span></li>
</ul></li>
</ul>
</section><section id="programa" class="title-slide slide level2"><h2><span class="header-section-number">1.4</span> Programa</h2><ul>
<li><p>Definición:</p>
<div class="caja">
<p><strong>Programa</strong>:</p>
<p>Un programa es la codificación de un algoritmo en un lenguaje de programación.</p>
</div></li>
<li><p>Si el algoritmo está adecuadamente definido, <em>traducir</em> ese algoritmo en un programa equivalente puede resultar trivial.</p></li>
<li><p>El texto del programa escrito en ese lenguaje de programación se denomina <strong>código fuente</strong>. Programar, al final, consiste en escribir (<em>codificar</em>) el código fuente de nuestro programa.</p></li>
<li><p>El algoritmo está pensado para ser entendido por un ser humano, mientras que el programa se escribe para ser interpretado y ejecutado por un ordenador.</p></li>
<li><p>Por ello, toda posible ambigüedad que pudiera quedar en el algoritmo debe eliminarse al codificarlo en forma de programa.</p></li>
</ul></section><section class="slide level4">

<ul>
<li><p>Programar depende mucho de las características del lenguaje de programación elegido.</p></li>
<li><p>Lo ideal es usar un lenguaje que se parezca lo más posible al <em>pseudolenguaje</em> utilizado para describir el correspondiente algoritmo.</p></li>
<li><p>En un programa también hay que considerar aspectos y limitaciones que hasta ahora no habíamos tenido en cuenta:</p>
<ul>
<li><p>El tamaño de los datos en memoria: por ejemplo, suele haber límites en cuanto a la cantidad de dígitos que puede tener un número o su precisión decimal.</p></li>
<li><p>Restricciones en los datos: mutables vs. inmutables, de tamaño fijo vs. tamaño variable, etc.</p></li>
<li><p>La semántica de las instrucciones: un símbolo usado en un algoritmo puede tener otro significado distinto en el programa, o puede que sólo pueda usarse en el programa bajo ciertas condiciones que no hace falta considerar en el algoritmo.</p></li>
</ul></li>
</ul>
</section></section>
<section><section id="paradigmas-de-programación" class="title-slide slide level1"><h1><span class="header-section-number">2</span> Paradigmas de programación</h1></section><section id="definición-2" class="title-slide slide level2"><h2><span class="header-section-number">2.1</span> Definición</h2><div class="caja">
<p><strong>Paradigma de programación</strong>:</p>
<p>Es un <strong>estilo</strong> de desarrollar programas, es decir, un <strong>modelo</strong> para resolver problemas computacionales.</p>
</div></section><section class="slide level4">

<ul>
<li><p>Cada paradigma entiende la programación desde una perspectiva diferente, partiendo de unos conceptos básicos diferentes y con unas reglas diferentes.</p></li>
<li><p>Cuando diseñamos un algoritmo o escribimos un programa, lo hacemos con base en un determinado paradigma, y éste impregna por completo la forma en la que describimos la solución al problema en el que estamos trabajando.</p></li>
<li><p>No existe un único paradigma de programación y cada uno tiene sus peculiaridades que lo hacen diferente.</p></li>
<li><p>Cada lenguaje de programación (o pseudocódigo) se dice que <em>soporta</em> un determinado paradigma cuando con dicho lenguaje se pueden escribir algoritmos o programas según el «estilo» que impone dicho paradigma.</p></li>
<li><p>Incluso existen lenguajes <em>multiparadigma</em> capaces de soportar varios paradigmas al mismo tiempo.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Clasificación de los paradigmas de programación más importantes:</p>
<ul>
<li><p>Imperativo</p>
<ul>
<li><p>Estructurado</p></li>
<li><p>Orientado a objetos</p></li>
</ul></li>
<li><p>Declarativo</p>
<ul>
<li><p>Funcional</p></li>
<li><p>Lógico</p></li>
<li><p>De bases de datos</p></li>
</ul></li>
</ul></li>
</ul>
</section><section class="slide level4">


<figure>
<img data-src="images/paradigmas.png" alt="Principales paradigmas (c) 2008 Peter Van Roy" style="width:80.0%" /><figcaption>Principales paradigmas (c) 2008 Peter Van Roy</figcaption>
</figure>

</section><section id="imperativo" class="title-slide slide level2"><h2><span class="header-section-number">2.2</span> Imperativo</h2><ul>
<li><p>El <strong>paradigma imperativo</strong> está basado en el concepto de <strong>sentencia</strong>. Un programa imperativo está formado por una sucesión de sentencias que se ejecutan en orden y que llevan a cabo una de estas acciones:</p>
<ul>
<li><p><strong>Cambiar el estado</strong> interno del programa, usualmente mediante la sentencia de <em>asignación</em>.</p></li>
<li><p>Cambiar el <strong>flujo de control</strong> del programa, haciendo que la ejecución se bifurque (<em>salte</em>) a otra parte del mismo.</p></li>
</ul></li>
<li><p>La ejecución de un programa imperativo, por tanto, consiste en una sucesión de cambios de estado controlados por mecanismos de control y que dependen del orden en el que se realizan.</p></li>
<li><p>Existen varios paradigmas con las características del paradigma imperativo, por lo que podemos decir que existen varios paradigmas imperativos.</p></li>
</ul></section><section id="estructurado" class="title-slide slide level3"><h3><span class="header-section-number">2.2.1</span> Estructurado</h3><ul>
<li><p>El <strong>paradigma estructurado</strong> es un paradigma imperativo en el que el flujo de control del programa se define mediante las denominadas <strong>estructuras de control</strong>.</p></li>
<li><p>Se apoya a nivel teórico en los resultados del conocido <strong>teorema de Böhm y Jacopini</strong>, que establece que cualquier programa se puede escribir usando solamente tres estructuras básicas:</p>
<ul>
<li>Secuencia</li>
<li>Selección</li>
<li>Iteración</li>
</ul></li>
<li><p>Con estas tres estructuras conseguimos que los programas se puedan leer de arriba abajo como compuestos por <strong>bloques anidados o independientes</strong> que se leen como un todo conjunto.</p></li>
<li><p>Su aparición llevó asociada la aparición de una <strong>metodología de desarrollo</strong> según la cual los programas se escriben por niveles de abstracción mediante refinamientos sucesivos y usando en cada nivel sólo las tres estructuras básicas.</p></li>
</ul></section><section id="orientado-a-objetos" class="title-slide slide level3"><h3><span class="header-section-number">2.2.2</span> Orientado a objetos</h3><ul>
<li><p>El <strong>paradigma orientado a objetos</strong> se apoya en los conceptos de <strong>objeto</strong> y <strong>mensaje</strong>.</p></li>
<li><p>Un programa orientado a objetos está formado por una colección de objetos que se intercambian mensajes entre sí.</p></li>
<li><p>Los objetos son entidades que existen dentro del programa y que poseen un cierto <strong>estado interno</strong>.</p></li>
<li><p>Cuando un objeto envía un mensaje a otro, el objeto receptor del mensaje reaccionará llevando a cabo alguna acción, que probablemente provocará un <strong>cambio en su estado interno</strong> y que, posiblemente, provocará también el envío de mensajes a otros objetos.</p></li>
<li><p>La programación orientada a objetos está vista como una forma natural de entender la programación y es, con diferencia, <strong>el paradigma más usado en la actualidad</strong>.</p></li>
</ul></section><section id="declarativo" class="title-slide slide level2"><h2><span class="header-section-number">2.3</span> Declarativo</h2><ul>
<li><p>La <strong>programación declarativa</strong> engloba a una familia de paradigmas de programación de muy alto nivel.</p></li>
<li><p>En programación declarativa se describe la solución a un problema con base en las propiedades que debe cumplir dicha solución y no tanto en forma de instrucciones que se deben ejecutar para resolver el problema.</p></li>
<li><p>Se dice que un programa imperativo describe <strong>cómo</strong> resolver el problema, mientras que un programa declarativo describe <strong>qué</strong> forma debe tener la solución.</p></li>
<li><p>Para dar forma a la solución, se utilizan formalismos abstractos matemáticos y lógicos, lo que da lugar a los dos grandes paradigmas declarativos: la <strong>programación funcional</strong> y <strong>la programación lógica</strong>.</p></li>
</ul></section><section id="funcional" class="title-slide slide level3"><h3><span class="header-section-number">2.3.1</span> Funcional</h3><ul>
<li><p>La <strong>programación funcional</strong> es un paradigma de programación declarativa basado en el uso de <strong>funciones matemáticas</strong>.</p></li>
<li><p>Tiene su origen teórico en el <strong>cálculo lambda</strong> de Alonzo Church (los lenguajes funcionales se pueden considerar azúcar sintáctico del cálculo lambda).</p></li>
<li><p>Una función (en programación funcional) define de un cálculo a realizar a partir de unos datos de entrada, con la propiedad de que el resultado de la función sólo puede depender de dichos datos de entrada (lo que se denomina <strong>transparencia referencial</strong>).</p></li>
<li><p>Eso significa que una función no puede tener estado interno ni su resultado puede depender del estado interno del programa. Por tanto, no existen los <strong>efectos laterales</strong>.</p></li>
<li><p>Demostrar la corrección de un programa funcional o paralelizar su ejecución es <strong>mucho más fácil</strong> que con un programa imperativo.</p></li>
</ul></section><section id="lógico" class="title-slide slide level3"><h3><span class="header-section-number">2.3.2</span> Lógico</h3><ul>
<li><p>La <strong>programación lógica</strong> es un paradigma de programación declarativa basado en el uso de la <strong>lógica de predicados de primer orden</strong>.</p></li>
<li><p>Básicamente, un programa lógico es una colección de definiciones que forman un conjunto de <strong>axiomas</strong> en un sistema de <strong>deducción lógica</strong>.</p></li>
<li><p>Ejecutar un programa lógico equivale a poner en marcha un mecanismo deductivo que trata de <strong>demostrar un teorema</strong> a partir de los axiomas.</p></li>
<li><p>El ejemplo más característico de este tipo de lenguajes es <strong>Prolog</strong>.</p></li>
</ul></section><section id="de-bases-de-datos" class="title-slide slide level3"><h3><span class="header-section-number">2.3.3</span> De bases de datos</h3><ul>
<li><p>Los sistemas de gestión de bases de datos relacionales (SGBDR) disponen de un lenguaje que permite al usuario consultar y manipular la información almacenada.</p></li>
<li><p>A esos lenguajes se los denomina <strong>lenguajes de bases de datos</strong> o <strong>lenguajes de consulta</strong>.</p></li>
<li><p>El lenguaje de consulta más conocido es el <strong>SQL</strong>.</p></li>
<li><p>Los SGBDR se basan en el <em>modelo relacional</em>, que es un modelo matemático.</p></li>
<li><p>SQL es, básicamente, una implementación del <strong>álgebra relacional</strong>.</p></li>
<li><p>Con SQL, el usuario indica <em>qué</em> desea obtener y el SGBDR determina automáticamente el mejor camino para alcanzar dicho objetivo.</p></li>
</ul></section><section id="actividades" class="slide level4">
<h4><span class="header-section-number">2.3.3.1</span> Actividades</h4>
<ol class="example" type="1">
<li>¿Hay más paradigmas de programación? Busca en Internet y pon un par de ejemplos de paradigmas que no se hayan nombrado aquí. Para cada uno, describe en una sola frase sus características básicas.</li>
</ol>
</section></section>
<section><section id="lenguajes-de-programación" class="title-slide slide level1"><h1><span class="header-section-number">3</span> Lenguajes de programación</h1></section><section id="definición-3" class="title-slide slide level2"><h2><span class="header-section-number">3.1</span> Definición</h2><div class="caja">
<p><strong>Lenguaje de programación:</strong></p>
<p>Un lenguaje de programación es un <strong>lenguaje formal</strong> que proporciona una serie de instrucciones que permiten a un programador escribir programas destinados a controlar el comportamiento físico y lógico de un ordenador.</p>
</div>
<ul>
<li><p>Un <strong>programa</strong> es la <strong>codificación de un algoritmo</strong> en un lenguaje de programación.</p></li>
<li><p>Por tanto: cuando escribimos un algoritmo en un lenguaje de programación, obtenemos un programa.</p></li>
<li><p>Estos lenguajes están determinados por un conjunto de símbolos (llamado <em>alfabeto</em>), reglas gramaticales (léxico/morfológicas y sintácticas) y reglas semánticas, que en conjunto definen las estructuras válidas en el lenguaje y su significado.</p></li>
</ul></section><section id="sintaxis" class="title-slide slide level3"><h3><span class="header-section-number">3.1.1</span> Sintaxis</h3><ul>
<li><p>A la forma visible de un lenguaje de programación se la conoce como <strong>sintaxis</strong>.</p></li>
<li><p>La sintaxis de un lenguaje de programación describe las combinaciones posibles de los símbolos que forman un programa sintácticamente correcto.</p></li>
<li><p>La sintaxis define dos elementos principales:</p>
<ul>
<li><p>Los componentes léxicos, es decir, los elementos mínimos que forman un programa (palabras clave, identificadores, caracteres de puntuación como paréntesis o comas, etc…).</p></li>
<li><p>La estructura gramatical, es decir, cómo se pueden combinar los componentes léxicos para formar «frases» correctas según la sintaxis del lenguaje.</p></li>
</ul></li>
</ul></section><section id="notación-ebnf" class="slide level4">
<h4><span class="header-section-number">3.1.1.1</span> Notación EBNF</h4>
<ul>
<li><p>La sintaxis de los lenguajes de programación es definida generalmente utilizando:</p>
<ul>
<li><p><strong>Expresiones regulares</strong> (para la estructura léxica)</p></li>
<li><p><strong>Notación de Backus-Naur extendida</strong> (para la estructura gramatical)</p></li>
</ul></li>
<li><p>Cada una de esas notaciones son formalismos usados para describir estructuras sintácticas en gramáticas formales.</p></li>
<li><p>Las expresiones regulares las estudiaremos a lo largo del curso, ya que resultan muy útiles para procesar cadenas.</p></li>
<li><p>Conocer la notación de Backus-Naur resulta de gran interés porque la mayoría de los lenguajes de programación la utilizan para documentar su sintaxis.</p></li>
</ul>
</section><section id="ejemplo-2" class="slide level4">
<h4><span class="header-section-number">3.1.1.2</span> Ejemplo</h4>
<div class="columns">
<div class="column">
<div class="line-block"><span style="color:teal"><em>&lt;expresión&gt;</em></span> ::= <span style="color:teal"><em>&lt;átomo&gt;</em></span> | <span style="color:teal"><em>&lt;lista&gt;</em></span><br />
<span style="color:teal"><em>&lt;átomo&gt;</em></span> ::= <span style="color:teal"><em>&lt;número&gt;</em></span> | <span style="color:teal"><em>&lt;símbolo&gt;</em></span><br />
<span style="color:teal"><em>&lt;lista&gt;</em></span> ::= <strong><code>(</code></strong> <span style="color:teal"><em>&lt;expresión&gt;</em></span>* <strong><code>)</code></strong><br />
<span style="color:teal"><em>&lt;número&gt;</em></span> ::= [<strong><code>+</code></strong> | <strong><code>-</code></strong>] <span style="color:teal"><em>&lt;dígito&gt;</em></span>+<br />
<span style="color:teal"><em>&lt;símbolo&gt;</em></span> ::= <span style="color:teal"><em>&lt;letra&gt;</em></span>+<br />
<span style="color:teal"><em>&lt;dígito&gt;</em></span> ::= <strong><code>0</code></strong> | <strong><code>1</code></strong> | <strong><code>2</code></strong> | <strong><code>3</code></strong> | <strong><code>4</code></strong> | <strong><code>5</code></strong> | <strong><code>6</code></strong> | <strong><code>7</code></strong> | <strong><code>8</code></strong> | <strong><code>9</code></strong><br />
<span style="color:teal"><em>&lt;letra&gt;</em></span> ::= <strong><code>a</code></strong> | <strong><code>b</code></strong> | … | <strong><code>z</code></strong></div>
<ul>
<li>Cada regla sintáctica (llamada <strong>producción</strong>) está formada por dos partes separadas por <span style="color:teal">::=</span> , donde a la izquierda hay un símbolo no terminal y a la derecha puede haber una lista de símbolos terminales y no terminales.</li>
</ul>
</div><div class="column">
<ul>
<li>Los nombres entre ángulos (como <span style="color:teal"><em>&lt;expresión&gt;</em></span>) se llaman <strong>símbolos no terminales</strong>.</li>
<li>Los caracteres en negrita y azul (como <strong><code>b</code></strong>) se llaman <strong>símbolos terminales</strong>.</li>
<li>La barra vertical <span style="color:teal">|</span> indica poder elegir entre dos <strong>opciones</strong>.</li>
<li>El <span style="color:teal">*</span> representa 0, 1 ó más <strong>repeticiones</strong> de lo que acompaña.</li>
<li>El <span style="color:teal">+</span> representa 1 ó más <strong>repeticiones</strong> de lo que acompaña.</li>
<li>Los corchetes <span style="color:teal">[</span> y <span style="color:teal">]</span> indican <strong>optatividad</strong>.</li>
<li>Los paréntesis <span style="color:teal">(</span> y <span style="color:teal">)</span> <strong>agrupan</strong>.</li>
</ul>
</div>
</div>
</section><section id="semántica-estática" class="title-slide slide level3"><h3><span class="header-section-number">3.1.2</span> Semántica estática</h3><ul>
<li><p>La semántica estática define las <strong>restricciones</strong> sobre la estructura de los textos válidos que resulta imposible o muy difícil expresar mediante formalismos sintácticos estándar como los que acabamos de ver.</p></li>
<li><p>Es decir: hay programas sintácticamente correctos que, sin embargo, no resultan ser programas válidos según las reglas de la semántica estática del lenguaje.</p></li>
<li><p>La semántica estática de un lenguaje está fuertemente relacionado con su <strong>sistema de tipos</strong>.</p></li>
<li><p>Por ejemplo:</p>
<ul>
<li>Comprobar que los tipos de los datos a operar son los correctos (por ejemplo, que no se intente sumar una cadena a un número).</li>
<li>Comprobar que una variable está ligada a un valor antes de usarla en una expresión.</li>
<li>Comprobar que el número de argumentos en la llamada a una función coincide con el número de parámetros de la función.</li>
</ul></li>
</ul></section><section id="semántica-dinámica" class="title-slide slide level3"><h3><span class="header-section-number">3.1.3</span> Semántica dinámica</h3><ul>
<li><p>La semántica dinámica (o simplemente <strong>semántica</strong>) de un lenguaje de programación expresa el <strong>significado</strong> de cada construcción del lenguaje.</p></li>
<li><p>Es un concepto muy complicado de formalizar y por ello se suele definir de manera informal en la documentación del lenguaje en función de los <strong>efectos</strong> que produce cada construcción del lenguaje dentro de un programa.</p></li>
</ul></section><section id="evolución-histórica" class="title-slide slide level2"><h2><span class="header-section-number">3.2</span> Evolución histórica</h2><ul>
<li><p><strong>1804: El telar de Jacquard (<em>Joseph Marie Jacquard</em>)</strong></p>
<ul>
<li>Tarjetas perforadas para controlar los diseños en los tejidos.</li>
</ul></li>
<li><p><strong>1837 – 1871: La máquina analítica (<em>Charles Babbage</em>)</strong></p>
<ul>
<li><p>En 1842, el matemático italiano Luigi Menabrea escribió una descripción de la máquina en frances.</p></li>
<li><p>En 1843, <strong>Ada Lovelace</strong> la traduce al inglés e incorpora unas anotaciones propias en las que especifica con detalle un método para calcular los números de Bernoulli con esa máquina. Por ello, se la considera <strong>la primera programadora de la historia</strong>.</p></li>
</ul></li>
</ul></section><section class="slide level4">

<ul>
<li><p><strong>1890: Máquinas tabuladoras electromecánicas (<em>Herman Hollerith, Tabulating Machine Company</em>)</strong></p>
<ul>
<li>Hollerith está considerado <strong>el primer informático de la historia</strong>, por crear las primeras máquinas de procesamiento automático de la información.</li>
<li>Con ellas se creó el censo de los EE.UU.</li>
<li>Su empresa acabó llamándose <strong>IBM</strong>.</li>
</ul></li>
<li><p><strong>1936: El gran año de los modelos formales computacionales:</strong></p>
<ul>
<li><p><strong>Cálculo lambda (<em>Alonzo Church</em>)</strong></p>
<ul>
<li>Un modelo universal de computación basado en la abstracción y aplicación de funciones.</li>
</ul></li>
<li><p><strong>Máquinas de Turing (<em>Alan Turing</em>)</strong></p>
<ul>
<li>Un modelo universal de computación basado en máquinas abstractas que manipulan símbolos escritos en una cinta de acuerdo a una serie de reglas definidas.</li>
</ul></li>
<li><p><strong>Sorpresa</strong>: ambos modelos son <strong>equivalentes</strong>.</p></li>
</ul></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p><strong>El trabajo de <em>Konrad Zuse</em>:</strong></p>
<ul>
<li><p><strong>1941: Ordenador Z3</strong></p>
<ul>
<li><p>El primer ordenador digital programable que realmente llegó a funcionar.</p></li>
<li><p>Por ello, Zuse es considerado <strong>el inventor del ordenador moderno</strong>.</p></li>
</ul></li>
<li><p><strong>1945: Ordenador Z4</strong></p>
<ul>
<li><p>El primer ordenador digital comercial del mundo.</p></li>
<li><p>Se vendió a varias universidades.</p></li>
</ul></li>
<li><p><strong>1948: Plankalkül</strong></p>
<ul>
<li><p>Considerado <strong>el primer lenguaje de programación</strong>.</p></li>
<li><p>Diseñado, pero no implantado en su época.</p></li>
</ul></li>
</ul></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p><strong>(<em>Hasta aquí</em>):</strong> Todo se programa en <strong>lenguaje máquina</strong></p></li>
<li><p><strong>1949: Lenguaje ensamblador (<em>EDSAC</em>)</strong></p></li>
<li><p><strong>Primeros Autocódigos:</strong></p>
<ul>
<li><p><strong>1952: Autocódigo de Glennie (<em>Alick Glennie, Universidad de Manchester</em>)</strong></p></li>
<li><p><strong>1955: Autocódigo del Mark 1 (<em>Ralph Anthony Brooker, Universidad de Manchester</em>)</strong></p></li>
</ul></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p><strong>1957: Fortran (<em>John Backus, IBM</em>)</strong></p>
<ul>
<li>El primer lenguaje de alto nivel de propósito general de uso masivo en tener una implementación funcional.</li>
</ul></li>
<li><p><strong>1958: LISP (<em>John McCarthy, Instituto de Tecnología de Massachusetts</em>)</strong></p>
<ul>
<li><p>Basado en el cálculo lambda.</p></li>
<li><p>Destinado al procesamiento simbólico y a la investigación en Inteligencia Artificial.</p></li>
</ul></li>
<li><p><strong>1958 – 1960: Familia de lenguajes ALGOL (<em>Backus, Naur, Wijngaarden, Bauer, Perlis, McCarthy y otros</em>):</strong></p>
<ul>
<li><p><strong>1958: ALGOL 58</strong></p>
<ul>
<li>Introdujo el concepto de bloque de código (sentencia compuesta).</li>
</ul></li>
<li><p><strong>1960: ALGOL 60</strong></p>
<ul>
<li><p>Influyó mucho en lenguajes posteriores.</p></li>
<li><p>Introdujo las definiciones de funciones anidadas y el ámbito léxico.</p></li>
</ul></li>
</ul></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p><strong>1959: FLOW-MATIC (<em>Grace Hopper, Remington Rand</em>)</strong></p>
<ul>
<li><p>El primer lenguaje de alto nivel orientado a las aplicaciones de gestión.</p></li>
<li><p>El primero en usar sentencias y palabras en inglés.</p></li>
</ul></li>
<li><p><strong>1960: COBOL (<em>Grace Hopper, Comisión CODASYL y Departamento de Defensa de los EE.UU.</em>)</strong></p>
<ul>
<li>Inspirado en FLOW-MATIC.</li>
</ul></li>
<li><p><strong>1962: Simula (<em>Ole-Johan Dahl y Kristen Nygaard, Norwegian Computer Center</em>)</strong></p>
<ul>
<li>Considerado el primer lenguaje <strong>orientado a objetos</strong>.</li>
</ul></li>
<li><p><strong>1970: Pascal (<em>Niklaus Wirth</em>)</strong></p>
<ul>
<li><p>Lenguaje imperativo, procedimental, estructurado, pequeño, eficiente, heredero del ALGOL 60.</p></li>
<li><p>Muy usado en la enseñanza de la programación.</p></li>
</ul></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p><strong>1972: Prolog (<em>Alain Colmerauer, Universidad de Marsella</em>)</strong></p>
<ul>
<li>El primer lenguaje de <strong>programación lógica</strong>.</li>
</ul></li>
<li><p><strong>1972: C (<em>Dennis Ritchie, Laboratorios Bell</em>)</strong></p>
<ul>
<li><p>Lenguaje de <strong>nivel medio</strong> (de alto nivel pero con acceso directo a la máquina y al sistema operativo).</p></li>
<li><p>Lenguaje <strong>de sistemas</strong></p></li>
</ul></li>
<li><p><strong>1975: Scheme (<em>Gerald Jay Sussman, Guy L. Steele, Jr., MIT</em>)</strong></p>
<ul>
<li>Lenguaje funcional basado en LISP con ámbito léxico.</li>
</ul></li>
<li><p><strong>1978: ML (<em>Robin Milner, Universidad de Edimburgo</em>)</strong></p>
<ul>
<li><p>Lenguaje de <strong>programación funcional</strong> con sistema de tipos estático y polimórfico.</p></li>
<li><p>En realidad es una familia de lenguajes, entre los que se encuentran Standard ML, OCaml o F#.</p></li>
</ul></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p><strong>1980: Smalltalk (<em>Alan Kay, Adele Goldberg, Xerox PARC</em>)</strong></p>
<ul>
<li>Lenguaje orientado a objetos puro, reflexivo, con tipado dinámico, con un entorno propio de desarrollo y ejecución.</li>
</ul></li>
<li><p><strong>1985: C++ (<em>Bjarne Stroustrup, Laboratorios Bell</em>)</strong></p>
<ul>
<li>Extensión orientada a objetos del lenguaje C.</li>
</ul></li>
<li><p><strong>1990: Haskell (<em>Simon Peyton Jones, Paul Hudak, Philip Wadler y otros</em>)</strong></p>
<ul>
<li>Lenguaje funcional puro con evaluación no estricta y sistema de tipos polimórfico y fuertemente tipado.</li>
</ul></li>
<li><p><strong>1991: Python (<em>Guido Van Rossum, CWI de Holanda</em>)</strong></p>
<ul>
<li>Lenguaje multiparadigma interpretado, dinámico y multiplataforma.</li>
</ul></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p><strong>1995: Un año especialmente destacable:</strong></p>
<ul>
<li><p><strong>Java (<em>James Gosling, Sun Microsystems</em>)</strong></p>
<ul>
<li><p>Lenguaje orientado a objetos, el más usado en la actualidad.</p></li>
<li><p>Genera código para una máquina virtual presente en millones de dispositivos en todo el mundo.</p></li>
</ul></li>
<li><p><strong>JavaScript (<em>Brendan Eich, Netscape Communications</em>)</strong></p>
<ul>
<li><p>Lenguaje multiparadigma, basado en prototipos e interpretado.</p></li>
<li><p>Usado como lenguaje cliente en los navegadores web.</p></li>
</ul></li>
<li><p><strong>PHP (<em>Rasmus Lerdorf</em>)</strong></p>
<ul>
<li><p>Lenguaje multiparadigma e interpretado.</p></li>
<li><p>Usado principalmente como lenguaje de servidor en aplicaciones web.</p></li>
</ul></li>
<li><p><strong>Ruby (<em>Yukihiro Matsumoto</em>)</strong></p>
<ul>
<li>Lenguaje interpretado orientado a objetos puro.</li>
</ul></li>
</ul></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p><strong>2000: C# (<em>Anders Hejlsberg, Microsoft</em>)</strong></p>
<ul>
<li>Lenguaje orientado a objetos para la plataforma .NET.</li>
</ul></li>
<li><p><strong>2003: Scala (<em>Martin Odersky, Escuela Politécnica Federal de Lausana, Suiza</em>)</strong></p>
<ul>
<li>Lenguaje multiparadigma (funcional y orientado a objetos) para la máquina virtual de Java.</li>
</ul></li>
<li><p>Swift, Kotlin, TypeScript, Julia, Go, Rust, Perl 6, Clojure…</p></li>
</ul>
</section><section id="actividades-1" class="slide level4">
<h4><span class="header-section-number">3.2.0.10</span> Actividades</h4>
<ol start="2" class="example" type="1">
<li>Busca en Internet información sobre un lenguaje de programación que no se haya comentado aquí y que se haya creado no antes del año 2000. Anota el paradigma (o paradigmas) que soporta y los lenguajes que influyeron en su diseño.</li>
</ol>
</section><section id="clasificación" class="title-slide slide level2"><h2><span class="header-section-number">3.3</span> Clasificación</h2></section><section id="por-nivel" class="title-slide slide level3"><h3><span class="header-section-number">3.3.1</span> Por nivel</h3><ul>
<li><p>Dependiendo del <strong>nivel</strong> del lenguaje de programación tenemos:</p>
<ul>
<li><p>Lenguajes de bajo nivel</p></li>
<li><p>Lenguajes de alto nivel</p></li>
</ul></li>
</ul></section><section id="lenguajes-de-bajo-nivel" class="slide level4">
<h4><span class="header-section-number">3.3.1.1</span> Lenguajes de bajo nivel</h4>
<ul>
<li><p>Lenguajes más cercanos a la máquina</p></li>
<li><p>Con poca o nula capacidad de abstracción</p></li>
<li><p>Se trabaja directamente con elementos propios del <em>hardware</em> del ordenador</p></li>
<li><p>Atados a la arquitectura interna de la máquina para la que se programa</p></li>
<li><p>Programas difíciles de escribir, depurar, mantener y portar</p></li>
<li><p>Se consigue el máximo control del ordenador</p></li>
<li><p>Principales ejemplos:</p>
<ul>
<li><p>Código máquina</p></li>
<li><p>Ensamblador</p></li>
</ul></li>
</ul>
</section><section id="lenguajes-de-alto-nivel" class="slide level4">
<h4><span class="header-section-number">3.3.1.2</span> Lenguajes de alto nivel</h4>
<ul>
<li><p>Lenguajes más cercanos al ser humano</p></li>
<li><p>Mayor capacidad de abstracción</p></li>
<li><p>Independiente de la arquitectura y los detalles internos del ordenador o el sistema operativo</p></li>
<li><p>Programas más fáciles de escribir, depurar, mantener y portar</p></li>
<li><p>Menor control de los recursos de la máquina</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Ejemplos de lenguajes de alto nivel:</p>
<ul>
<li>Fortran</li>
<li>LISP</li>
<li>COBOL</li>
<li>BASIC</li>
<li>Pascal</li>
<li>C</li>
<li>Java</li>
<li>Ruby</li>
<li>C++</li>
<li>Python</li>
<li>JavaScript</li>
<li>C#</li>
<li>PHP</li>
<li>Haskell</li>
</ul></li>
</ul>
</section><section id="actividades-2" class="slide level4">
<h4><span class="header-section-number">3.3.1.4</span> Actividades</h4>
<ol start="3" class="example" type="1">
<li>Ordena cronológicamente la lista anterior por el año de creación de cada lenguaje.</li>
</ol>
</section><section id="por-generación" class="title-slide slide level3"><h3><span class="header-section-number">3.3.2</span> Por generación</h3><ol type="1">
<li><p><strong>Primera generación</strong>: Se programa directamente en <em>código máquina</em>.</p></li>
<li><p><strong>Segunda generación</strong>: Aparece el <em>lenguaje ensamblador</em> como un lenguaje simbólico que se traduce a lenguaje máquina usando un <em>programa ensamblador</em>.</p></li>
<li><p><strong>Tercera generación</strong>: Aparecen los <em>lenguajes de alto nivel</em> con los que se puede programar con códigos independientes de la máquina. El código fuente se traduce a código máquina usando programas específicos llamados <strong>traductores</strong>.</p></li>
<li><p><strong>Cuarta generación</strong>: Herramientas que combinan un lenguaje de programación de alto nivel con un <em>software</em> de generación de pantallas, listados, informes, etc. orientado al desarrollo rápido de aplicaciones. Ejemplos característicos son los lenguajes de <strong>programación visual</strong>.</p></li>
<li><p><strong>Quinta generación</strong>: Es una denominación que se usó durante un tiempo para los lenguajes de programación de muy alto nivel (funciones y lógicos) destinados principalmente a resolver problemas de <strong>Inteligencia Artificial</strong>, pero como término ya ha caído en desuso.</p></li>
</ol></section><section id="por-propósito" class="title-slide slide level3"><h3><span class="header-section-number">3.3.3</span> Por propósito</h3><ul>
<li><p>Dependiendo del tipo de programa que podemos escribir con el lenguaje, tenemos:</p>
<ul>
<li><p><strong>Lenguajes de propósito general</strong>: Con ellos se pueden escribir programas muy diversos. No están atados a un tipo concreto de problema a resolver. Ejemplos:</p>
<ul>
<li>LISP, Pascal, C, Java, Ruby, C++, Python, C#, Haskell…</li>
</ul></li>
<li><p><strong>Lenguajes de propósito específico</strong>: Son lenguajes mucho más especializados y destinados principalmente a resolver un tipo determinado de problema. No sirven para escribir cualquier tipo de programa pero, dentro de su ámbito de actuación, suelen funcionar mejor que los lenguajes de propósito general. Ejemplos:</p>
<ul>
<li>Lenguajes de consulta a bases de datos (SQL)</li>
<li>Lenguajes de descripción de hardware (VHDL)</li>
<li>Lenguajes para desarrollo de aplicaciones de gestión (COBOL)</li>
</ul></li>
</ul></li>
</ul></section><section id="por-paradigma" class="title-slide slide level3"><h3><span class="header-section-number">3.3.4</span> Por paradigma</h3><ul>
<li><p>Dependiendo del paradigma de programación que soporta el lenguaje, podemos encontrar:</p>
<ul>
<li><p>Lenguajes imperativos</p></li>
<li><p>Lenguajes funcionales</p></li>
<li><p>Lenguajes orientados a objetos</p></li>
<li><p>Lenguajes lógicos</p></li>
<li><p>Lenguajes dirigidos por eventos</p></li>
<li><p>Lenguajes multiparadigma</p></li>
</ul></li>
</ul></section></section>
<section><section id="traductores" class="title-slide slide level1"><h1><span class="header-section-number">4</span> Traductores</h1></section><section id="definición-4" class="title-slide slide level2"><h2><span class="header-section-number">4.1</span> Definición</h2><ul>
<li><p>El único lenguaje que entiende la máquina directamente es el <strong>lenguaje máquina</strong> o <strong>código máquina</strong>, que es un lenguaje de <strong>bajo nivel</strong>.</p></li>
<li><p>Para poder programar con un lenguaje de <strong>alto nivel</strong>, necesitamos usar herramientas <em>software</em> que traduzcan nuestro programa al lenguaje máquina que entiende el ordenador.</p></li>
<li><p>Estas herramientas <em>software</em> son los <strong>traductores</strong>.</p>
<div class="caja">
<p><strong>Traductor:</strong></p>
<p>Es un <em>software</em> que traduce un programa escrito en un lenguaje a otro lenguaje, conservando su significado.</p>
</div></li>
</ul></section><section class="slide level4">

<ul>
<li><p>El traductor transforma el programa fuente (o <strong>código fuente</strong>) en el programa objeto (o <strong>código objeto</strong>).</p></li>
<li><p>El código fuente está escrito en el <strong>lenguaje fuente</strong> (que generalmente será un lenguaje de alto nivel).</p></li>
<li><p>El código objeto está escrito en el <strong>lenguaje objeto</strong> (que generalmente será código máquina).</p></li>
<li><p>Durante el proceso de traducción, el traductor también informa al programador de posibles <strong>errores</strong> en el código fuente.</p></li>
</ul>

<figure>
<img data-src="images/traduccion.svg" alt="El proceso de traducción" class="plain" style="width:80.0%" /><figcaption>El proceso de traducción</figcaption>
</figure>
<p></p>
</section><section id="compiladores" class="title-slide slide level2"><h2><span class="header-section-number">4.2</span> Compiladores</h2><ul>
<li><p>Definición:</p>
<div class="caja">
<p><strong>Compilador</strong>:</p>
<p>Es un traductor que convierte un programa escrito en un lenguaje de <strong>más alto nivel</strong> a un lenguaje de <strong>más bajo nivel</strong>.</p>
</div></li>
<li><p>Generalmente, el lenguaje objeto suele ser <strong>código máquina</strong> y el resultado de la compilación es un <strong>objeto ejecutable</strong> directamente por la máquina.</p></li>
</ul>
<p><img data-src="images/compilacion.svg" class="plain" style="width:80.0%" /></p>
<p></p></section><section id="ensambladores" class="title-slide slide level3"><h3><span class="header-section-number">4.2.1</span> Ensambladores</h3><ul>
<li><p>Un caso particular de compilador es el <strong>ensamblador</strong>:</p>
<div class="caja">
<p><strong>Ensamblador</strong>:</p>
<p>Es un compilador que traduce un programa escrito en <strong>lenguaje ensamblador</strong> a código máquina.</p>
</div></li>
<li><p>Muchas veces, los compiladores se construyen <em>en cadena</em>: en lugar de generar código máquina directamente, generan código ensamblador que sirve de entrada a un programa ensamblador que generará el código objeto final.</p></li>
</ul>
<p><img data-src="images/ensamblado.svg" class="plain" style="width:80.0%" /></p>
<p></p></section><section id="intérpretes" class="title-slide slide level2"><h2><span class="header-section-number">4.3</span> Intérpretes</h2><ul>
<li><p>Un <strong>intérprete</strong> es un caso muy especial de traductor.</p></li>
<li><p>En lugar de generar código objeto, el intérprete <strong>lee el código fuente y lo ejecuta directamente</strong>.</p></li>
<li><p>El intérprete funciona, por tanto, como un <strong>simulador</strong> de una máquina que hablara el lenguaje de alto nivel en el que está escrito el programa fuente.</p></li>
</ul>
<p><img data-src="images/interpretes.svg" class="plain" style="width:80.0%" /></p>
<p></p></section><section class="slide level4">

<ul>
<li><p>El desarrollo de programas se ve <strong>acelerado</strong> con un intérprete ya que no es necesario pasar por el proceso de compilación ni, por tanto, generar el código objeto para poder ejecutar el programa.</p></li>
<li><p>Sin embargo, si el programa fuente tiene errores sintácticos, el intérprete no informará de ellos hasta el momento en el que intente ejecutar la instrucción errónea, es decir, <strong>los errores se muestran en tiempo de ejecución, no en tiempo de compilación</strong>.</p></li>
<li><p>Hay lenguajes <em>compilados</em> y lenguajes <em>interpretados</em>, e incluso lenguajes que son ambas cosas (tienen compiladores e intérpretes).</p></li>
</ul>
</section><section id="interactivos-repl" class="title-slide slide level3"><h3><span class="header-section-number">4.3.1</span> Interactivos (<em>REPL</em>)</h3><ul>
<li><p>A los intérpretes que hemos visto hasta ahora se les denomina <strong>intérpretes por lotes</strong>, ya que tratan al programa fuente como un lote de instrucciones conjuntas.</p></li>
<li><p>A diferencia de los anteriores, los <strong>intérpretes interactivos</strong> son programas que solicitan al programador que introduzca por teclado, una a una, las instrucciones que se desean ejecutar, y el intérprete las va ejecutando a medida que el programador las va introduciendo.</p></li>
<li><p>Su comportamiento se resume en el siguiente bucle:</p>
<ol type="1">
<li>Leer la siguiente instrucción por teclado (<em><strong>R</strong>ead</em>)</li>
<li>Ejecutar o evaluar la instrucción (<em><strong>E</strong>val</em>)</li>
<li>Imprimir por la pantalla el resultado (<em><strong>P</strong>rint</em>)</li>
<li>Repetir el bucle (<em><strong>L</strong>oop</em>)</li>
</ol></li>
</ul></section><section class="slide level4">

<ul>
<li><p>Los intérpretes interactivos son ideales para:</p>
<ul>
<li><p>Aprender conceptos de programación.</p></li>
<li><p>Experimentar con el lenguaje.</p></li>
<li><p>Probar rápidamente el efecto de una instrucción.</p></li>
</ul></li>
</ul>
</section></section>
<section><section id="resolución-de-problemas-mediante-programación" class="title-slide slide level1"><h1><span class="header-section-number">5</span> Resolución de problemas mediante programación</h1></section><section id="introducción" class="title-slide slide level2"><h2><span class="header-section-number">5.1</span> Introducción</h2><ul>
<li><p>El proceso de resolución de un problema con un ordenador pasa por escribir y ejecutar un programa.</p></li>
<li><p>Aunque diseñar programas es, esencialmente, un proceso creativo, se puede considerar una serie de fases o pasos comunes, que generalmente deben seguir todos los programadores:</p>
<ul>
<li>Especificación</li>
<li>Análisis del problema</li>
<li>Diseño del algoritmo</li>
<li>Verificación</li>
<li>Estudio de la eficiencia</li>
<li>Codificación</li>
<li>Traducción y ejecución</li>
<li>Pruebas</li>
<li>Depuración</li>
<li>Documentación</li>
<li>Mantenimiento</li>
</ul></li>
</ul></section><section id="especificación" class="title-slide slide level2"><h2><span class="header-section-number">5.2</span> Especificación</h2><ul>
<li><p>En esta fase se define con precisión (cuanto más formal mejor):</p>
<ul>
<li><p>Qué datos de entrada se requieren</p></li>
<li><p>Cuál es la salida deseada</p></li>
</ul></li>
<li><p>Se trata al programa como una caja negra de la que se sabe <em>qué</em> tiene que hacer pero aún no sabemos <em>cómo</em>.</p></li>
<li><p>Ejemplo: Se desea determinar el máximo de dos números enteros</p>
<ul>
<li>Entrada: los dos números (llamémosles <span class="math inline">n_1</span> y <span class="math inline">n_2</span>) enteros</li>
<li>Proceso: determinar cuál es el mayor de los dos</li>
<li>Salida: el mayor de los dos números</li>
</ul></li>
</ul>
<div class="line-block"><strong>Entrada:</strong> <span class="math inline">n_1, n_2: \mathbb{N}</span><br />
<strong>Proceso:</strong> Cálculo del máximo de dos números<br />
<strong>Salida:</strong> el mayor de ambos</div></section><section id="análisis-del-problema" class="title-slide slide level2"><h2><span class="header-section-number">5.3</span> Análisis del problema</h2><ul>
<li><p>A partir de la especificación, se estudia detalladamente el problema a resolver, los requisitos que se deben cumplir y las posibles restricciones que pueda tener la solución.</p></li>
<li><p>En el ejemplo anterior:</p>
<ul>
<li>Hay que comparar el valor de los dos números y devolver el mayor de ellos.</li>
<li>Si los dos números son iguales, se puede devolver cualquiera de los dos.</li>
</ul></li>
</ul></section><section id="diseño-del-algoritmo" class="title-slide slide level2"><h2><span class="header-section-number">5.4</span> Diseño del algoritmo</h2><ul>
<li><p>Una vez analizado el problema con detalle, se diseña un algoritmo que cumpla con todas las posibles restricciones y satisfaga la especificación del problema.</p></li>
<li><p>El algoritmo se representa con cualquier herramienta adecuada para ello: ordinogramas, pseudocódigo, etc.</p></li>
</ul>
<div class="line-block"><strong>Algoritmo:</strong> Cálculo del máximo de dos números<br />
<strong>Entrada:</strong> <span class="math inline">n_1, n_2: \mathbb{N}</span><br />
<strong>Salida:</strong> el mayor de ambos<br />
<br />
<strong>inicio</strong><br />
    <strong>si</strong> <span class="math inline">n_1 &gt; n_2</span> <strong>entonces</strong><br />
        <strong>devolver</strong> <span class="math inline">n_1</span><br />
    <strong>sino</strong><br />
        <strong>devolver</strong> <span class="math inline">n_2</span><br />
<strong>fin</strong></div></section><section id="verificación" class="title-slide slide level2"><h2><span class="header-section-number">5.5</span> Verificación</h2><ul>
<li><p>Es el proceso por el cual se intenta <strong>demostrar</strong> que el algoritmo diseñado es <strong>correcto</strong>.</p></li>
<li><p>Un algoritmo es correcto cuando <strong>satisface su especificación</strong>.</p></li>
<li><p>Es un proceso basado en las matemáticas y la lógica, y consiste en considerar que el algoritmo es un <strong>teorema</strong> a demostrar en un sistema deductivo lógico en el que hay <em>axiomas</em> y <em>reglas de inferencia</em>.</p></li>
<li><p>Puede resultar muy difícil incluso en casos sencillos.</p></li>
<li><p>En la práctica, su uso se reduce a bloques pequeños y críticos del programa.</p></li>
</ul></section><section id="estudio-de-la-eficiencia" class="title-slide slide level2"><h2><span class="header-section-number">5.6</span> Estudio de la eficiencia</h2><ul>
<li><p>Cuando disponemos de un algoritmo correcto que resuelve el problema, podemos optar a estudiar la eficiencia del mismo.</p></li>
<li><p>Si el algoritmo es correcto pero ineficiente, no suele resultar práctico, y se debe optar por diseñar otro algoritmo más eficiente.</p></li>
</ul></section><section id="codificación" class="title-slide slide level2"><h2><span class="header-section-number">5.7</span> Codificación</h2><ul>
<li><p>Una vez diseñado y verificado el algoritmo, éste se codifica en un lenguaje de programación usando un editor de textos o un IDE (<em>Entorno Integrado de Desarrollo</em>).</p></li>
<li><p>Se considera una tarea casi mecanizable, pero aún hay decisiones que pueden influir a la hora de codificar un programa y que sólo puede tomar un programador experimentado.</p></li>
<li><p>El lenguaje de programación utilizado es una decisión de diseño que hay que justificar.</p></li>
<li><p>El diseño del algoritmo debería ser independiente del lenguaje de programación en el que se vaya a codificar posteriormente el programa, pero el <em>estilo</em> (paradigma) influye.</p></li>
</ul></section><section class="slide level4">

<ul>
<li><p>Codificación del algoritmo anterior en lenguaje Python:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">def</span> maximo(n1, n2):</a>
<a class="sourceLine" id="cb1-2" title="2">    <span class="co">&quot;&quot;&quot;Calcula el máximo de dos números.&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="cf">if</span> n1 <span class="op">&gt;</span> n2:</a>
<a class="sourceLine" id="cb1-4" title="4">        <span class="cf">return</span> n1</a>
<a class="sourceLine" id="cb1-5" title="5">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb1-6" title="6">        <span class="cf">return</span> n2</a></code></pre></div></li>
<li><p>Codificación en lenguaje Java:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb2-1" title="1"><span class="co">/**</span></a>
<a class="sourceLine" id="cb2-2" title="2"> <span class="co">*</span> Calcula el máximo de dos números.</a>
<a class="sourceLine" id="cb2-3" title="3"> <span class="co">*/</span></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">maximo</span>(<span class="dt">int</span> n1, <span class="dt">int</span> n2) {</a>
<a class="sourceLine" id="cb2-5" title="5">    <span class="kw">if</span> (n1 &gt; n2) {</a>
<a class="sourceLine" id="cb2-6" title="6">        <span class="kw">return</span> n1;</a>
<a class="sourceLine" id="cb2-7" title="7">    } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb2-8" title="8">        <span class="kw">return</span> n2;</a>
<a class="sourceLine" id="cb2-9" title="9">    }</a>
<a class="sourceLine" id="cb2-10" title="10">}</a></code></pre></div></li>
</ul>
</section><section id="traducción-y-ejecución" class="title-slide slide level2"><h2><span class="header-section-number">5.8</span> Traducción y ejecución</h2><ul>
<li><p>Una vez escrito el programa, se procede a su ejecución. Para ello:</p>
<ul>
<li><p>Si el lenguaje es <strong>compilado</strong>: se compila, se genera el código objeto y se ejecuta éste.</p></li>
<li><p>Si el lenguaje es <strong>interpretado</strong>: se ejecuta el código fuente directamente por medio del intérprete del lenguaje.</p></li>
</ul></li>
<li><p>Si durante la compilación (o ejecución, en el caso de un lenguaje interpretado) el traductor muestra <strong>errores en el programa fuente</strong>, es preciso volver a editar el programa, corregir los errores e intentar de nuevo.</p></li>
<li><p>Los errores que un traductor puede detectar son, principalmente:</p>
<ul>
<li>Errores <strong>sintácticos</strong> (por ejemplo, falta o sobra un paréntesis)</li>
<li>Errores <strong>de semántica estática</strong> (por ejemplo, se intenta sumar una cadena a un número, detectable mediante un <strong>chequeo de tipos</strong>)</li>
</ul></li>
</ul></section><section id="actividades-3" class="slide level4">
<h4><span class="header-section-number">5.8.0.1</span> Actividades</h4>
<ol start="4" class="example" type="1">
<li>Desde el punto de vista de la detección de errores sintácticos o de semántica estática, ¿qué resulta más interesante: un compilador o un intérprete? Razona la respuesta.</li>
</ol>
</section><section id="pruebas" class="title-slide slide level2"><h2><span class="header-section-number">5.9</span> Pruebas</h2><ul>
<li><p>Para determinar que el programa funciona correctamente, se determina una <strong>batería de pruebas</strong> que debe superar el mismo para concluir que se comporta como debe.</p></li>
<li><p>Esas baterías de prueba (o <strong>casos de prueba</strong>) consisten en una serie de <strong>datos de entrada</strong> con los que se estimula al programa, emparejados junto a una serie de <strong>resultados esperables</strong> que se comparan con los resultados reales que el programa genera a partir de los datos de entrada.</p></li>
<li><p>Si los generados coinciden con los esperables, se concluye que el programa está funcionando <strong>correctamente</strong>.</p></li>
<li><p>En caso contrario, decimos que el programa <strong>falla</strong> y debemos localizar el error (o errores) que provocan el mal funcionamiento.</p></li>
</ul></section><section class="slide level4">

<ul>
<li><p><strong>Las pruebas pueden detectar la presencia de errores, pero nunca pueden garantizar la ausencia de los mismos.</strong></p></li>
<li><p>La verificación formal es la única forma de garantizar la ausencia de errores en un programa.</p></li>
<li><p>Entonces, ¿por qué hacemos pruebas?</p>
<ul>
<li><p>Para comprobar que no se han <em>colado</em> errores al codificar el algoritmo (aunque hayamos verificado la corrección del algoritmo, se nos puede haber colado un error al codificarlo en el programa).</p></li>
<li><p>A veces, simplemente, no verificamos, y lo único que tenemos son las pruebas.</p></li>
<li><p>También es importante comprobar la <strong>eficiencia</strong> del programa con ejecuciones <em>reales</em>.</p></li>
</ul></li>
</ul>
</section><section id="depuración" class="title-slide slide level2"><h2><span class="header-section-number">5.10</span> Depuración</h2><ul>
<li><p>La <strong>depuración</strong> es el proceso de <strong>encontrar</strong> los errores del programa y <strong>corregir</strong> o eliminar dichos errores.</p></li>
<li><p>En caso de ser <strong>errores sintácticos o de semántica estática</strong>, el traductor facilita mucho la tarea de localizar la posición concreta del mismo en el programa fuente, gracias a los <strong>mensajes de error</strong> que genera durante la compilación o interpretación del programa.</p></li>
<li><p>Si tenemos un <strong>error lógico</strong> (un error en la lógica del programa que provoca que éste produzca resultados incorrectos), normalmente resulta más difícil de localizar.</p></li>
</ul></section><section id="documentación" class="title-slide slide level2"><h2><span class="header-section-number">5.11</span> Documentación</h2><ul>
<li><p>La documentación es el proceso por el cual incorporamos al código fuente del programa de toda la información que pueda ayudar en la comprensión y el mantenimiento del mismo.</p></li>
<li><p>La documentación de un programa puede ser interna o externa:</p>
<ul>
<li><p>La <strong>documentación interna</strong> forma parte del código fuente del programa y se refiere al uso de comentarios, identificadores descriptivos, indentación, reglas de estilo, etc. Todo orientado a ayudar a entender el código cuando lo lea un humano.</p></li>
<li><p>La <strong>documentación externa</strong> va fuera del código fuente e incluye análisis, diagramas de flujo y/o pseudocódigos, manuales de usuario con instrucciones para ejecutar el programa y para interpretar los resultados.</p></li>
</ul></li>
</ul></section><section id="mantenimiento" class="title-slide slide level2"><h2><span class="header-section-number">5.12</span> Mantenimiento</h2><ul>
<li><p>La vida útil de un programa rara vez termina cuando se ha acabado de programar y los usuarios comienzan a usarlo, sino que a partir de ese momento comienza una de las etapas más importantes y probablemente más costosas en tiempo y esfuerzo: el <strong>mantenimiento</strong>.</p></li>
<li><p>Mantener un programa consiste en realizar las acciones encaminadas a:</p>
<ul>
<li><p>Corregir los fallos que puedan aparecer como consecuencia del uso del programa (fallos que no se localizaron previamente en la fase de pruebas).</p></li>
<li><p>Adaptar el programa a nuevas condiciones de utilización (nuevos sistemas operativos, nuevas plataformas <em>hardware</em>…)</p></li>
<li><p>Mejorar el programa incorporando nuevas funcionalidades.</p></li>
</ul></li>
<li><p>Para ello, es fundamental que el programa esté correctamente documentado.</p></li>
</ul></section><section id="ingeniería-del-software" class="title-slide slide level2"><h2><span class="header-section-number">5.13</span> Ingeniería del software</h2><ul>
<li><p>En los años 60, los problemas a resolver son cada vez más complejos y los ordenadores son cada vez más potentes pero los programadores son incapaces de escribir programas que aprovechen esa potencia y que sean fiables.</p></li>
<li><p>Además resulta difícil estimar el presupuesto y el tiempo necesarios para desarrollar programas.</p></li>
<li><p>En 1968, Fiedrich Bauer habla por primera vez de la <strong>crisis del software</strong> en la primera Conferencia sobre Ingeniería del Software de la OTAN en Garmish (Alemania).</p></li>
<li><p>Se llega a la conclusión de que no basta con tener mejores herramientas (lenguajes), sino que hay que dar un enfoque más industrial y sistemático al desarrollo de software.</p></li>
<li><p>Aparece la <strong>ingeniería del software</strong> como disciplina.</p></li>
</ul></section><section class="slide level4">

<ul>
<li><p>La ingeniería del software no considera a la programación como una disciplina científica o como un arte, sino como un proceso sistemático que va más allá de escribir código.</p></li>
<li><p>Cuando el programa a desarrollar es grande, escribir código es sólo una de las tareas que hay que realizar. También hay que:</p>
<ul>
<li><p>Realizar un análisis del sistema.</p></li>
<li><p>Estimar y planificar el tiempo y el esfuerzo necesarios para desarrollar la solución.</p></li>
<li><p>Aplicar procedimientos estandarizados.</p></li>
<li><p>Elaborar documentación.</p></li>
<li><p>Medir la calidad del producto resultante.</p></li>
</ul></li>
<li><p>El desarrollo de software complejo requiere pasar por varias etapas que, juntas, forman lo que se llama el <strong>ciclo de vida</strong> del software.</p></li>
</ul>
</section></section>
<section><section id="entornos-integrados-de-desarrollo" class="title-slide slide level1"><h1><span class="header-section-number">6</span> Entornos integrados de desarrollo</h1></section><section id="definición-5" class="title-slide slide level2"><h2><span class="header-section-number">6.1</span> Definición</h2><ul>
<li><p>Definición:</p>
<div class="caja">
<p>Un <strong>entorno integrado de desarrollo</strong> o <strong>IDE</strong> (del inglés, <em>Integrated Development Environment</em>), es una herramienta <em>software</em> que proporciona servicios que facilitan el desarrollo de software al programador.</p>
</div></li>
<li><p>Está formado por un <strong>editor de textos</strong> donde el programador puede codificar el programa en el lenguaje de programación correspondiente, alrededor del cual pueden orbitar una serie de herramientas satélite, como:</p>
<ul>
<li>Herramientas visuales para la creación de <em>interfaces gráficas de usuario</em></li>
<li>Sistemas de control de versiones</li>
<li>Visor de documentación</li>
<li>Intérpretes interactivos</li>
</ul></li>
</ul></section><section class="slide level4">

<ul>
<li><p>Asimismo, el editor de textos del IDE suele incorporar facilidades que ayudan a escribir código con más comodidad:</p>
<ul>
<li><p>Resaltado de sintaxis</p></li>
<li><p>Autocompletado de código</p></li>
<li><p>Ayudas a la refactorización</p></li>
</ul></li>
<li><p>Los IDE suelen ir asociados a un lenguaje o grupo de lenguajes de programación concreto y, por lo tanto, son herramientas especializadas utilizadas para programar en el lenguaje o lenguajes para los que han sido diseñadas. Por ejemplo:</p>
<ul>
<li><p>PyCharm es un IDE para programar en el lenguaje Python.</p></li>
<li><p>IntelliJ IDEA es un IDE para programar en el lenguaje Java.</p></li>
</ul></li>
</ul>
</section><section id="editores-de-textos" class="title-slide slide level2"><h2><span class="header-section-number">6.2</span> Editores de textos</h2><ul>
<li><p>Un editor de textos, por contra, es una herramienta <em>software</em> que, en principio, sólo cuenta con la posibilidad de editar texto «plano» cuyo contenido puede ser de cualquier tipo (no necesariamente un código fuente).</p></li>
<li><p>Al ser una herramienta general, no dispone de características específicas para escribir programas.</p></li>
<li><p>Los principales editores de textos que podemos encontrar en el mercado son:</p>
<ul>
<li>Vim</li>
<li>Emacs</li>
<li>Atom</li>
<li>Sublime Text</li>
<li>Visual Studio Code</li>
</ul></li>
</ul></section><section id="editores-vs.-ide" class="title-slide slide level3"><h3><span class="header-section-number">6.2.1</span> Editores vs. IDE</h3><ul>
<li><p>Los mejores editores de textos son <strong>extensibles</strong>, es decir, es posible ampliar su funcionalidad por medio de <em>extensiones</em>.</p></li>
<li><p>Esto hace que podamos personalizar su aspecto y funcionalidad hasta crear con ellos un IDE completo y ajustado a nuestras necesidades.</p></li>
<li><p>Gracias a ello, podemos usar el mismo editor de textos tanto para crear documentos de texto genéricos como para escribir programas. Por tanto, sólo tenemos que aprender el manejo de una única herramienta.</p></li>
<li><p>No obstante, los IDE suelen incorporar modos de funcionamiento que <em>imitan</em> a los de los editores de textos más conocidos (como Vim o Emacs).</p></li>
</ul></section><section id="visual-studio-code" class="title-slide slide level3"><h3><span class="header-section-number">6.2.2</span> Visual Studio Code</h3><ul>
<li><p>Es el editor de textos que vamos a usar en clase.</p></li>
<li><p>Es <em>software</em> libre, y por tanto podemos usarlo sin ningún tipo de restricción.</p></li>
<li><p>Además, es extensible y dispone de una enorme cantidad de extensiones que nos van a permitir construirnos nuestro propio IDE para los lenguajes que vamos a usar en clase.</p></li>
</ul></section></section>
<section id="bibliografía" class="title-slide slide level1 unnumbered"><h1>Bibliografía</h1><div id="refs" class="references" role="doc-bibliography">
<div id="ref-aguilar_fundamentos_2008">
<p>Aguilar, Luis Joyanes. 2008. <em>Fundamentos de Programación</em>. Aravaca: McGraw-Hill Interamericana de España.</p>
</div>
<div id="ref-pareja_flores_desarrollo_1997">
<p>Pareja Flores, Cristóbal, Manuel Ojeda Aciego, Ángel Andeyro Quesada, and Carlos Rossi Jiménez. 1997. <em>Desarrollo de Algoritmos Y Técnicas de Programación En Pascal</em>. Madrid: Ra-Ma.</p>
</div>
<div id="ref-van-roy_concepts_2004">
<p>Van-Roy, Peter, and Seif Haridi. 2004. <em>Concepts, Techniques, and Models of Computer Programming</em>. Cambridge, Mass: MIT Press.</p>
</div>
</div></section>
    </div>
  </div>

  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Display the page number of the current slide
        slideNumber: true,
        // Push each slide change to the browser history
        history: true,
        // Transition style
        transition: 'slide', // none/fade/slide/convex/concave/zoom
        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1280,
        height: 1080,

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'reveal.js/plugin/notes/notes.js', async: true },
          { src: 'reveal.js/plugin/reveal.js-menu/menu.js', async: true },
          { src: 'reveal.js/plugin/reveal.js-quiz/quiz/js/quiz.js', async: true, callback: function() { prepareQuizzes({preventUnanswered: true, checkAnswerText: 'Comprueba la respuesta', nextQuestionText: 'Siguiente &raquo;', backButtonText: '&laquo; Anterior', tryAgainText: 'Prueba de nuevo', preventUnansweredText: 'Selecciona una respuesta', questionCountText: 'Pregunta %current de %total', skipStartButton: true}); } },
          { src: 'reveal.js/plugin/reveal-code-focus/vendor/highlight.js/highlight.pack.js' },
          { src: 'reveal.js/plugin/reveal-code-focus/reveal-code-focus.js', async: true, callback: function() { RevealCodeFocus(); } },
          { src: 'reveal.js/plugin/search/search.js', async: true },
          { src: 'reveal.js/plugin/customcontrols/customcontrols.js', async: true }
        ],

        customcontrols: {
          controls: [
            { icon: '<i class="fa fa-question-circle"></i>',
			  css: 'position: fixed; right: 50px; bottom: 50px; z-index: 30; font-size: 24px;',
			  action: 'Reveal.toggleHelp(); return false;'
			}
          ]
        },

        menu: {
          numbers: true,
          hideMissingTitles: true,
          themes: true,
          themesPath: 'reveal.js/css/theme/'
        }
      });
    </script>
    </body>
</html>
