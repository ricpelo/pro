<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Ricardo Pérez López">
  <title>Expresiones</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=1280">
  <link rel="stylesheet" href="./reveal.js/dist/reset.css">
  <link rel="stylesheet" href="./reveal.js/dist/reveal.css">
  <style>
    .reveal .sourceCode {  /* see #7635 */
      overflow: visible;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      { color: #268bd2;  }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #cb4b16; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #d33682; } /* BaseN */
    code span.bu { color: #4070a0; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #dc322f; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #93a1a1; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #6c71c4; } /* DataType */
    code span.dv { color: #d33682; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #d33682; } /* Float */
    code span.fu { color: #4070a0; } /* Function */
    code span.im { font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #268bd2; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #a57800; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #2aa198; } /* SpecialString */
    code span.st { color: #2aa198; } /* String */
    code span.va { color: #6c71c4; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    /* CSS for citations */
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
      margin-bottom: 0em;
    }
    .hanging-indent div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }  </style>
  <link rel="stylesheet" href="./reveal.js/dist/theme/solarized.css" id="theme">
  <link rel="stylesheet" href="custom.css"/>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css" />
  <link href="https://fonts.googleapis.com/css?family=Lato&display=swap" rel="stylesheet">
  <style type="text/css">
      #header-left {
          position: absolute;
          font-size: 25%;
          top: 0%;
          left: 0%;
          margin-left: 10px;
          margin-top: 10px;
      }
      #header-right {
          position: absolute;
          font-size: 25%;
          top: 0%;
          right: 0%;
          margin-right: 10px;
          margin-top: 10px;
      }
      #footer-left {
          position: absolute;
          font-size: 25%;
          bottom: 0%;
          left: 0%;
          margin-left: 10px;
          margin-bottom: 10px;
      }
  </style>
</head>
<body>
<div id="hidden" style="display:none;">
    <div id="header">
        <div id="header-left"></div>
        <div id="header-right"></div>
        <div id="footer-left"></div>
    </div>
</div>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">Expresiones</h1>
  <p class="author">Ricardo Pérez López</p>
  <p class="date">IES Doñana, curso 2025/2026</p>
</section>
<section id="TOC">
<nav role="doc-toc"> 
<ul>
<li><a href="#/elementos-de-un-programa"
id="/toc-elementos-de-un-programa"><span
class="toc-section-number">1</span> Elementos de un programa</a></li>
<li><a href="#/valores" id="/toc-valores"><span
class="toc-section-number">2</span> Valores</a></li>
<li><a href="#/operaciones" id="/toc-operaciones"><span
class="toc-section-number">3</span> Operaciones</a></li>
</ul>
</nav>
</section>

<section>
<section id="elementos-de-un-programa" class="title-slide slide level1"
data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span>
Elementos de un programa</h1>

</section>
<section id="expresiones-y-sentencias" class="title-slide slide level2"
data-number="1.1">
<h2 data-number="1.1"><span class="header-section-number">1.1</span>
Expresiones y sentencias</h2>
<ul>
<li><p>El código fuente de un programa está formado por
<strong>instrucciones</strong>.</p></li>
<li><p>Las instrucciones se clasifican en:</p>
<ul>
<li><p><strong>Expresiones</strong>: son secuencias de símbolos las
cuales <em>representan valores</em> y están formados por <em>datos</em>
y (posiblemente) <em>operaciones</em> a realizar sobre esos datos. El
valor al que representa la expresión se obtiene <em>evaluando</em> dicha
expresión.</p></li>
<li><p><strong>Sentencias</strong>: son <em>órdenes</em> que sirven para
pedirle al intérprete que <em>ejecute</em> una determinada
<em>acción</em>.</p></li>
</ul></li>
<li><p>Las sentencias pueden contener expresiones.</p></li>
<li><p>En muchos lenguajes de programación, una expresión por sí sola
también es una sentencia válida, ya que expresan la orden de calcular el
valor de la expresión.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.1.0.0.1">

<p><span class="math display">\begin{array}{c}
  \text{En un programa hay dos} \\
  \text{clases de instrucciones}
  \end{array}
  \begin{cases}
    \text{\textbf{Expresiones}} \begin{cases}
      \text{- Se evalúan} \\
      \text{- Representan valores} \\
      \text{- Están formadas por} \begin{cases}
        \text{\textbf{Datos}} \\
        \text{\textbf{Operaciones}}
      \end{cases} \\
      \text{- Por sí solas también pueden ser sentencias}
    \end{cases} \\\\
    \text{\textbf{Sentencias}} \begin{cases}
      \text{- Son órdenes que provocan acciones} \\
      \text{- Se ejecutan} \\
      \text{- Pueden contener expresiones}
    \end{cases}
  \end{cases}
</span></p>
<div class="caja centered">
<p>Las <strong>expresiones</strong> se <em>evalúan</em> y denotan un
<em>valor</em>.</p>
<p>Las <strong>sentencias</strong> se <em>ejecutan</em> y provocan una
<em>acción</em>.</p>
</div>
</section>

<section id="sintaxis-y-semántica-de-las-expresiones"
class="title-slide slide level2" data-number="1.2">
<h2 data-number="1.2"><span class="header-section-number">1.2</span>
Sintaxis y semántica de las expresiones</h2>
<div class="caja">
<p><strong>Definición:</strong></p>
<p>Una <strong>expresión</strong> es una frase (secuencia de símbolos)
sintáctica y semánticamente correcta según las reglas del lenguaje que
estamos utilizando, cuya finalidad es la de <em>representar</em> o
<strong>denotar</strong> un determinado objeto abstracto, al que
denominamos el <strong>valor</strong> de la expresión.</p>
</div>
<ul>
<li><p>El ejemplo clásico es el de las <em>expresiones
aritméticas</em>:</p>
<ul>
<li><p>Están formadas por secuencias de números junto con símbolos que
representan operaciones aritméticas a realizar con esos
números.</p></li>
<li><p>Denotan un valor numérico, que es el resultado de calcular el
valor de la expresión tras hacer las operaciones que aparecen en
ella.</p>
<p>Por ejemplo, la expresión <code>(2 * (3 + 5))</code> denota un valor,
que es el número abstracto <strong>dieciséis</strong>.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="1.2.0.0.1">

<ul>
<li><p>La <strong>sintaxis</strong> de las expresiones correctamente
formadas deben satisfacer la gramática del lenguaje en el que están
escritas.</p></li>
<li><p>Si una expresión es sintácticamente correcta, su
<strong>semántica</strong> (es decir, su <em>significado</em>) es
<strong>el valor al que representa</strong>.</p></li>
<li><p>En un lenguaje de programación existen muchos tipos de
expresiones, dependiendo del tipo de los datos y de las operaciones
involucradas en dicha expresión.</p></li>
<li><p>Empezaremos trabajando con las expresiones aritméticas más
sencillas para ir incorporando cada vez más elementos nuevos que nos
permitan crear expresiones más complejas.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.2.0.0.2">

<ul>
<li><p>Para ello, nos basaremos en la siguiente gramática, la cual es
una simplificación modificada de la gramática real que deben satisfacer
las expresiones en Python:</p>
<div class="line-block"><span
style="color:teal">⟨<em>expresión</em>⟩</span> ::= <span
style="color:teal">⟨<em>operación</em>⟩</span> | <span
style="color:teal">⟨<em>literal</em>⟩</span> | <span
style="color:teal">⟨<em>nombre</em>⟩</span><br />
<span style="color:teal">⟨<em>operación</em>⟩</span> ::=
<strong><code>(</code></strong><span
style="color:teal">⟨<em>expresión</em>⟩</span> <span
style="color:teal">⟨<em>operador_binario</em>⟩</span> <span
style="color:teal">⟨<em>expresión</em>⟩</span><strong><code>)</code></strong><br />
                              | <strong><code>(</code></strong><span
style="color:teal">⟨<em>operador_unario</em>⟩</span> <span
style="color:teal">⟨<em>expresión</em>⟩</span><strong><code>)</code></strong><br />
                              | <span
style="color:teal">⟨<em>llamada_función</em>⟩</span> | <span
style="color:teal">⟨<em>llamada_método</em>⟩</span><br />
<span style="color:teal">⟨<em>nombre</em>⟩</span> ::=
<strong><code>identificador</code></strong><br />
<span style="color:teal">⟨<em>literal</em>⟩</span> ::=
<strong><code>entero</code></strong> |
<strong><code>real</code></strong> |
<strong><code>cadena</code></strong> | …<br />
<span style="color:teal">⟨<em>operador_binario</em>⟩</span> ::=
<strong><code>+</code></strong> | <strong><code>-</code></strong> |
<strong><code>*</code></strong> | <strong><code>/</code></strong> |
<strong><code>//</code></strong> | <strong><code>**</code></strong> |
<strong><code>%</code></strong> | …<br />
<span style="color:teal">⟨<em>operador_unario</em>⟩</span> ::=
<strong><code>+</code></strong> | <strong><code>-</code></strong> |
…<br />
<span style="color:teal">⟨<em>llamada_función</em>⟩</span> ::= <span
style="color:teal">⟨<em>función</em>⟩</span><strong><code>(</code></strong>[<span
style="color:teal">⟨<em>lista_argumentos</em>⟩</span>]<strong><code>)</code></strong><br />
<span style="color:teal">⟨<em>función</em>⟩</span> ::=
<strong><code>identificador</code></strong><br />
<span style="color:teal">⟨<em>llamada_método</em>⟩</span> ::= <span
style="color:teal">⟨<em>objeto</em>⟩</span><strong><code>.</code></strong><span
style="color:teal">⟨<em>método</em>⟩</span><strong><code>(</code></strong>[<span
style="color:teal">⟨<em>lista_argumentos</em>⟩</span>]<strong><code>)</code></strong><br />
<span style="color:teal">⟨<em>objeto</em>⟩</span> ::= <span
style="color:teal">⟨<em>expresión</em>⟩</span><br />
<span style="color:teal">⟨<em>método</em>⟩</span> ::=
<strong><code>identificador</code></strong><br />
<span style="color:teal">⟨<em>lista_argumentos</em>⟩</span> ::= <span
style="color:teal">⟨<em>expresión</em>⟩</span>(<strong><code>,</code></strong>
<span style="color:teal">⟨<em>expresión</em>⟩</span>)*</div></li>
</ul>
</section>
<section class="slide level5" data-number="1.2.0.0.3">

<ul>
<li><p>Los símbolos terminales
<strong><code>identificador</code></strong>,
<strong><code>entero</code></strong>, <strong><code>real</code></strong>
y <strong><code>cadena</code></strong> representan cada uno de ellos a
una multitud de secuencias de caracteres que siguen un determinado
patrón.</p></li>
<li><p>A las secuencias de caracteres que se ajustan al patrón léxico de
un símbolo terminal determinado se les denomina
<strong>lexemas</strong>.</p>
<ul>
<li><p>Un <strong><code>identificador</code></strong> es una secuencia
de caracteres que puede estar formada por letras y dígitos, siempre y
cuando empiece por una letra. Los identificadores representan
<em>nombres</em>. Por ej.: <code>x</code>, <code>n1</code> o
<code>dni</code>.</p></li>
<li><p>Un <strong><code>entero</code></strong> es una secuencia de
dígitos sin punto decimal que representa a un número entero. Por ej.:
<code>25</code> o <code>140</code>.</p></li>
<li><p>Un <strong><code>real</code></strong> es una secuencia de dígitos
y otros caracteres especiales (el <strong><code>.</code></strong> o la
<strong><code>e</code></strong>) que representa a un número real. Por
ej.: <code>12.4</code> o <code>4e3</code>.</p></li>
<li><p>Una <strong><code>cadena</code></strong> es una secuencia de
caracteres encerrada entre comillas simples
(<strong><code>'</code></strong>) o dobles
(<strong><code>"</code></strong>). Por ej.: <code>"Hola"</code> o
<code>'Juan Martínez'</code>.</p></li>
</ul></li>
<li><p>Normalmente, los espacios en blanco se usan para separar y
distinguir los diferentes símbolos terminales. Así se sabe que
<code>12</code> representa al entero <code>12</code> y no a los dos
enteros <code>1</code> y <code>2</code>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.2.0.0.4">

<ul>
<li><p>Esta gramática reconoce <strong>expresiones <em>totalmente
parentizadas</em></strong>, en las que cada operación a realizar con
operadores va agrupada entre paréntesis, aunque no sea estrictamente
necesario, como por ejemplo:</p>
<div class="centered">
<p><code>(3 + (4 - 7))</code></p>
</div></li>
<li><p>Otros ejemplos de expresiones que satisfacen dicha gramática:</p>
<ul>
<li><p><code>24</code></p></li>
<li><p><code>(4 + 5)</code></p></li>
<li><p><code>(-(8 * 3.5))</code></p></li>
<li><p><code>(9 * (x - 2))</code></p></li>
<li><p><code>z</code></p></li>
<li><p><code>(abs(-3) + (max(8, 5) / 2))</code></p></li>
</ul></li>
<li><p>Sabemos que todas esas expresiones son sintácticamente correctas
según nuestra gramática porque podemos construir derivaciones desde el
símbolo inicial <span style="color:teal">⟨<em>expresión</em>⟩</span>
hasta cada expresión.</p></li>
</ul>
</section>
<section id="ejercicio" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejercicio</h5>
<ol class="example" type="1">
<li>Obtener las derivaciones correspondientes de cada una de las
expresiones.</li>
</ol>
</section>
<section class="slide level5" data-number="1.2.0.0.5">

<ul>
<li><p>Muchas veces, de ahora en adelante representaremos las
expresiones combinando <strong>distintos colores y estilos
tipográficos</strong> con la única finalidad de facilitar la lectura y
ayudar a reconocer los diferentes elementos sintácticos que las
componen.</p></li>
<li><p>A esta técnica se la denomina <strong>resaltado de
sintaxis</strong>.</p></li>
<li><p>Por ejemplo, las expresiones anteriores quedarían así:</p>
<ul>
<li><p><code
class="sourceCode python">(<span class="dv">3</span> <span class="op">+</span> (<span class="dv">4</span> <span class="op">-</span> <span class="dv">7</span>))</code></p></li>
<li><p><code
class="sourceCode python"><span class="dv">24</span></code></p></li>
<li><p><code
class="sourceCode python">(<span class="dv">4</span> <span class="op">+</span> <span class="dv">5</span>)</code></p></li>
<li><p><code
class="sourceCode python">(<span class="op">-</span>(<span class="dv">8</span> <span class="op">*</span> <span class="fl">3.5</span>))</code></p></li>
<li><p><code
class="sourceCode python">(<span class="dv">9</span> <span class="op">*</span> (x <span class="op">-</span> <span class="dv">2</span>))</code></p></li>
<li><p><code class="sourceCode python">z</code></p></li>
<li><p><code
class="sourceCode python">(<span class="bu">abs</span>(<span class="op">-</span><span class="dv">3</span>) <span class="op">+</span> (<span class="bu">max</span>(<span class="dv">8</span>, <span class="dv">5</span>) <span class="op">/</span> <span class="dv">2</span>))</code></p></li>
</ul></li>
</ul>
</section>
</section>
<section>
<section id="valores" class="title-slide slide level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span>
Valores</h1>

</section>
<section id="información-datos-tipos-y-valores"
class="title-slide slide level2" data-number="2.1">
<h2 data-number="2.1"><span class="header-section-number">2.1</span>
Información, datos, tipos y valores</h2>
<ul>
<li><p>La Informática es la ciencia que estudia los sistemas de
procesamiento automático de la información, también llamados
<em>sistemas informáticos</em>.</p></li>
<li><p>Esos sistemas procesan la información de forma automática
siguiendo las instrucciones de un programa.</p></li>
<li><p>Las instrucciones que forman el programa son las que dictan qué
operaciones hay que realizar con la información.</p></li>
<li><p>Esa información se codifica, almacena y manipula en forma de
<strong>datos</strong>.</p></li>
<li><p>Los datos, por tanto, son información codificada y almacenada en
un formato y en un soporte adecuados para ser manipulados por un sistema
informático.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.1.0.0.1">

<ul>
<li><p>Esos datos pueden ser:</p>
<ul>
<li><p><strong>Datos de entrada o salida</strong>, que representan
información de interés para el usuario del programa y que, o bien se
reciben del usuario o bien se envían al usuario,
respectivamente.</p></li>
<li><p><strong>Datos internos</strong> que usa el programa para su
correcto funcionamiento.</p></li>
</ul></li>
<li><p>El objeto abstracto que representa un dato en un momento dado (es
decir, la información que actualmente «contiene» el dato) se denomina el
<strong>valor</strong> del dato. Se dice que un dato <em>posee</em> (o
<em>tiene</em> o <em>contiene</em>) un <strong>valor</strong>, o que
<em>vale</em> ese valor.</p>
<ul>
<li><p>Si el valor de un dato nunca cambia, decimos que ese dato es
<strong>constante</strong>.</p></li>
<li><p>En cambio, si el valor de un dato puede cambiar durante el
funcionamiento del programa, decimos que es un dato
<strong>variable</strong>.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="2.1.0.0.2">

<ul>
<li><p>Los valores se agrupan en <strong>tipos</strong>, que son
conjuntos de valores que comparten características comunes.</p></li>
<li><p>Entre esas características comunes destacan, principalmente:</p>
<ul>
<li><p>La <strong>codificación</strong> usada para representar esos
valores dentro del ordenador.</p></li>
<li><p>Las <strong>operaciones</strong> que se pueden realizar con esos
valores.</p></li>
<li><p>El hecho de que representan el mismo <strong>concepto</strong>
genérico.</p></li>
</ul></li>
<li><p><strong>Todo <em>valor</em> pertenece a un
<em>tipo</em></strong>. <!-- (y, a veces, a más de
  uno) --></p></li>
<li><p>Como cada tipo es un conjunto de valores, decimos que «<em>un
valor pertenece a un tipo</em>» cuando pertenece a ese conjunto (o sea,
cuando es uno de los elementos de ese conjunto).</p>
<p>Por ejemplo, el tipo <em>entero</em> representa el conjunto de los
números enteros. Todos los números enteros pertenecen al tipo
<em>entero</em>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.1.0.0.3">

<ul>
<li><p>Cada tipo, además, determina qué operaciones se pueden realizar
sobre valores de ese tipo.</p></li>
<li><p>En general, las <strong>operaciones</strong> sólo pueden actuar
sobre valores de determinados tipos.</p>
<p>O dicho de otra forma: esas son las operaciones que tiene sentido
realizar sobre esos valores.</p>
<p>Esto es así porque recordemos que las operaciones actúan como
funciones que están definidas sobre un <strong>dominio</strong>, que es
un subconjunto del <strong>conjunto origen</strong>. Ese conjunto origen
sería, a grandes rasgos, el tipo de los valores sobre los que puede
actuar.</p>
<p>Por ejemplo: sobre un valor de tipo <em>cadena</em> se puede realizar
la operación <em>longitud</em> (pero no la <em>raíz cuadrada</em>), y
sobre dos <em>enteros</em> se pueden realizar las operaciones de
<em>suma</em> y <em>producto</em>. No tiene sentido sumar dos
cadenas.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.1.0.0.4">

<ul>
<li><p>Igualmente, también decimos que <strong>los datos tienen un
<em>tipo</em></strong>, que es el tipo de los valores que puede tener el
dato. Por eso, a los tipos también se les llama <strong>tipos de
datos</strong>.</p>
<p>En cierta forma, el tipo de un dato es como una etiqueta,
característica o atributo que va asociado al dato y que define una
cualidad muy importante del mismo.</p>
<p>Se dice que «<em>un dato <strong>es de</strong> un tipo</em>», o que
«<em>un dato <strong>tiene</strong> un tipo</em>» o que «<em>un dato
<strong>pertenece a</strong> un tipo</em>» cuando ese dato tiene (o
puede tener) un valor de ese tipo.</p></li>
<li><p>Dependiendo del lenguaje de programación utilizado, el tipo de un
dato puede venir definido:</p>
<ul>
<li><p><em>Implícitamente</em>, como <strong>el tipo del valor que tiene
actualmente</strong> el dato.</p></li>
<li><p><em>Explícitamente</em>, asociando el tipo al dato mediante una
instrucción especial llamada <strong>declaración</strong>.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="2.1.0.0.5">

<ul>
<li><p>Como los datos tienen (o representan) valores, <strong>las
operaciones también pueden actuar sobre datos</strong>.</p>
<p>En realidad, lo que hacen las operaciones es actuar sobre los valores
que tienen esos datos.</p></li>
<li><p>Por tanto, también se puede decir que <strong>las operaciones que
se pueden realizar sobre un dato dependen del <em>tipo</em> de ese
dato</strong>.</p></li>
<li><p>Y, por extensión, podemos decir que <strong>un tipo de
datos</strong>:</p>
<ul>
<li><p>es el conjunto de <strong>valores</strong> que puede tomar un
dato de ese tipo, y</p></li>
<li><p>define también el conjunto de <strong>operaciones</strong>
válidas que se pueden realizar sobre datos de ese tipo.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="2.1.0.0.6">

<div class="caja">
<p><strong>Tipo (o tipo de datos):</strong></p>
<p>Es un conjunto de <strong>valores</strong> que, indirectamente,
define también el conjunto de <strong>operaciones</strong> que se pueden
realizar sobre esos valores.</p>
</div>
<div class="caja">
<p><strong>Tipo de un dato:</strong></p>
<p>Es el tipo que tiene ese dato, es decir, una característica o
atributo del dato que define el conjunto de <strong>valores</strong> que
puede tomar ese dato y, en consecuencia, también las
<strong>operaciones</strong> que se pueden realizar sobre ese dato.</p>
</div>
</section>
<section class="slide level5" data-number="2.1.0.0.7">

<ul>
<li><p>Los datos se pueden manipular dentro de un programa haciendo que
formen parte de <strong>expresiones</strong> y evaluando dichas
expresiones.</p></li>
<li><p>El <strong><em>valor</em> de una expresión</strong> se obtiene a
través del valor de los datos que contiene, y podemos manipular esos
datos a través de las <strong>operaciones</strong> que actúan sobre
ellos dentro de la expresión.</p></li>
<li><p>Por extensión, el <strong><em>tipo</em> de una expresión</strong>
es el tipo al que pertenece el valor de esa expresión.</p></li>
</ul>
<div class="caja">
<p><strong>Tipo de una expresión:</strong></p>
<p>Es <strong>el tipo del valor</strong> resultante de
<strong>evaluar</strong> dicha expresión.</p>
</div>
</section>
<section class="slide level5" data-number="2.1.0.0.8">

<div class="centered">
<figure>
<img data-src="images/datos-informacion-tipos-valores.svg" class="plain"
style="width:100.0%"
alt="Relación entre información, datos, valores, tipos y operaciones" />
<figcaption aria-hidden="true">Relación entre información, datos,
valores, tipos y operaciones</figcaption>
</figure>
</div>
</section>
<section id="ejemplo" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejemplo</h5>
<ul>
<li><p>Supongamos que queremos representar en un sistema informático la
edad de una persona.</p></li>
<li><p>Esa información la codificamos en un <strong>dato</strong> al que
llamaremos <em>edad</em>.</p></li>
<li><p>Ese dato <em>edad</em> será un dato <strong>variable</strong>, ya
que la edad de una persona cambia con el tiempo y, por tanto, el valor
que contenga el dato podrá cambiar.</p></li>
<li><p>Por otra parte, la edad de una persona se puede representar
mediante un número entero no negativo (mayor o igual que cero), así que
el dato <em>edad</em> debería contener un valor que sea un número entero
sin signo.</p></li>
<li><p>Por tanto, el <strong>tipo</strong> del dato <em>edad</em> es el
conjunto de los números enteros sin signo y, en consecuencia, el
<strong>valor</strong> del dato <em>edad</em> podría ser cualquiera de
los números que están dentro de ese conjunto.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.1.0.0.9">

<ul>
<li><p>Si, por ejemplo, una determinada persona tiene una edad de 12
años, decimos que el <strong>valor</strong> del <strong>dato</strong>
<em>edad</em> para esa persona es 12, o que <strong>su edad
<em>vale</em> 12</strong> (actualmente).</p></li>
<li><p>Dentro de un año, el valor de ese dato pasará a ser 13.</p></li>
<li><p>Por eso decimos que la edad es un dato
<em>variable</em>.</p></li>
<li><p>En cambio, su fecha de nacimiento es un valor <em>constante</em>,
ya que nunca cambia.</p></li>
<li><p>Recordemos que el tipo de un dato también determina las
<strong>operaciones</strong> que podemos realizar con él, ya que (en
principio) cada operación sólo actúa sobre datos de un determinado
tipo.</p></li>
<li><p>Como el dato <em>edad</em> es un número entero, podemos realizar
operaciones aritméticas sobre él. Por ejemplo, podemos restar la edad al
año actual para averiguar el año de nacimiento de esa persona.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.1.0.0.10">

<ul>
<li><p>Los tipos de un lenguaje de programación tienen un nombre (un
<em>identificador</em>) que los representa.</p></li>
<li><p>En Python, los <strong>tipos de datos básicos</strong> son los
siguientes (entre paréntesis va el nombre que tienen cada uno de esos
tipos en Python):</p>
<ul>
<li><p><strong>Números enteros (<code
class="sourceCode python"><span class="bu">int</span></code>)</strong>:
los números (positivos o negativos) que sólo tienen parte entera, como
el <strong>cuatro</strong> o el <strong>menos tres</strong>.</p>
<p>Se corresponde <em>más o menos</em> con el símbolo matemático <span
class="math inline">\mathbb{Z}</span>, que representa el conjunto de los
números enteros en Matemáticas.</p></li>
<li><p><strong>Números reales (<code
class="sourceCode python"><span class="bu">float</span></code>)</strong>:
los números (positivos o negativos) que tienen parte entera y parte
fraccionaria, como el <strong>siete con cuatro</strong> o el
<strong>menos ocho con diecisiete</strong>.</p>
<p>Se corresponde <em>más o menos</em> con el símbolo matemático <span
class="math inline">\mathbb{R}</span>, que representa el conjunto de los
números reales en Matemáticas.</p></li>
<li><p><strong>Cadenas de caracteres (<code
class="sourceCode python"><span class="bu">str</span></code>)</strong>:
secuencias de caracteres (letras, dígitos, símbolos, etc.), como nombres
de personas, direcciones, o cualquier texto en general.</p></li>
<li><p><strong>Tuplas (<code
class="sourceCode python"><span class="bu">tuple</span></code>)</strong>:
secuencias de valores que pueden pertenecer a distintos tipos.</p></li>
<li><p><strong>Lógicos (<code
class="sourceCode python"><span class="bu">bool</span></code>)</strong>:
sólo contiene dos valores que representan dos posibilidades contrarias,
como <strong>verdadero</strong> o <strong>falso</strong>,
<strong>sí</strong> o <strong>no</strong>, <strong>encendido</strong> o
<strong>apagado</strong>, etc.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="2.1.0.0.11">

<ul>
<li><p>Así, por ejemplo, cuando un dato es un número entero, en Python
decimos que pertenece al tipo <code
class="sourceCode python"><span class="bu">int</span></code>; cuando es
una cadena, decimos que pertenece al tipo <code
class="sourceCode python"><span class="bu">str</span></code>;
etcétera.</p></li>
<li><p>Para indicar que un dato tiene (o pertenece a) un determinado
tipo, se pueden usar distintas notaciones dependiendo del lenguaje
empleado.</p></li>
<li><p>Por ejemplo, si queremos indicar que el dato <em>edad</em> es un
número entero (es decir, que es de tipo entero), se puede representar
así:</p>
<ul>
<li><p>En Matemáticas:</p>
<p><span class="math inline">edad \in \mathbb{Z}</span></p></li>
<li><p>En Teoría de tipos:</p>
<p><span class="math inline">edad: \mathbb{Z}</span></p></li>
<li><p>En Python:</p>
<p><span class="math inline">edad</span><code>:</code>
<code>int</code></p></li>
<li><p>En Java:</p>
<p><code>int</code> <span class="math inline">\,edad</span></p></li>
</ul></li>
</ul>
</section>

<section id="evaluación-de-expresiones" class="title-slide slide level2"
data-number="2.2">
<h2 data-number="2.2"><span class="header-section-number">2.2</span>
Evaluación de expresiones</h2>
<ul>
<li><p><strong><em>Evaluar</em> una expresión</strong> consiste en
determinar el <strong><em>valor</em> de la expresión</strong>. Es decir,
una expresión <em>representa</em> o <strong>denota</strong> el valor que
se obtiene al evaluarla.</p></li>
<li><p>El <strong>tipo de la expresión</strong> es el tipo del valor de
esa expresión.</p></li>
<li><p>Una <strong><em>subexpresión</em></strong> es una expresión
contenida dentro de otra.</p></li>
<li><p>La <strong>evaluación de una expresión</strong>, en esencia, es
el proceso de <strong>sustituir</strong> (o
<strong><em>reescribir</em></strong>), dentro de ella, unas
<em>subexpresiones</em> por otras que, según indiquen ciertas reglas,
estén <em>más cerca</em> del valor final a calcular, y así hasta
calcular el <strong>valor</strong> de la expresión al completo.</p></li>
<li><p>Al mismo tiempo, también se va calculando el
<strong>tipo</strong> de sus <em>subexpresiones</em> (el tipo del valor
de cada <em>subexpresión</em>) y, finalmente, se obtiene el tipo de la
propia expresión, que será el tipo del valor de esa expresión.</p></li>
<li><p>Además de las expresiones existen las <em>sentencias</em>, que no
poseen ningún valor y que, por tanto, no se evalúan sino que se
<em>ejecutan</em>. Las sentencias son básicas en los paradigmas
<em>imperativos</em>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.2.0.0.1">

<ul>
<li><p>Podemos decir que las expresiones:</p>
<p><code class="sourceCode python"><span class="dv">3</span></code></p>
<p><code
class="sourceCode python">(<span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span>)</code></p>
<p><code
class="sourceCode python">(<span class="dv">5</span> <span class="op">-</span> <span class="dv">2</span>)</code></p>
<p>denotan todas el mismo <strong>valor</strong> (el número abstracto
<strong>tres</strong>, cuyo <strong>tipo</strong> es el conjunto de los
<em>números enteros</em>).</p></li>
<li><p>Es decir: todas esas expresiones son representaciones diferentes
del mismo ente abstracto.</p></li>
<li><p>Cuando introducimos una expresión en el intérprete, lo que hace
éste es buscar <strong>la representación más simplificada o
reducida</strong> posible.</p>
<p>En el ejemplo anterior, sería la expresión <code
class="sourceCode python"><span class="dv">3</span></code>.</p></li>
<li><p>Por eso a menudo usamos, indistintamente, los términos
<em>reducir</em>, <em>simplificar</em> y <em>evaluar</em>.</p></li>
</ul>
</section>

<section id="expresión-canónica-y-forma-normal"
class="title-slide slide level2" data-number="2.3">
<h2 data-number="2.3"><span class="header-section-number">2.3</span>
Expresión canónica y forma normal</h2>
<ul>
<li><p>Los ordenadores no manipulan valores, sino que sólo pueden
manejar representaciones concretas de los mismos.</p></li>
<li><p>Por ejemplo: utilizan la codificación binaria en complemento a
dos para representar los números enteros.</p></li>
<li><p>Pedimos que la <strong>representación del valor</strong>
resultado de una evaluación sea <strong>única</strong>.</p></li>
<li><p>De esta forma, seleccionaremos de cada conjunto de expresiones
que denoten el mismo valor, a lo sumo una que llamaremos
<strong>expresión canónica de ese valor</strong>.</p></li>
<li><p>Además, llamaremos a la expresión canónica que representa el
valor de una expresión la <strong>forma normal de esa
expresión</strong>.</p></li>
<li><p>Con esta restricción pueden quedar expresiones sin forma
normal.</p></li>
</ul>
</section>
<section id="recuerda" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Recuerda</h5>
<div class="caja">
<p>Se dice:</p>
<ul>
<li><p><strong>Expresión canónica <em>de un
valor</em></strong>.</p></li>
<li><p><strong>Forma normal <em>de una expresión</em></strong>.</p></li>
</ul>
</div>
</section>
<section id="ejemplo-1" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejemplo</h5>
<ul>
<li><p>De las expresiones anteriores:</p>
<p><code class="sourceCode python"><span class="dv">3</span></code></p>
<p><code
class="sourceCode python">(<span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span>)</code></p>
<p><code
class="sourceCode python">(<span class="dv">5</span> <span class="op">-</span> <span class="dv">2</span>)</code></p>
<p>que denotan todas el mismo valor abstracto <strong>tres</strong>,
seleccionamos una (la expresión <code
class="sourceCode python"><span class="dv">3</span></code>) como la
<strong>expresión canónica</strong> de ese valor.</p></li>
<li><p>Igualmente, la expresión <code
class="sourceCode python"><span class="dv">3</span></code> es la
<strong>forma normal</strong> de todas las expresiones anteriores (y de
cualquier otra expresión con valor <strong>tres</strong>).</p></li>
<li><p>Es importante no confundir el valor abstracto
<strong>tres</strong> con la expresión <code
class="sourceCode python"><span class="dv">3</span></code> que
representa dicho valor.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.3.0.0.1">

<ul>
<li><p>Hay <strong>valores que no tienen expresión
canónica</strong>:</p>
<ul>
<li><p>Las funciones (los valores de tipo <em>función</em>).</p></li>
<li><p>El número <span class="math inline">\pi</span> no tiene
representación decimal finita, por lo que tampoco tiene expresión
canónica.</p></li>
</ul></li>
<li><p>Y hay <strong>expresiones que no tienen forma
normal</strong>:</p>
<ul>
<li><p>Si definimos <span class="math inline">inf = inf + 1</span>, la
expresión <span class="math inline">inf</span> (que es un número) no
tiene forma normal.</p></li>
<li><p>Lo mismo ocurre con <span
class="math inline">1\over0</span>.</p></li>
</ul></li>
</ul>
</section>

<section id="formas-normales-y-evaluación"
class="title-slide slide level2" data-number="2.4">
<h2 data-number="2.4"><span class="header-section-number">2.4</span>
Formas normales y evaluación</h2>
<ul>
<li><p>Según lo visto hasta ahora, la evaluación de una expresión es el
proceso de encontrar su forma normal.</p></li>
<li><p>Para ello, el intérprete evalúa la expresión reduciendo sus
subexpresiones según las reglas del lenguaje y las operaciones que
aparecen en ellas, buscando su forma normal.</p></li>
<li><p>El sistema de evaluación dentro del intérprete está hecho de tal
forma que cuando ya no es posible reducir más la expresión es porque se
ha llegado a la forma normal.</p></li>
<li><p>Recordemos que no todos los valores tienen forma normal.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.4.0.0.1">

<ul>
<li><p>El orden en el que se van reduciendo las subexpresiones no
debería influir en el resultado de evaluar una expresión, así que
debería dar igual elegir una u otra subexpresión.</p></li>
<li><p>De todas formas, los lenguajes de programación suelen imponer un
orden concreto a la hora de evaluar las expresiones.</p></li>
<li><p>Tanto en Python como en Java (los dos lenguajes que veremos), el
orden de evaluación es de izquierda a derecha (salvo excepciones):</p>
<div class="caja">
<p><strong>Orden de evaluación de las expresiones:</strong></p>
<p>Al evaluar una expresión, las subexpresiones que la forman siempre se
evaluarán <strong>de izquierda a derecha</strong>.</p>
</div></li>
<li><p>El orden de evaluación de las subexpresiones es un asunto más
complejo de lo que parece, y lo estudiaremos en profundidad en
posteriores apartados.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.4.0.0.2">

<div class="centered">
<figure>
<img data-src="images/evaluacion.svg" class="plain" style="width:40.0%"
alt="Evaluación de una expresión" />
<figcaption aria-hidden="true">Evaluación de una expresión</figcaption>
</figure>
</div>
</section>
<section id="ejemplos" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejemplos</h5>
<ul>
<li><p>Evaluar la expresión <code
class="sourceCode python">(<span class="dv">2</span> <span class="op">+</span> <span class="dv">3</span>)</code>:</p>
<ul>
<li><p>La expresión está formada por un operador <code>+</code> que
actúa sobre las dos subexpresiones <code
class="sourceCode python"><span class="dv">2</span></code> y <code
class="sourceCode python"><span class="dv">3</span></code>. Por tanto,
habrá que evaluar primero esas dos subexpresiones, siempre de izquierda
a derecha:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(<span class="dv">2</span> <span class="op">+</span> <span class="dv">3</span>)             <span class="co"># se evalúa primero 2 (que devuelve 2)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">2</span> <span class="op">+</span> <span class="dv">3</span>)           <span class="co"># luego se evalúa 3 (que devuelve 3)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">2</span> <span class="op">+</span> <span class="dv">3</span>)           <span class="co"># ahora se evalúa (2 + 3) (que devuelve 5)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">5</span></span></code></pre></div>
<p>El <code>+</code> por sí solo no se evalúa, ya que no es una
expresión válida.</p></li>
</ul></li>
<li><p>Por tanto, la expresión <code
class="sourceCode python"><span class="dv">5</span></code> es la
<em>forma normal</em> de la expresión <code
class="sourceCode python">(<span class="dv">2</span> <span class="op">+</span> <span class="dv">3</span>)</code>,
y ambas representan al valor <strong>cinco</strong>, que es un valor de
<strong>tipo <em>entero</em></strong>.</p></li>
<li><p>Asimismo, decimos que <code
class="sourceCode python"><span class="dv">5</span></code> es la
<em>expresión canónica</em> del valor <strong>cinco</strong>, de
<strong>tipo <em>entero</em></strong> (es la expresión que mejor
representa a ese valor).</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.4.0.0.3">

<ul>
<li><p>Evaluar la expresión <code
class="sourceCode python">(<span class="dv">2</span> <span class="op">+</span> (<span class="dv">3</span> <span class="op">*</span> <span class="dv">5</span>))</code>:</p>
<ul>
<li><p>La expresión está formada por un operador <code>+</code> que
actúa sobre las dos subexpresiones <code
class="sourceCode python"><span class="dv">2</span></code> y <code
class="sourceCode python">(<span class="dv">3</span> <span class="op">*</span> <span class="dv">5</span>)</code>.</p></li>
<li><p>La segunda subexpresión, a su vez, está formada por un operador
<code>*</code> que actúa sobre las dos subexpresiones <code
class="sourceCode python"><span class="dv">3</span></code> y <code
class="sourceCode python"><span class="dv">5</span></code>.</p></li>
<li><p>Todas las subexpresiones se evalúan siempre de izquierda a
derecha, a medida que se van reduciendo:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>(<span class="dv">2</span> <span class="op">+</span> (<span class="dv">3</span> <span class="op">*</span> <span class="dv">5</span>))       <span class="co"># se evalúa primero 2 (que devuelve 2)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">2</span> <span class="op">+</span> (<span class="dv">3</span> <span class="op">*</span> <span class="dv">5</span>))     <span class="co"># se evalúa 3 (que devuelve 3)</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">2</span> <span class="op">+</span> (<span class="dv">3</span> <span class="op">*</span> <span class="dv">5</span>))     <span class="co"># se evalúa 5 (que devuelve 5)</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">2</span> <span class="op">+</span> (<span class="dv">3</span> <span class="op">*</span> <span class="dv">5</span>))     <span class="co"># se evalúa (3 * 5) (que devuelve 15)</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">2</span> <span class="op">+</span> <span class="dv">15</span>)          <span class="co"># se evalúa (2 + 15) (que devuelve 17)</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">17</span></span></code></pre></div></li>
</ul></li>
<li><p>Por tanto, la expresión <code
class="sourceCode python"><span class="dv">17</span></code> es la
<em>forma normal</em> de la expresión <code
class="sourceCode python">(<span class="dv">2</span> <span class="op">+</span> (<span class="dv">3</span> <span class="op">*</span> <span class="dv">5</span>))</code>.
Ambas representan al valor <strong>diecisiete</strong>, que es un valor
de <strong>tipo <em>entero</em></strong>, pero <code
class="sourceCode python"><span class="dv">17</span></code> es la
<em>expresión canónica</em> de ese valor.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.4.0.0.4">

<ul>
<li><p>Evaluar la expresión <code
class="sourceCode python">((<span class="dv">2</span> <span class="op">+</span> <span class="dv">5</span>) <span class="op">*</span> <span class="dv">3</span>)</code>:</p>
<ul>
<li><p>La expresión está formada por un operador <code>*</code> que
actúa sobre las dos subexpresiones <code
class="sourceCode python">(<span class="dv">2</span> <span class="op">+</span> <span class="dv">5</span>)</code>
y <code
class="sourceCode python"><span class="dv">3</span></code>.</p></li>
<li><p>La primera subexpresión, a su vez, está formada por un operador
<code>+</code> que actúa sobre las dos subexpresiones <code
class="sourceCode python"><span class="dv">2</span></code> y <code
class="sourceCode python"><span class="dv">5</span></code>.</p></li>
<li><p>Todas las subexpresiones se evalúan siempre de izquierda a
derecha, a medida que se van reduciendo:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>((<span class="dv">2</span> <span class="op">+</span> <span class="dv">5</span>) <span class="op">*</span> <span class="dv">3</span>)       <span class="co"># se evalúa primero 2 (que devuelve 2)</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> ((<span class="dv">2</span> <span class="op">+</span> <span class="dv">5</span>) <span class="op">*</span> <span class="dv">3</span>)     <span class="co"># se evalúa 5 (que devuelve 5)</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> ((<span class="dv">2</span> <span class="op">+</span> <span class="dv">5</span>) <span class="op">*</span> <span class="dv">3</span>)     <span class="co"># se evalúa (2 + 5) (que devuelve 7)</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">7</span> <span class="op">*</span> <span class="dv">3</span>)           <span class="co"># se evalúa 3 (que devuelve 3)</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">7</span> <span class="op">*</span> <span class="dv">3</span>)           <span class="co"># se evalúa (7 * 3) (que devuelve 21)</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">21</span></span></code></pre></div></li>
</ul></li>
<li><p>Por tanto, la expresión <code
class="sourceCode python"><span class="dv">21</span></code> es la
<em>forma normal</em> de la expresión <code
class="sourceCode python">((<span class="dv">2</span> <span class="op">+</span> <span class="dv">5</span>) <span class="op">*</span> <span class="dv">3</span>)</code>.
Ambas representan al valor <strong>veintiuno</strong>, que es un valor
de <strong>tipo <em>entero</em></strong>, pero <code
class="sourceCode python"><span class="dv">21</span></code> es la
<em>expresión canónica</em> de ese valor.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.4.0.0.5">

<ul>
<li><p>De ahora en adelante, para simplificar las explicaciones,
<strong>a menudo usaremos la expresión canónica de un valor como si
fuera el valor mismo</strong>, cuando ya sabemos que, en realidad, no
son lo mismo.</p></li>
<li><p>Por ejemplo: diremos «<em>el valor <code
class="sourceCode python"><span class="dv">21</span></code></em>»
cuando, en realidad, <code
class="sourceCode python"><span class="dv">21</span></code> no es el
propio valor <strong>veintiuno</strong>, sino una expresión que
<em>representa</em> al valor <strong>veintiuno</strong>.</p></li>
<li><p>Esto lo haremos en contextos donde no haya confusión, y siempre
entendiendo que cuando decimos «<em>el valor <code
class="sourceCode python"><span class="dv">21</span></code></em>» nos
referimos al valor que representa la expresión <code
class="sourceCode python"><span class="dv">21</span></code>.</p></li>
</ul>
</section>

<section id="literales" class="title-slide slide level2"
data-number="2.5">
<h2 data-number="2.5"><span class="header-section-number">2.5</span>
Literales</h2>
<ul>
<li><p>Los literales constituyen <strong>las expresiones más
sencillas</strong> del lenguaje.</p></li>
<li><p>Un literal es una expresión simple que denota <strong>un valor
concreto, constante y fijo</strong>, escrito directamente en la
expresión y ya totalmente reducido (o casi) a su expresión
canónica.</p></li>
<li><p>Los literales tienen que satisfacer las <strong>reglas
léxicas</strong> del lenguaje, que son las que determinan qué forma
pueden tener los componentes léxicos del programa (como números,
cadenas, identificadores, etc.).</p>
<p>Esos componentes léxicos son los <em>símbolos terminales</em> de la
gramática del lenguaje.</p></li>
<li><p>Gracias a esas reglas, el intérprete puede identificar qué
literales son, qué <strong>valor</strong> representan y de qué
<strong>tipo</strong> son.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.5.0.0.1">

<ul>
<li><p>Ejemplos de distintos tipos de literales:</p>
<table style="width:99%;">
<colgroup>
<col style="width: 31%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th style="text-align: center;">Números enteros (tipo
<code>int</code>)</th>
<th style="text-align: center;">Números reales<br />
(tipo <code>float</code>)</th>
<th style="text-align: center;">Cadenas<br />
(tipo <code>str</code>)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code
class="sourceCode python"><span class="op">-</span><span class="dv">2</span></code></td>
<td style="text-align: center;"><code
class="sourceCode python"><span class="fl">3.5</span></code></td>
<td style="text-align: center;"><code
class="sourceCode python"><span class="st">&quot;hola&quot;</span></code></td>
</tr>
<tr>
<td style="text-align: center;"><code
class="sourceCode python"><span class="op">-</span><span class="dv">1</span></code></td>
<td style="text-align: center;"><code
class="sourceCode python"><span class="op">-</span><span class="fl">2.7</span></code></td>
<td style="text-align: center;"><code
class="sourceCode python"><span class="st">&#39;pepe&#39;</span></code></td>
</tr>
<tr>
<td style="text-align: center;"><code
class="sourceCode python"><span class="dv">0</span></code></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><code
class="sourceCode python"><span class="st">&quot;25&quot;</span></code></td>
</tr>
<tr>
<td style="text-align: center;"><code
class="sourceCode python"><span class="dv">1</span></code></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><code
class="sourceCode python"><span class="st">&quot;&quot;</span></code></td>
</tr>
<tr>
<td style="text-align: center;"><code
class="sourceCode python"><span class="dv">2</span></code></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table></li>
<li><p>Algunas reglas léxicas son:</p>
<ul>
<li><p>Si el número tiene un <code>.</code> decimal, es que es un número
real.</p></li>
<li><p>Si algo va entre comillas (simples <code>'</code> o dobles
<code>"</code>) es que es una cadena.</p></li>
</ul></li>
<li><p>En apartados posteriores estudiaremos los tipos de datos con más
profundidad.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.5.0.0.2">

<ul>
<li><p>Con frecuencia, un literal resulta ser la <em>expresión
canónica</em> del valor al que denotan y la forma normal de todas las
posibles expresiones que denotan ese valor.</p></li>
<li><p>Por consiguiente, suelen estar ya totalmente
simplificados.</p></li>
<li><p>Por ejemplo, el <code
class="sourceCode python"><span class="fl">3.5</span></code> es un
literal que denota el valor numérico <strong>tres y medio</strong>, es
su expresión canónica y es la forma normal de cualquier expresión que
denote dicho valor.</p></li>
<li><p>Por tanto, el literal <code
class="sourceCode python"><span class="fl">3.5</span></code> es la forma
más reducida de representar el valor <strong>tres y
medio</strong>.</p></li>
<li><p>Es decir: si le pedimos al intérprete que calcule el resultado de
<code
class="sourceCode python"><span class="dv">7</span> <span class="op">/</span> <span class="dv">2</span></code>,
nos devolverá la expresión <code
class="sourceCode python"><span class="fl">3.5</span></code>.</p></li>
<li><p>Sin embargo, el <code
class="sourceCode python"><span class="fl">3.5</span></code> no es el
único literal que denota el valor numérico <strong>tres y
medio</strong>. Por ejemplo, los literales <code
class="sourceCode python"><span class="fl">3.50</span></code>, <code
class="sourceCode python"><span class="fl">3.500</span></code> o <code
class="sourceCode python"><span class="fl">03.50</span></code> también
denotan ese mismo valor, pero la forma normal de todos ellos es <code
class="sourceCode python"><span class="fl">3.5</span></code>.</p></li>
<li><p>O sea: hay varias maneras de escribir un literal que denote el
valor <strong>tres y medio</strong>, pero sólo el literal <code
class="sourceCode python"><span class="fl">3.5</span></code> es la forma
normal de todas ellas.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.5.0.0.3">

<ul>
<li><p>Igualmente, la forma normal de todas las posibles expresiones que
denotan el valor numérico <strong>dos</strong> es el literal <code
class="sourceCode python"><span class="dv">2</span></code>.</p></li>
<li><p>El literal <code
class="sourceCode python"><span class="dv">2</span></code> es la forma
más reducida de representar el valor <strong>dos</strong>.</p></li>
<li><p>Pero no es el único literal que denota dicho valor.</p></li>
<li><p>El literal <code class="sourceCode python">02</code> no es
correcto según las reglas léxicas del lenguaje, pero sí que podemos usar
la expresión <code
class="sourceCode python"><span class="bn">0b10</span></code>, que es un
literal que representa el valor <strong>dos</strong> escrito en
binario.</p></li>
<li><p>Igualmente, las reglas léxicas del lenguaje permiten usar el
carácter <code>_</code> dentro de un número, por lo que el valor
numérico <strong>cuatro millones</strong> se puede representar con el
literal <code
class="sourceCode python"><span class="dv">4_000_000</span></code>, si
bien su forma normal sigue siendo simplemente <code
class="sourceCode python"><span class="dv">4000000</span></code>.</p></li>
<li><p>Finalmente, las cadenas se pueden escribir con comillas simples
(<code>'</code>) o dobles (<code>"</code>), pero la forma normal de una
cadena siempre usa las simples (salvo que la propia cadena incluya una
comilla simple como un carácter más, en cuyo caso se usarán las comillas
dobles en su forma normal).</p></li>
</ul>
</section>

<section id="identificadores" class="title-slide slide level2"
data-number="2.6">
<h2 data-number="2.6"><span class="header-section-number">2.6</span>
Identificadores</h2>
<ul>
<li><p>Los <strong>identificadores</strong> son nombres que representan
elementos dentro de un programa.</p></li>
<li><p>Por ejemplo, el nombre de una función es un identificador porque
representa a la función.</p></li>
<li><p>Los identificadores <strong>deben cumplir unas <em>reglas
léxicas</em></strong> que dependen del lenguaje de programación, pero
generalmente se resumen en que:</p>
<ul>
<li><p>Pueden estar formados por combinaciones de
<strong>letras</strong>, <strong>dígitos</strong> y algunos
<strong>caracteres especiales</strong> como <code>_</code> (por ejemplo,
<code>salida_principal23</code>).</p></li>
<li><p><strong>No pueden empezar con un dígito</strong>, ya que eso los
confundiría con un número (por ejemplo, <code>9abc</code>).</p></li>
<li><p>La mayoría de los lenguajes <strong>distinguen las mayúsculas de
las minúsculas</strong>, por lo que <code>cantidad</code>,
<code>Cantidad</code> y <code>CANTIDAD</code> son normalmente
identificadores distintos (así ocurre en Python y Java).</p></li>
</ul></li>
</ul>
</section>
</section>
<section>
<section id="operaciones" class="title-slide slide level1"
data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span>
Operaciones</h1>

</section>
<section id="clasificación" class="title-slide slide level2"
data-number="3.1">
<h2 data-number="3.1"><span class="header-section-number">3.1</span>
Clasificación</h2>
<ul>
<li><p>Ya hemos visto que en una expresión puede haber:</p>
<ul>
<li><p><strong>Datos</strong> (constantes o variables).</p></li>
<li><p><strong>Operaciones</strong> a realizar sobre esos
datos.</p></li>
</ul></li>
<li><p>A su vez, las operaciones pueden aparecer en forma de:</p>
<ul>
<li><p>Operadores</p></li>
<li><p>Funciones</p></li>
<li><p>Métodos</p></li>
</ul></li>
</ul>
<p><span class="math display">
\text{En una expresión hay}
\begin{cases}
\text{Datos} \begin{cases}
              \text{Constantes} \\
              \text{Variables}
             \end{cases} \\
\text{Operaciones} \begin{cases}
                    \text{Operadores} \\
                    \text{Funciones} \\
                    \text{Métodos}
                   \end{cases}
\end{cases}
</span></p>
</section>
<section class="slide level5" data-number="3.1.0.0.1">

<div class="columns">
<div class="column">
<ul>
<li><p>Matemáticamente, una <strong>operación</strong> se corresponde
con el concepto de <em>función</em>.</p></li>
<li><p>En Matemáticas, una <strong>función</strong> es una regla que
<strong>asocia</strong> a cada elemento de un conjunto (el
<strong>dominio</strong>) <strong>exactamente un elemento</strong> (ni
más ni menos) de un segundo conjunto (el <strong>codominio</strong> o
<strong>rango</strong>).</p></li>
<li><p>A su vez, las funciones están definidas sobre un <strong>conjunto
origen</strong> y un <strong>conjunto imagen</strong>.</p></li>
</ul>
</div><div class="column">
<div class="centered">
<figure>
<img data-src="images/funcion.svg" class="plain" style="width:80.0%"
alt="Función matemática que asocia a cada polígono con su número de lados" />
<figcaption aria-hidden="true">Función matemática que asocia a cada
polígono con su número de lados</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section class="slide level5" data-number="3.1.0.0.2">

<ul>
<li><p>En Programación, el concepto de <em>operación</em> es también
similar al de <em>función matemática</em>, pero con su propia
terminología y funcionamiento.</p></li>
<li><p>Desde el punto de vista de la Programación, las operaciones son
dispositivos que <strong>transforman datos de <em>entrada</em> en datos
de <em>salida</em></strong>:</p>
<div class="centered">
<p><img data-src="images/operacion-dispositivo.svg" class="plain"
style="width:50.0%" /></p>
</div></li>
<li><p>Esos datos de entrada se denominan <strong>argumentos</strong> u
<strong>operandos</strong>, según la forma de la operación.</p></li>
<li><p>Asimismo, los datos de salida representan el
<strong>resultado</strong> o <strong>valor de retorno</strong> de la
operación.</p></li>
<li><p>El valor de retorno se calcula como resultado de procesar los
datos de entrada y, por tanto, depende de la operación a realizar y de
los datos recibidos por la entrada.</p></li>
<li><p>Visto así, las operaciones son <strong>subprogramas</strong>, es
decir, porciones de código que actúan como pequeños programas dentro de
otros programas, ya que siguen el esquema de «<em>entrada - proceso -
salida</em>» como cualquier programa.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.1.0.0.3">

<ul>
<li><p>Los operadores, las funciones y los métodos no son más que
<strong>diferentes <em>formas sintácticas</em></strong> de expresar una
operación.</p></li>
<li><p>En la práctica, apenas hay diferencias sustanciales entre las
tres formas.</p></li>
<li><p>Por ejemplo, la operación «cuadrado» actúa asociando cada número
real con otro número real: el cuadrado del número (el número
multiplicado por sí mismo).</p></li>
<li><p>Así, esa operación asocia el número <span
class="math inline">4</span> con el <span class="math inline">16</span>,
y el <span class="math inline">7</span> con el <span
class="math inline">49</span>.</p></li>
<li><p>Aquí, tanto el dominio como el codominio de la operación serían
<span class="math inline">\mathbb{R}</span>, el conjunto de los números
reales.</p></li>
<li><p>Por tanto, podemos definirla diciendo que es una función que
asocia <span class="math inline">\mathbb{R}</span> (su <em>conjunto
origen</em>) con <span class="math inline">\mathbb{R}</span> (su
<em>conjunto imagen</em>), lo que se puede representar así: <span
class="math display">cuadrado: \mathbb{R} \longrightarrow
\mathbb{R}</span></p></li>
</ul>
</section>
<section class="slide level5" data-number="3.1.0.0.4">

<ul>
<li><p>Otro ejemplo sería la operación «inverso», que asocia a cada
número real otro número real: el inverso del número (<span
class="math inline">1</span> dividido entre el número).</p></li>
<li><p>Así, esa operación asocia el número <span
class="math inline">4</span> con el <span
class="math inline">0.25</span> (<span
class="math inline">\frac{1}{4}</span>) y el <span
class="math inline">5</span> con <span class="math inline">0.2</span>
(<span class="math inline">\frac{1}{5}</span>).</p></li>
<li><p>El conjunto origen y el conjunto imagen siguen siendo <span
class="math inline">\mathbb{R}</span>.</p></li>
<li><p>Pero, en este caso, el dominio no coincide con el conjunto
origen, ya que no existe el inverso del número <span
class="math inline">0</span> (<span
class="math inline">\frac{1}{0}</span>) («inverso» es una operación
<em>parcial</em>). Por tanto, el conjunto origen podrá ser <span
class="math inline">\mathbb{R}</span> pero su dominio deberá excluir al
cero: <span class="math display">\textrm{dom}(inverso) = \mathbb{R}
\setminus
\{0\}</span></p>
<p>(En cambio, el conjunto imagen sí coincide con el
codominio.)</p></li>
<li><p>En consecuencia, podemos definir la función de la siguiente
manera: <span class="math display">inverso: \mathbb{R} \longrightarrow
\mathbb{R}</span></p>
<p>sabiendo que el dominio de la función no contiene a todo el conjunto
origen (el cero no está).</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.1.0.0.5">

<ul>
<li><p>Otro ejemplo sería la operación «suma», que asocia a cada pareja
de números reales otro número real: la suma de ambos.</p></li>
<li><p>Esa operación asocia, por ejemplo, los números <span
class="math inline">2</span> y <span class="math inline">3</span> con el
número <span class="math inline">5</span>.</p></li>
<li><p>En este caso, el dominio de la operación «suma» sería el producto
cartesiano del conjunto de los números reales consigo mismo (es decir,
el conjunto <span class="math inline">\mathbb{R} \times
\mathbb{R}</span> formado por parejas de números reales).</p></li>
<li><p>Por tanto, podemos definir la operación «suma» diciendo que es
una operación que asocia <span class="math inline">\mathbb{R} \times
\mathbb{R}</span> (su conjunto origen) con <span
class="math inline">\mathbb{R}</span> (su conjunto imagen), lo que se
puede representar así: <span class="math display">suma:
\mathbb{R} \times \mathbb{R} \longrightarrow \mathbb{R}</span></p></li>
</ul>
<!--

- Esa operación puede tener forma de operador (el símbolo $+$) o de función:

  ::: centered
    $3 + 4$ devuelve $7$
  :::

  ::: centered
    $suma(3, 4)$ devuelve $7$
  :::

-->
</section>
<section class="slide level5" data-number="3.1.0.0.6">

<ul>
<li><p>En Programación, las operaciones no se definen sobre conjuntos,
sino sobre <strong>tipos</strong>.</p></li>
<li><p>Por ejemplo, la operación «suma» podría definirse sobre sobre el
tipo <code
class="sourceCode python"><span class="bu">float</span></code> de
Python, que es el más parecido al conjunto <span
class="math inline">\mathbb{R}</span> de los números reales.</p></li>
<li><p>Eso se podría representar así:</p>
<div class="centered">
<p><span class="math inline">suma:</span> <code>float</code> <span
class="math inline">\times</span> <code>float</code> <span
class="math inline">\longrightarrow</span> <code>float</code></p>
</div>
<p>Pero, en la práctica, usaremos una notación más apropiada para
representar los tipos sobre los que se definen las operaciones en
nuestros programas y nuestros lenguajes de programación.</p></li>
<li><p>Esa notación, llamada <em>signatura</em>, la estudiaremos en
breve.</p></li>
</ul>
</section>

<section id="operadores" class="title-slide slide level2"
data-number="3.2">
<h2 data-number="3.2"><span class="header-section-number">3.2</span>
Operadores</h2>
<ul>
<li><p>Un <strong>operador</strong> es un símbolo o palabra clave que
representa una <em>operación</em> a realizar sobre unos
<em>datos</em>.</p></li>
<li><p>Los datos sobre los que actúa un operador se denominan
<strong>operandos</strong>.</p></li>
<li><p>Por ejemplo, los operadores aritméticos <code>+</code>,
<code>-</code>, <code>*</code> y <code>/</code>, cuando actúan sobre
operandos numéricos, representan las operaciones de suma, resta,
multiplicación y división, respectivamente.</p>
<ul>
<li><p>En la expresión <code
class="sourceCode python">(<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)</code>:</p>
<ul>
<li><p>Los operandos son <code
class="sourceCode python"><span class="dv">3</span></code> y <code
class="sourceCode python"><span class="dv">4</span></code>.</p></li>
<li><p>El operador es <code>+</code> y representa la operación «<em>suma
de números</em>».</p></li>
</ul></li>
<li><p>En la expresión <code
class="sourceCode python">(<span class="dv">9</span> <span class="op">*</span> <span class="dv">8</span>)</code>:</p>
<ul>
<li><p>Los operandos son <code
class="sourceCode python"><span class="dv">9</span></code> y <code
class="sourceCode python"><span class="dv">8</span></code>.</p></li>
<li><p>El operador es <code>*</code> y representa la operación
«<em>multiplicación de números</em>».</p></li>
</ul></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.0.0.1">

<ul>
<li><p>Por tanto, la operación «suma» de la que hablamos anteriormente,
se puede representar matemáticamente de la siguiente forma usando el
operador <code>+</code>: <span class="math display">\_\texttt{+}\_:
\mathbb{R} \times \mathbb{R} \longrightarrow \mathbb{R}</span></p></li>
<li><p>Eso significa que el operador <code>+</code> acepta dos operandos
(dos números reales) y devuelve un número real.</p></li>
</ul>
</section>
<section id="aridad-de-operadores" class="title-slide slide level3"
data-number="3.2.1">
<h3 data-number="3.2.1"><span class="header-section-number">3.2.1</span>
Aridad de operadores</h3>
<ul>
<li><p>La <strong>aridad</strong> de un operador es el número de
operandos sobre los que opera.</p></li>
<li><p>Los operadores se clasifican según su aridad en:</p>
<ul>
<li><p><strong>Unarios</strong>: operan sobre un único operando.</p>
<p>Por ejemplo, el operador <code>-</code> de cambio de signo: <code
class="sourceCode python">(<span class="op">-</span>(<span class="dv">5</span> <span class="op">+</span> <span class="dv">3</span>))</code>.</p></li>
<li><p><strong>Binarios</strong>: operan sobre dos operandos.</p>
<p>Por ejemplo, la mayoría de los operadores aritméticos.</p></li>
<li><p><strong>Ternarios</strong>: operan sobre tres operandos.</p>
<p>Veremos un ejemplo más adelante.</p></li>
</ul></li>
</ul>
</section>

<section id="notación-de-los-operadores"
class="title-slide slide level3" data-number="3.2.2">
<h3 data-number="3.2.2"><span class="header-section-number">3.2.2</span>
Notación de los operadores</h3>
<ul>
<li><p>La <strong>notación</strong> de un operador indica en qué
posición se escribe dicho operador con respecto a sus operandos en una
expresión.</p></li>
<li><p>Los operadores se pueden escribir:</p>
<ul>
<li><p>Con <strong>notación prefija</strong>: cuando el operador se
escribe <em>antes</em> que los operandos.</p>
<p>Es el que se usa habitualmente para los operadores
<strong>unarios</strong>, como el operador <code>-</code> de cambio de
signo.</p></li>
<li><p>Con <strong>notación infija</strong>: cuando el operador se
escribe <em>entre</em> los operandos.</p>
<p>Es el que se usa habitualmente para los operadores
<strong>binarios</strong>.</p></li>
<li><p>Con <strong>notación postfija</strong>: cuando el operador se
escribe <em>después</em> que los operandos.</p>
<p>Se usa poco en la práctica, salvo casos especiales.</p></li>
</ul></li>
</ul>
</section>

<section id="paréntesis" class="title-slide slide level3"
data-number="3.2.3">
<h3 data-number="3.2.3"><span class="header-section-number">3.2.3</span>
Paréntesis</h3>
<ul>
<li><p>Los <strong>paréntesis</strong> sirven para agrupar elementos
dentro de una expresión y romper la posible ambigüedad que pueda haber
respecto a qué operador actúa sobre qué operandos.</p></li>
<li><p>Se usan, sobre todo, para hacer que varios elementos de una
expresión actúen como uno solo (una subexpresión) al realizar una
operación.</p>
<ul>
<li><p>Por ejemplo:</p>
<p><code
class="sourceCode python">((<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>) <span class="op">*</span> <span class="dv">5</span>)</code>
vale <code
class="sourceCode python"><span class="dv">35</span></code></p>
<p><code
class="sourceCode python">(<span class="dv">3</span> <span class="op">+</span> (<span class="dv">4</span> <span class="op">*</span> <span class="dv">5</span>))</code>
vale <code
class="sourceCode python"><span class="dv">23</span></code></p></li>
</ul></li>
<li><p>Una expresión está <strong>correctamente parentizada</strong> si
tiene los paréntesis bien colocados según dicta la gramática del
lenguaje.</p></li>
<li><p>Una expresión está <strong>totalmente parentizada</strong> si
agrupa con paréntesis a <strong>todas</strong> las operaciones con sus
operandos.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.3.0.1">

<ul>
<li><p>Hasta ahora, según nuestra gramática, las expresiones
correctamente parentizadas son precisamente las que están totalmente
parentizadas.</p></li>
<li><p>Por ejemplo:</p>
<ul>
<li><p><code
class="sourceCode python"><span class="dv">2</span> <span class="op">+</span>) <span class="dv">3</span> <span class="op">*</span>( <span class="dv">5</span>(</code>
no está correctamente parentizada.</p></li>
<li><p><code
class="sourceCode python">(<span class="dv">4</span> <span class="op">+</span> (<span class="dv">2</span> <span class="op">*</span> <span class="dv">5</span>))</code>
está correcta y totalmente parentizada.</p></li>
<li><p><code
class="sourceCode python"><span class="dv">2</span> <span class="op">+</span> <span class="dv">5</span></code>
no está totalmente parentizada y, por tanto, no está correctamente
parentizada según nuestra gramática.</p></li>
</ul></li>
<li><p>Para reducir la cantidad de paréntesis en una expresión, podemos
cambiar nuestra gramática acudiendo a un esquema de
<strong>prioridades</strong> y <strong>asociatividades</strong> de
operadores.</p></li>
<li><p>Haciendo eso, ya no hará falta exigir que las expresiones estén
totalmente parentizadas.</p></li>
</ul>
</section>

<section id="prioridad-de-operadores" class="title-slide slide level3"
data-number="3.2.4">
<h3 data-number="3.2.4"><span class="header-section-number">3.2.4</span>
Prioridad de operadores</h3>
<ul>
<li><p>En ausencia de paréntesis, cuando un operando está afectado a
izquierda y derecha por <strong>operadores de distinta
prioridad</strong>, se aplican las reglas de la
<strong>prioridad</strong>:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dv">8</span> <span class="op">+</span> <span class="dv">4</span> <span class="op">*</span> <span class="dv">2</span></span></code></pre></div>
<p>El <code class="sourceCode python"><span class="dv">4</span></code>
está afectado a izquierda y derecha por los operadores <code>+</code> y
<code>*</code>, que tienen distinta prioridad, por lo que se aplican las
reglas de la prioridad. El <code>*</code> tiene <em>más prioridad</em>
que el <code>+</code>, así que se agrupa con el <code>*</code>. Equivale
a:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dv">8</span> <span class="op">+</span> (<span class="dv">4</span> <span class="op">*</span> <span class="dv">2</span>)</span></code></pre></div>
<p>Si hiciéramos:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>(<span class="dv">8</span> <span class="op">+</span> <span class="dv">4</span>) <span class="op">*</span> <span class="dv">2</span></span></code></pre></div>
<p>el resultado sería distinto.</p></li>
<li><p>Ver prioridad de los operadores en Python en <a
href="https://docs.python.org/3/reference/expressions.html#operator-precedence"
target="_blank">https://docs.python.org/3/reference/expressions.html#operator-precedence</a>.</p></li>
</ul>
</section>

<section id="asociatividad-de-operadores"
class="title-slide slide level3" data-number="3.2.5">
<h3 data-number="3.2.5"><span class="header-section-number">3.2.5</span>
Asociatividad de operadores</h3>
<ul>
<li><p>En ausencia de paréntesis, cuando un operando está afectado a
izquierda y derecha por <strong>operadores de la misma
prioridad</strong> (o por el <strong>mismo operador</strong>), se
aplican las reglas de la <strong>asociatividad</strong>:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dv">8</span> <span class="op">/</span> <span class="dv">4</span> <span class="op">/</span> <span class="dv">2</span></span></code></pre></div>
<p>El <code class="sourceCode python"><span class="dv">4</span></code>
está afectado a derecha e izquierda por el mismo operador
<code>/</code>, por lo que se aplican las reglas de la asociatividad. El
<code>/</code> es <em>asociativo por la izquierda</em>, así que se
agrupa con el operador que está a la izquierda. Equivale a hacer:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>(<span class="dv">8</span> <span class="op">/</span> <span class="dv">4</span>) <span class="op">/</span> <span class="dv">2</span></span></code></pre></div>
<p>Si hiciéramos:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dv">8</span> <span class="op">/</span> (<span class="dv">4</span> <span class="op">/</span> <span class="dv">2</span>)</span></code></pre></div>
<p>el resultado sería distinto.</p></li>
<li><p>En Python, todos los operadores son <strong>asociativos por la
izquierda</strong> excepto el <code>**</code>, que es asociativo por la
derecha.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.5.0.1">

<ul>
<li><p>Por ejemplo, en este caso tenemos a un operando (el <code
class="sourceCode python"><span class="dv">3</span></code>) afectado a
derecha e izquierda por el mismo operador (el <code>**</code>), por lo
que, de nuevo, tenemos que aplicar las reglas de la asociatividad:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span> <span class="op">**</span> <span class="dv">3</span> <span class="op">**</span> <span class="dv">2</span></span></code></pre></div>
<p>Pero como el operador <code>**</code> es asociativo por la derecha,
se agrupa con el operador de la derecha, resultando equivalente a
hacer:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span> <span class="op">**</span> (<span class="dv">3</span> <span class="op">**</span> <span class="dv">2</span>)</span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.5.0.2">

<ul>
<li><p>En este ejemplo, el mismo operando (el <code
class="sourceCode python"><span class="dv">4</span></code>) está
afectado a derecha e izquierda por distintos operadores (el
<code>*</code> y el <code>/</code>), pero estos operadores tienen la
misma prioridad, así que, de nuevo, tenemos que aplicar las reglas de la
asociatividad:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dv">8</span> <span class="op">*</span> <span class="dv">4</span> <span class="op">/</span> <span class="dv">2</span></span></code></pre></div>
<p>Los operadores (<code>*</code> y <code>/</code>) son asociativos por
la izquierda, por lo que, nuevamente, el <code
class="sourceCode python"><span class="dv">4</span></code> se agrupa con
el operador que está a la izquierda, lo que equivale a hacer:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>(<span class="dv">8</span> <span class="op">*</span> <span class="dv">4</span>) <span class="op">/</span> <span class="dv">2</span></span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.5.0.3">

<ul>
<li><p>En todos los casos, es necesario que ambos operadores tengan la
misma asociatividad.</p></li>
<li><p>Podríamos plantearnos ahora qué ocurriría si los dos operadores
tuvieran la misma prioridad pero distinta asociatividad.</p></li>
<li><p>Por ejemplo, supongamos que tenemos dos extraños operadores
<code>&amp;</code> y <code>@</code>.</p></li>
<li><p>Ahora mismo no nos interesa saber qué hacen; sólo que ambos
tienen la misma prioridad pero distinta asociatividad.</p></li>
<li><p>Para este ejemplo, supongamos que <code>&amp;</code> es
asociativo por la izquierda y <code>@</code> por la derecha).</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.5.0.4">

<ul>
<li><p>En ese caso, sería imposible interpretar correctamente la
siguiente expresión, ya que un operador dice que hay que agrupar por la
izquierda pero el otro dice lo contrario:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="dv">4</span> <span class="op">&amp;</span> <span class="dv">3</span> <span class="op">@</span> <span class="dv">5</span></span></code></pre></div></li>
<li><p>Y lo mismo ocurriría con esta expresión:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="dv">4</span> <span class="op">@</span> <span class="dv">3</span> <span class="op">&amp;</span> <span class="dv">5</span></span></code></pre></div></li>
<li><p>Si se diera un caso así, sería porque el lenguaje no está bien
diseñado, ya que la gramática del lenguaje no aclararía con qué operador
hay que agrupar en casos así.</p></li>
<li><p>De hecho, se nos estaría obligando a usar paréntesis para dejar
claro cómo se agrupan los elementos que forman la expresión.</p></li>
<li><p>Por eso, lo normal es que los operadores que tienen la misma
prioridad tengan también la misma asociatividad.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.5.0.5">

<ul>
<li><p>También puede ocurrir que existan operadores que no son
asociativos ni por la derecha ni por la izquierda.</p></li>
<li><p>Tales operadores se dice que son <strong>no
asociativos</strong>.</p></li>
<li><p>En Python no hay ningún operador no asociativo, pero, por
ejemplo, en el lenguaje PHP existen varios operadores que sí lo son,
entre ellos <code>==</code>.</p></li>
<li><p>Por tanto, la siguiente expresión en PHP sería incorrecta y daría
lugar a un error sintáctico:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode php"><code class="sourceCode php"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span> == <span class="dv">3</span> == <span class="dv">4</span></span></code></pre></div></li>
<li><p>Tendríamos que usar paréntesis para dejar claro cómo se deben
agrupar los elementos que forman la expresión, lo que daría lugar a dos
posibles expresiones distintas:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode php"><code class="sourceCode php"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(</span><span class="dv">2</span> == <span class="dv">3</span><span class="ot">)</span> == <span class="dv">4</span></span></code></pre></div>
<div class="sourceCode" id="cb18"><pre
class="sourceCode php"><code class="sourceCode php"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span> == <span class="ot">(</span><span class="dv">3</span> == <span class="dv">4</span><span class="ot">)</span></span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.5.0.6">

<ul>
<li><p>Incorporando las reglas de la prioridad y la asociatividad, y
eliminando la necesidad de que las expresiones estén totalmente
parentizadas, nuestra gramática quedaría ahora sí:</p>
<div class="line-block"><span
style="color:teal">⟨<em>expresión</em>⟩</span> ::= <span
style="color:teal">⟨<em>operación</em>⟩</span> | <span
style="color:teal">⟨<em>literal</em>⟩</span> | <span
style="color:teal">⟨<em>nombre</em>⟩</span> |
<strong><code>(</code></strong><span
style="color:teal">⟨<em>expresión</em>⟩</span><strong><code>)</code></strong><br />
<span style="color:teal">⟨<em>operación</em>⟩</span> ::= <span
style="color:teal">⟨<em>expresión</em>⟩</span> <span
style="color:teal">⟨<em>operador_binario</em>⟩</span> <span
style="color:teal">⟨<em>expresión</em>⟩</span><br />
                              | <span
style="color:teal">⟨<em>operador_unario</em>⟩</span> <span
style="color:teal">⟨<em>expresión</em>⟩</span><br />
                              | <span
style="color:teal">⟨<em>llamada_función</em>⟩</span> | <span
style="color:teal">⟨<em>llamada_método</em>⟩</span><br />
<span style="color:teal">⟨<em>nombre</em>⟩</span> ::=
<strong><code>identificador</code></strong><br />
<span style="color:teal">⟨<em>literal</em>⟩</span> ::=
<strong><code>entero</code></strong> |
<strong><code>real</code></strong> |
<strong><code>cadena</code></strong> | …<br />
<span style="color:teal">⟨<em>operador_binario</em>⟩</span> ::=
<strong><code>+</code></strong> | <strong><code>-</code></strong> |
<strong><code>*</code></strong> | <strong><code>/</code></strong> |
<strong><code>//</code></strong> | <strong><code>**</code></strong> |
<strong><code>%</code></strong> | …<br />
<span style="color:teal">⟨<em>operador_unario</em>⟩</span> ::=
<strong><code>+</code></strong> | <strong><code>-</code></strong> |
…<br />
<span style="color:teal">⟨<em>llamada_función</em>⟩</span> ::= <span
style="color:teal">⟨<em>función</em>⟩</span><strong><code>(</code></strong>[<span
style="color:teal">⟨<em>lista_argumentos</em>⟩</span>]<strong><code>)</code></strong><br />
<span style="color:teal">⟨<em>función</em>⟩</span> ::=
<strong><code>identificador</code></strong><br />
<span style="color:teal">⟨<em>llamada_método</em>⟩</span> ::= <span
style="color:teal">⟨<em>objeto</em>⟩</span><strong><code>.</code></strong><span
style="color:teal">⟨<em>método</em>⟩</span><strong><code>(</code></strong>[<span
style="color:teal">⟨<em>lista_argumentos</em>⟩</span>]<strong><code>)</code></strong><br />
<span style="color:teal">⟨<em>objeto</em>⟩</span> ::= <span
style="color:teal">⟨<em>expresión</em>⟩</span><br />
<span style="color:teal">⟨<em>método</em>⟩</span> ::=
<strong><code>identificador</code></strong><br />
<span style="color:teal">⟨<em>lista_argumentos</em>⟩</span> ::= <span
style="color:teal">⟨<em>expresión</em>⟩</span>(<strong><code>,</code></strong>
<span style="color:teal">⟨<em>expresión</em>⟩</span>)*</div></li>
<li><p>Ahora, cualquier expresión puede llevar paréntesis si es
necesario, pero si no son necesarios se pueden omitir.</p></li>
</ul>
</section>

<section id="paréntesis-y-orden-de-evaluación"
class="title-slide slide level3" data-number="3.2.6">
<h3 data-number="3.2.6"><span class="header-section-number">3.2.6</span>
Paréntesis y orden de evaluación</h3>
<ul>
<li><p>Es importante entender que los paréntesis sirven para agrupar
elementos, pero por sí mismos no son suficientes para imponer un
determinado <strong>orden de evaluación</strong>.</p></li>
<li><p>Por ejemplo, en la expresión <code
class="sourceCode python"><span class="dv">4</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">+</span> <span class="dv">5</span>)</code>,
el intérprete intenta hacer el producto de <code
class="sourceCode python"><span class="dv">4</span></code> por <code
class="sourceCode python">(<span class="dv">3</span> <span class="op">+</span> <span class="dv">5</span>)</code>,
pero no puede hacerlo hasta haber calculado primero la suma de <code
class="sourceCode python"><span class="dv">3</span></code> y <code
class="sourceCode python"><span class="dv">5</span></code>.</p></li>
<li><p>Por eso el intérprete calcula primero la suma y finalmente hace
el producto, porque para hacer el producto primero necesita haber
reducido sus operandos a dos números que se puedan multiplicar.</p></li>
<li><p>El efecto final es que parece que los paréntesis han obligado a
hacer primero la suma, como si los paréntesis fuesen una especie de
operador cuya finalidad es la de aumentar la prioridad de lo que hay
dentro.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.6.0.1">

<ul>
<li><p>En concreto, la evaluación de esa expresión sería:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="dv">4</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">+</span> <span class="dv">5</span>)       <span class="co"># se evalúa 4 (que devuelve 4)</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">4</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">+</span> <span class="dv">5</span>)     <span class="co"># se evalúa 3 (que devuelve 3)</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">4</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">+</span> <span class="dv">5</span>)     <span class="co"># se evalúa 5 (que devuelve 5)</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">4</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">+</span> <span class="dv">5</span>)     <span class="co"># se evalúa (3 + 5) (que devuelve 8)</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">4</span> <span class="op">*</span> <span class="dv">8</span>           <span class="co"># se evalúa 4 * 8 (que devuelve 32)</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">32</span></span></code></pre></div></li>
<li><p>Sin paréntesis, la expresión <code
class="sourceCode python"><span class="dv">4</span> <span class="op">*</span> <span class="dv">3</span> <span class="op">+</span> <span class="dv">5</span></code>
se evaluaría así:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="dv">4</span> <span class="op">*</span> <span class="dv">3</span> <span class="op">+</span> <span class="dv">5</span>         <span class="co"># se evalúa 4 (que devuelve 4)</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">4</span> <span class="op">*</span> <span class="dv">3</span> <span class="op">+</span> <span class="dv">5</span>       <span class="co"># se evalúa 3 (que devuelve 3)</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">4</span> <span class="op">*</span> <span class="dv">3</span> <span class="op">+</span> <span class="dv">5</span>       <span class="co"># se evalúa 4 * 3 (que devuelve 12)</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">12</span> <span class="op">+</span> <span class="dv">5</span>          <span class="co"># se evalúa 5 (que devuelve 5)</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">12</span> <span class="op">+</span> <span class="dv">5</span>          <span class="co"># se evalúa 12 + 5 (que devuelve 17)</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">17</span></span></code></pre></div>
<p>Aquí se puede hacer el producto antes que la suma porque los dos
operandos del <code>*</code> están ya totalmente reducidos.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.6.0.2">

<ul>
<li><p>Pero, ¿qué ocurre con la expresión <code
class="sourceCode python">(<span class="dv">2</span> <span class="op">+</span> <span class="dv">3</span>) <span class="op">*</span> (<span class="dv">4</span> <span class="op">+</span> <span class="dv">5</span>)</code>?</p></li>
<li><p>En un principio, ocurre algo parecido a lo de antes: para poder
hacer el producto, primero hay que calcular las dos sumas, ya que los
operandos del <code>*</code> son los valores que resultan de hacer esas
sumas.</p></li>
<li><p>La cuestión es: ¿qué suma se hace primero? O dicho de otra forma:
¿en qué orden se evalúan los operandos del operador
<code>*</code>?</p></li>
<li><p>Matemáticamente, no hay ninguna diferencia entre calcular primero
el resultado de <code
class="sourceCode python"><span class="dv">2</span> <span class="op">+</span> <span class="dv">3</span></code>
y luego hacer <code
class="sourceCode python"><span class="dv">4</span> <span class="op">+</span> <span class="dv">5</span></code>,
o hacerlo al revés.</p></li>
<li><p>Pero ya sabemos que Python impone un orden de evaluación de
izquierda a derecha al reducir las subexpresiones.</p></li>
<li><p>Por tanto, primero se evaluaría <code
class="sourceCode python">(<span class="dv">2</span> <span class="op">+</span> <span class="dv">3</span>)</code>,
y después <code
class="sourceCode python">(<span class="dv">4</span> <span class="op">+</span> <span class="dv">5</span>)</code>.</p></li>
<li><p>El orden de evaluación no viene determinado por los paréntesis,
sino por las reglas del lenguaje y el funcionamiento interno del
intérprete.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.6.0.3">

<ul>
<li><p>En concreto, la evaluación de esa expresión sería:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>(<span class="dv">2</span> <span class="op">+</span> <span class="dv">3</span>) <span class="op">*</span> (<span class="dv">4</span> <span class="op">+</span> <span class="dv">5</span>)    <span class="co"># se evalúa 2 (que devuelve 2)</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">2</span> <span class="op">+</span> <span class="dv">3</span>) <span class="op">*</span> (<span class="dv">4</span> <span class="op">+</span> <span class="dv">5</span>)  <span class="co"># se evalúa 3 (que devuelve 3)</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">2</span> <span class="op">+</span> <span class="dv">3</span>) <span class="op">*</span> (<span class="dv">4</span> <span class="op">+</span> <span class="dv">5</span>)  <span class="co"># se evalúa (2 + 3) (que devuelve 5)</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">+</span> <span class="dv">5</span>)        <span class="co"># se evalúa 4 (que devuelve 4)</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">+</span> <span class="dv">5</span>)        <span class="co"># se evalúa el último 5 (que devuelve 5)</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">+</span> <span class="dv">5</span>)        <span class="co"># se evalúa (4 + 5) (que devuelve 9)</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">5</span> <span class="op">*</span> <span class="dv">9</span>              <span class="co"># se evalúa 5 * 9 (que devuelve 45)</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="dv">45</span></span></code></pre></div></li>
</ul>
</section>

<section id="tipos-de-operandos" class="title-slide slide level3"
data-number="3.2.7">
<h3 data-number="3.2.7"><span class="header-section-number">3.2.7</span>
Tipos de operandos</h3>
<ul>
<li><p>Los operadores esperan que cada uno de sus operandos pertenezcan
a un determinado tipo. Si intentamos aplicar un operador sobre operandos
de tipos incorrectos, obtendremos resultados inesperados (o,
directamente, un error).</p></li>
<li><p>Por ejemplo, los operadores aritméticos esperan operandos de tipo
<em>numérico</em>. Así, si intentamos dividir dos cadenas usando el
operador <code>/</code>, nos dará un error de tipos (<code
class="sourceCode python"><span class="pp">TypeError</span></code>):</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="st">&quot;hola&quot;</span> <span class="op">/</span> <span class="st">&quot;pepe&quot;</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>Traceback (most recent call last):</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="pp">TypeError</span>: unsupported operand <span class="bu">type</span>(s) <span class="cf">for</span> <span class="op">/</span>: <span class="st">&#39;str&#39;</span> <span class="kw">and</span> <span class="st">&#39;str&#39;</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span></span></code></pre></div></li>
<li><p>Durante la evaluación de una expresión, se deberá ir calculando
tanto el valor como el tipo de cada subexpresión, y se debería ir
comprobando si los tipos de los operandos son los adecuados para cada
operación.</p></li>
<li><p>El concepto de <strong>tipo de dato</strong> es uno de los más
importantes en Programación y lo estudiaremos en profundidad más
adelante.</p></li>
</ul>
</section>


<section id="funciones" class="title-slide slide level2"
data-number="3.3">
<h2 data-number="3.3"><span class="header-section-number">3.3</span>
Funciones</h2>
<ul>
<li><p>Como cualquier otro tipo de operación, las funciones en
Programación reciben unos datos de entrada y devuelven un valor de
salida.</p></li>
<li><p>En Programación, los datos de entrada de una función se denominan
<strong>argumentos</strong>.</p></li>
<li><p>Por tanto, los argumentos para las funciones son como los
operandos para los operadores.</p></li>
<li><p>Las funciones reciben los argumentos a través de sus
<strong>parámetros</strong>.</p></li>
<li><p>Para usar una función hay que conocer su
<strong>signatura</strong>, la cual informa de:</p>
<ul>
<li><p>El <strong><em>nombre</em></strong> de la función, que es un
<em>identificador</em> que hace referencia a la función.</p></li>
<li><p>El <strong>número, tipo, nombre y posición</strong> de sus
<strong><em>parámetros</em></strong>.</p></li>
<li><p>El <strong><em>tipo de retorno</em></strong>, o
<strong>tipo</strong> del <em>resultado</em> que devuelve.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.0.0.1">

<ul>
<li><p>Por ejemplo, la función <code
class="sourceCode python"><span class="bu">abs</span></code>, que está
predefinida en Python, podría tener la siguiente signatura:</p>
<p><span
class="math inline">\texttt{abs(\(x\):\,int)\;-&gt;\;int}</span></p></li>
<li><p>Esa signatura nos dice que:</p>
<ul>
<li><p>La función se llama <code
class="sourceCode python"><span class="bu">abs</span></code>.</p></li>
<li><p>Tiene un único parámetro llamado <span
class="math inline">\underline{x}</span> que puede tomar cualquier valor
de tipo <code
class="sourceCode python"><span class="bu">int</span></code> (un número
<em>entero</em>).</p>
<p>Por tanto, los argumentos que puede recibir la función (sus datos de
entrada) deben ser valores numéricos de tipo entero, ya que los
parámetros de una función representan a los argumentos dentro de la
función.</p></li>
<li><p>Su tipo de retorno es <code
class="sourceCode python"><span class="bu">int</span></code>, por lo que
devuelve como resultado un número <em>entero</em>.</p></li>
</ul></li>
<li><p>La sintaxis anterior usa el concepto de <strong>anotaciones de
tipos</strong>, que son una característica que permite indicar qué tipo
de datos se espera que tengan los parámetros y el valor de retorno de
una función.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.0.0.2">

<ul>
<li><p>Las funciones, como cualquier otro valor, también tienen un tipo.
Por ejemplo, en Matemáticas y en Teoría de tipos, el tipo de una función
se puede representar así:</p>
<p><span class="math inline">abs: \mathbb{Z} \longrightarrow
\mathbb{Z}</span></p>
<p><span class="math inline">pow: \mathbb{R} \times \mathbb{R}
\longrightarrow \mathbb{R}</span></p></li>
<li><p>En Programación, el tipo de una función se puede deducir a partir
de la <em>signatura</em> de la función, la cual se puede escribir de
varias formas según el lenguaje utilizado. Por ejemplo:</p>
<ul>
<li><p>En Python:</p>
<p><span
class="math inline">\texttt{abs(\(x\):\,int)\;-&gt;\;int}</span></p>
<p><span
class="math inline">\texttt{pow(\(base\):\,float,\;\(exp\):\,float)\;-&gt;\;float}</span></p>
<!-- Esta sintaxis, con la cual se representan los tipos de los elementos
de un programa en Python, se denomina **anotaciones de tipo** o _type
hints_. --></li>
<li><p>En Java:</p>
<p><span class="math inline">\texttt{int abs(int\;\,\(x\))}</span></p>
<p><span class="math inline">\texttt{double
pow(double\;\,\(base\),\;double\;\,\(exp\))}</span></p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.0.0.3">

<ul>
<li><p>De aquí se puede deducir que, en Programación:</p>
<ul>
<li><p>El <strong>producto cartesiano de los tipos de los
parámetros</strong> de una función se corresponde con el
<strong>conjunto origen</strong> de una función matemática.</p></li>
<li><p>El <strong>tipo de retorno</strong> de una función se corresponde
con el <strong>conjunto imagen</strong> de una función
matemática.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.0.0.4">

<ul>
<li><p>Para usar la función, lo que hacemos es <strong>llamar</strong> o
<strong>invocar</strong> a la función.</p></li>
<li><p>«<em>Llamar a una función</em>» consiste en <strong>aplicar dicha
función a unos argumentos</strong>, que son los datos sobre los que
queremos que actúe la función.</p></li>
<li><p>La <strong>aplicación de una función a unos argumentos</strong>
es una expresión mediante la cual solicitamos que se realice una
operación (que tiene forma de función) pasándole a ésta (a través de los
argumentos) los datos sobre los que queremos que actúe la
operación.</p></li>
<li><p>A la aplicación de una función a unos argumentos también se la
denomina <strong>invocación</strong> de la función o
<strong>llamada</strong> a la función.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.0.0.5">

<ul>
<li><p>En la llamada a la función, <strong>los argumentos
<em>sustituyen</em> a los parámetros</strong> según el orden en el que
aparecen en la llamada, haciendo corresponder el primer argumento con el
primer parámetro, el segundo con el segundo y así
sucesivamente.</p></li>
<li><p>Dicho de otra forma: <strong>los parámetros toman los valores de
los argumentos correspondientes</strong>.</p></li>
<li><p>También se dice que <strong>los argumentos <em>se pasan</em> a
los parámetros</strong>.</p></li>
<li><p>Por eso debe haber tantos argumentos como parámetros, ni más ni
menos.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.0.0.6">

<ul>
<li><p>Sintácticamente, la <strong>llamada a una función</strong> tiene
esta forma:</p>
<div class="line-block"><span
style="color:teal">⟨<em>llamada_función</em>⟩</span> ::= <span
style="color:teal">⟨<em>función</em>⟩</span><strong><code>(</code></strong>[<span
style="color:teal">⟨<em>lista_argumentos</em>⟩</span>]<strong><code>)</code></strong><br />
<span style="color:teal">⟨<em>función</em>⟩</span> ::=
<strong><code>identificador</code></strong><br />
<span style="color:teal">⟨<em>lista_argumentos</em>⟩</span> ::= <span
style="color:teal">⟨<em>expresión</em>⟩</span>(<strong><code>,</code></strong>
<span style="color:teal">⟨<em>expresión</em>⟩</span>)*</div></li>
<li><p>Por ejemplo, si queremos calcular el valor absoluto del número
<span class="math inline">-3</span>, podemos llamar a la función <code
class="sourceCode python"><span class="bu">abs</span></code> pasándole
<code
class="sourceCode python"><span class="op">-</span><span class="dv">3</span></code>
como su argumento:</p></li>
</ul>
<p><code
class="sourceCode python"><span class="bu">abs</span>(<span class="op">-</span><span class="dv">3</span>)</code></p>
<ul>
<li><p>En esta llamada, las siguientes tres afirmaciones son
equivalentes (son tres formas distintas de decir lo mismo):</p>
<ul>
<li><p>«El argumento <code
class="sourceCode python"><span class="op">-</span><span class="dv">3</span></code>
se pasa a la función <code
class="sourceCode python"><span class="bu">abs</span></code> a través
del parámetro <span class="math inline">\underline{x}</span>».</p></li>
<li><p>«El argumento <code
class="sourceCode python"><span class="op">-</span><span class="dv">3</span></code>
se pasa al parámetro <span
class="math inline">\underline{x}</span>».</p></li>
<li><p>«El parámetro <span class="math inline">\underline{x}</span> toma
el valor <code
class="sourceCode python"><span class="op">-</span><span class="dv">3</span></code>».</p></li>
</ul></li>
<li><p>El resultado de la llamada a la función será el valor que
devuelve (en este caso, el valor <code
class="sourceCode python"><span class="dv">3</span></code>). Por tanto,
la expresión <code
class="sourceCode python"><span class="bu">abs</span>(<span class="op">-</span><span class="dv">3</span>)</code>
vale <code
class="sourceCode python"><span class="dv">3</span></code>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.0.0.7">

<ul>
<li><p>Como la función <code
class="sourceCode python"><span class="bu">abs</span></code> está
<strong>predefinida</strong> en Python, se puede usar directamente. Por
ejemplo:</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">abs</span>(<span class="op">-</span><span class="dv">3</span>)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span></span></code></pre></div></li>
<li><p>Al igual que pasa con los operadores, es importante respetar la
signatura de una función. Eso significa, entre otras cosas, que
<strong>sus argumentos deben pertenecer al <em>tipo</em>
correcto</strong> (el tipo indicado para su correspondiente
parámetro).</p></li>
<li><p>Por ejemplo, si aplicamos la función <code
class="sourceCode python"><span class="bu">abs</span></code> a un
argumento de un tipo incorrecto (digamos, una cadena en lugar de un
número), obtendremos un error <code
class="sourceCode python"><span class="pp">TypeError</span></code>:</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">abs</span>(<span class="st">&quot;hola&quot;</span>)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>Traceback (most recent call last):</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="pp">TypeError</span>: bad operand <span class="bu">type</span> <span class="cf">for</span> <span class="bu">abs</span>(): <span class="st">&#39;str&#39;</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span></span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.0.0.8">

<ul>
<li><p>Igualmente, el <strong>número de argumentos</strong> que se pasan
a la función durante la llamada a la misma debe ser el
correcto.</p></li>
<li><p>Es decir: el número de argumentos en la llamada a la función
<strong>debe coincidir con el número de parámetros</strong> de la
función.</p></li>
<li><p>Si pasamos a la función más o menos argumentos de los indicados
en su lista de parámetros, obtendremos un error <code
class="sourceCode python"><span class="pp">TypeError</span></code>:</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">abs</span>()</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>Traceback (most recent call last):</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="pp">TypeError</span>: <span class="bu">abs</span>() takes exactly one argument (<span class="dv">0</span> given)</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">abs</span>(<span class="dv">4</span>, <span class="dv">2</span>)</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>Traceback (most recent call last):</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a><span class="pp">TypeError</span>: <span class="bu">abs</span>() takes exactly one argument (<span class="dv">2</span> given)</span></code></pre></div></li>
<li><p>Siempre hay que respetar el número y tipo de los datos sobre los
que actúa una operación, tenga ésta la forma que tenga. Por ejemplo, con
los operadores también hay que hacerlo.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.0.0.9">

<ul>
<li><p>Otro ejemplo es la función <code
class="sourceCode python"><span class="bu">len</span></code>, que
devuelve la longitud de una cadena (el número de caracteres que
contiene). Su signatura sería:</p>
<p><span
class="math inline">\texttt{len(\(cadena\):\,str)\;-&gt;\;int}</span></p></li>
<li><p>Un ejemplo de llamada a la función <code
class="sourceCode python"><span class="bu">len</span></code>:</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">len</span>(<span class="st">&quot;hola&quot;</span>)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="dv">4</span></span></code></pre></div></li>
<li><p>Sabemos que hay que cumplir la signatura de la función. Por
tanto, debemos pasarle un único argumento de tipo cadena. Si le pasamos
más argumentos, o bien le pasamos un argumento de otro tipo, dará
error:</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">len</span>(<span class="dv">23</span>)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>Traceback (most recent call last):</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="pp">TypeError</span>: <span class="bu">object</span> of <span class="bu">type</span> <span class="st">&#39;int&#39;</span> has no <span class="bu">len</span>()</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">len</span>(<span class="st">&quot;hola&quot;</span>, <span class="st">&quot;pepe&quot;</span>)</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>Traceback (most recent call last):</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a><span class="pp">TypeError</span>: <span class="bu">len</span>() takes exactly one argument (<span class="dv">2</span> given)</span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.0.0.10">

<ul>
<li><p>Otro ejemplo es la función <code
class="sourceCode python"><span class="bu">pow</span></code>, que
realiza la operación de elevar un número a la potencia de otro. Su
signatura (simplificada) podría ser:</p>
<p><span
class="math inline">\texttt{pow(\(base\):\,int,\;\(exp\):\,int)\;-&gt;\;int}</span></p></li>
<li><p>Curiosamente, la misma operación existe en Python de dos formas
diferentes:</p>
<ul>
<li><p>Como operador (<code>**</code>):</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="dv">2</span> <span class="op">**</span> <span class="dv">3</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="dv">8</span></span></code></pre></div></li>
<li><p>Como función (<code
class="sourceCode python"><span class="bu">pow</span></code>):</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">pow</span>(<span class="dv">2</span>, <span class="dv">3</span>)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="dv">8</span></span></code></pre></div></li>
<li><p>En ambos casos, la operación es exactamente la misma.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.0.0.11">

<ul>
<li><p>Al llamar a la función <code
class="sourceCode python"><span class="bu">pow</span></code> hay que
tener en cuenta que tiene dos parámetros, por lo que hay que pasarle dos
argumentos.</p></li>
<li><p>Además, hay que recordar que importa el orden al pasar los
argumentos en la llamada a la función.</p></li>
<li><p>El primer argumento se pasaría al primer parámetro (<span
class="math inline">base</span>) y el segundo se pasaría al segundo
(<span class="math inline">exp</span>).</p></li>
<li><p>Por tanto, el primer argumento debe ser la base y el segundo debe
ser el exponente, y no al revés.</p></li>
<li><p>No es lo mismo hacer <code
class="sourceCode python"><span class="bu">pow</span>(<span class="dv">2</span>, <span class="dv">3</span>)</code>
que hacer <code
class="sourceCode python"><span class="bu">pow</span>(<span class="dv">3</span>, <span class="dv">2</span>)</code>:</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">pow</span>(<span class="dv">2</span>, <span class="dv">3</span>)  <span class="co"># aquí, el parámetro «base» toma el valor 2 y «exp» el valor 3</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="dv">8</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">pow</span>(<span class="dv">3</span>, <span class="dv">2</span>)  <span class="co"># aquí, el parámetro «base» toma el valor 3 y «exp» el valor 2</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="dv">9</span></span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.0.0.12">

<ul>
<li><p>Como último ejemplo, la función <code
class="sourceCode python"><span class="bu">max</span></code> devuelve el
máximo de varios valores recibidos como argumentos:</p>
<p><code>max(</code><span class="math inline">arg_1</span><code>,</code>
<code></code><span class="math inline">arg_2</span><code>,</code>
<code></code> <span class="math inline">\ldots</span> <code>,</code>
<span class="math inline">arg_n</span><code>)</code></p></li>
<li><p>Aquí es más complicado definir su signatura, ya que <code
class="sourceCode python"><span class="bu">max</span></code>:</p>
<ul>
<li><p>Admite <strong>argumentos de muchos tipos</strong> (se puede
calcular el máximo de varios números, de varias cadenas… de casi
cualquier conjunto de cosas que sean <em>comparables</em> entre sí), por
lo que decimos que es una función <strong>polimórfica</strong>, aunque
además <strong>todos los argumentos deben ser del mismo
tipo</strong>.</p></li>
<li><p>Admite un <strong>número variable de argumentos</strong> (es una
función <strong>variádica</strong>), aunque como mínimo debe recibir
uno.</p></li>
</ul></li>
<li><p>Por ejemplo:</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">max</span>(<span class="dv">13</span>, <span class="dv">4</span>, <span class="dv">28</span>)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="dv">28</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">max</span>(<span class="st">&quot;hola&quot;</span>, <span class="st">&quot;pepe&quot;</span>)</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="st">&#39;pepe&#39;</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">max</span>(<span class="dv">2</span>, <span class="st">&quot;hola&quot;</span>)</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>Traceback (most recent call last):</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a><span class="pp">TypeError</span>: <span class="st">&#39;&gt;&#39;</span> <span class="kw">not</span> supported between instances of <span class="st">&#39;str&#39;</span> <span class="kw">and</span> <span class="st">&#39;int&#39;</span></span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.0.0.13">

<ul>
<li><p>Es interesante tener en cuenta que el nombre de una función (como
<code class="sourceCode python"><span class="bu">abs</span></code>,
<code class="sourceCode python"><span class="bu">len</span></code> o
<code class="sourceCode python"><span class="bu">max</span></code>) es
un <strong>identificador</strong> que <strong>representa a la propia
función</strong>.</p></li>
<li><p>Es decir, que <code
class="sourceCode python"><span class="bu">max</span></code> (sin
paréntesis detrás) es una <strong>expresión válida cuyo valor es la
propia función «<em>máximo de dos números</em>»</strong>.</p></li>
<li><p>Si le pedimos al intérprete que nos muestre el valor de la
expresión <code
class="sourceCode python"><span class="bu">max</span></code>, nos
dice:</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">max</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>built<span class="op">-</span><span class="kw">in</span> function <span class="bu">max</span><span class="op">&gt;</span></span></code></pre></div>
<p>(Recordemos que las funciones no tienen forma normal.)</p></li>
<li><p>En resumen: la expresión <code
class="sourceCode python"><span class="bu">max</span></code> devuelve la
propia función «<strong>máximo</strong>» y la expresión <code
class="sourceCode python"><span class="bu">max</span>(<span class="dv">4</span>, <span class="dv">8</span>)</code>
devuelve el valor <code
class="sourceCode python"><span class="dv">8</span></code>.</p></li>
</ul>
<div class="caja centered">
<p><strong>Conclusión: las funciones también son valores.</strong></p>
</div>
</section>
<section id="evaluación-de-expresiones-con-funciones"
class="title-slide slide level3" data-number="3.3.1">
<h3 data-number="3.3.1"><span class="header-section-number">3.3.1</span>
Evaluación de expresiones con funciones</h3>
<ul>
<li><p><strong>Una llamada a función es una expresión válida</strong>,
por lo que podemos colocar una llamada a función en cualquier lugar
donde sea sintácticamente correcto situar un valor.</p></li>
<li><p>La evaluación de una expresión que contiene llamadas a funciones
se realiza <strong>sustituyendo (<em>reduciendo</em>) cada llamada a
función por su valor correspondiente</strong>, es decir, por el valor
que dicha función <em>devuelve</em> dependiendo de sus argumentos
(<strong>su <em>resultado</em></strong>).</p></li>
<li><p>Por ejemplo, en la siguiente expresión se combinan varias
funciones y operadores:</p>
<p><code
class="sourceCode python"><span class="bu">abs</span>(<span class="op">-</span><span class="dv">12</span>) <span class="op">+</span> <span class="bu">max</span>(<span class="dv">13</span>, <span class="dv">28</span>)</code></p>
<p>Aquí se llama a la función <code
class="sourceCode python"><span class="bu">abs</span></code> con el
argumento <code
class="sourceCode python"><span class="op">-</span><span class="dv">12</span></code>
y a la función <code
class="sourceCode python"><span class="bu">max</span></code> con los
argumentos <code
class="sourceCode python"><span class="dv">13</span></code> y <code
class="sourceCode python"><span class="dv">28</span></code>, y
finalmente se suman los dos valores obtenidos.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.1.0.1">

<ul>
<li><p>¿Cómo se calcula el valor de toda la expresión anterior?</p></li>
<li><p>En la expresión <code
class="sourceCode python"><span class="bu">abs</span>(<span class="op">-</span><span class="dv">12</span>) <span class="op">+</span> <span class="bu">max</span>(<span class="dv">13</span>, <span class="dv">28</span>)</code>
tenemos que calcular la suma de dos valores, pero esos valores aún no
los conocemos porque son los resultados que se obtienen al llamar a dos
funciones.</p></li>
<li><p>Por tanto, lo primero que tenemos que hacer es evaluar las dos
subexpresiones principales que contiene dicha expresión:</p>
<ul>
<li><p><code
class="sourceCode python"><span class="bu">abs</span>(<span class="op">-</span><span class="dv">12</span>)</code></p></li>
<li><p><code
class="sourceCode python"><span class="bu">max</span>(<span class="dv">13</span>, <span class="dv">28</span>)</code></p></li>
</ul></li>
<li><p>¿Cuál se evalúa primero?</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.1.0.2">

<ul>
<li><p>En Matemáticas no importa el orden de evaluación de las
subexpresiones, ya que el resultado debe ser siempre el mismo, así que
da igual evaluar primero uno u otro.</p></li>
<li><p>Por tanto, la evaluación paso a paso de la expresión matemática
anterior, podría ser de cualquiera de estas dos formas:</p>
<p><br></p>
<div class="columns">
<div class="column" style="width:5%;">

</div><div class="column" style="width:43%;">
<ol type="1">
<li><span class="math inline">\begin{cases}\begin{array}{l}
\underline{abs(-12)} + max(13, 28) \\[6pt]
= 12 + \underline{max(13, 28)} \\[6pt]
= \underline{12 + 28} \\[6pt]
= 40
\end{array}\end{cases}</span></li>
</ol>
</div><div class="column" style="width:43%;">
<ol start="2" type="1">
<li><span class="math inline">\begin{cases}\begin{array}{l}
abs(-12) + \underline{max(13, 28)} \\[6pt]
= \underline{abs(-12)} + 28 \\[6pt]
= \underline{12 + 28} \\[6pt]
= 40
\end{array}\end{cases}</span></li>
</ol>
</div>
</div>
<p><br></p>
<p>En cada paso, la subexpresión <span
class="math inline">\text{\underline{subrayada}}</span> es la que se va
a evaluar (reducir) en el paso siguiente.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.1.0.3">

<ul>
<li><p>En programación funcional ocurre lo mismo que en Matemáticas,
gracias a que se cumple la <em>transparencia referencial</em>.</p></li>
<li><p>Sin embargo, Python no es un lenguaje funcional puro, por lo que
resulta importante tener en cuenta el orden de evaluación que sigue al
evaluar las subexpresiones que forman una expresión.</p></li>
<li><p>Concretamente, ya sabemos que <strong>Python siempre evalúa las
expresiones de izquierda a derecha</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.1.0.4">

<ul>
<li><p>En Python, la expresión anterior se escribe exactamente igual, ya
que Python conoce las funciones <span class="math inline">abs</span> y
<span class="math inline">max</span> (son <strong>funciones
predefinidas</strong> en el lenguaje):</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">abs</span>(<span class="op">-</span><span class="dv">12</span>) <span class="op">+</span> <span class="bu">max</span>(<span class="dv">13</span>, <span class="dv">28</span>)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="dv">40</span></span></code></pre></div></li>
<li><p>Sabiendo que Python evalúa de izquierda a derecha, la evaluación
de la expresión anterior en Python sería:</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="bu">abs</span>(<span class="op">-</span><span class="dv">12</span>) <span class="op">+</span> <span class="bu">max</span>(<span class="dv">13</span>, <span class="dv">28</span>)   <span class="co"># se evalúa abs (devuelve una función)</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="bu">abs</span>(<span class="op">-</span><span class="dv">12</span>) <span class="op">+</span> <span class="bu">max</span>(<span class="dv">13</span>, <span class="dv">28</span>) <span class="co"># se evalúa -12 (devuelve -12)</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="bu">abs</span>(<span class="op">-</span><span class="dv">12</span>) <span class="op">+</span> <span class="bu">max</span>(<span class="dv">13</span>, <span class="dv">28</span>) <span class="co"># se evalúa abs(-12) (devuelve 12)</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">12</span> <span class="op">+</span> <span class="bu">max</span>(<span class="dv">13</span>, <span class="dv">28</span>)       <span class="co"># se evalúa max (devuelve una función)</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">12</span> <span class="op">+</span> <span class="bu">max</span>(<span class="dv">13</span>, <span class="dv">28</span>)       <span class="co"># se evalúa 13 (devuelve 13)</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">12</span> <span class="op">+</span> <span class="bu">max</span>(<span class="dv">13</span>, <span class="dv">28</span>)       <span class="co"># se evalúa 28 (devuelve 28)</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">12</span> <span class="op">+</span> <span class="bu">max</span>(<span class="dv">13</span>, <span class="dv">28</span>)       <span class="co"># se evalúa max(13, 28) (devuelve 28)</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">12</span> <span class="op">+</span> <span class="dv">28</span>                <span class="co"># se evalúa 12 + 28 (devuelve 40)</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">40</span></span></code></pre></div></li>
</ul>
</section>

<section id="composición-de-operaciones"
class="title-slide slide level3" data-number="3.3.2">
<h3 data-number="3.3.2"><span class="header-section-number">3.3.2</span>
Composición de operaciones</h3>
<ul>
<li><p>Como acabamos de ver, el resultado de una operación puede ser un
dato sobre el que aplicar otra operación dentro de la misma
expresión:</p>
<ul>
<li><p>En <code
class="sourceCode python"><span class="dv">4</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">+</span> <span class="dv">5</span>)</code>,
el resultado de <code
class="sourceCode python">(<span class="dv">3</span> <span class="op">+</span> <span class="dv">5</span>)</code>
se usa como operando para el operador <code>*</code>.</p></li>
<li><p>En <code
class="sourceCode python"><span class="bu">abs</span>(<span class="op">-</span><span class="dv">12</span>) <span class="op">+</span> <span class="bu">max</span>(<span class="dv">13</span>, <span class="dv">28</span>)</code>,
los resultados de llamar a las funciones <code
class="sourceCode python"><span class="bu">abs</span></code> y <code
class="sourceCode python"><span class="bu">max</span></code> son los
operandos del operador <code>+</code>.</p></li>
</ul></li>
<li><p>A esto se le denomina <strong>composición de
operaciones</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.2.0.1">

<ul>
<li><p>La manera más sencilla de realizar varias operaciones sobre los
mismos datos es componer las operaciones, es decir, hacer que el
resultado de una operación sea la entrada de otra operación.</p></li>
<li><p>Se va creando así una <strong>secuencia de operaciones</strong>
donde la salida de una es la entrada de la siguiente.</p></li>
<li><p>Cuando el resultado de una función se usa como argumento de otra
función le llamamos <strong>composición de funciones</strong>:</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="bu">round</span>(<span class="bu">abs</span>(<span class="op">-</span><span class="fl">23.459</span>), <span class="dv">2</span>)  <span class="co"># devuelve 23.46</span></span></code></pre></div></li>
<li><p>En programación funcional, la composición de funciones es una
técnica que ayuda a <strong>descomponer un problema en partes</strong>
que se van resolviendo por pasos como en una <strong>cadena de
montaje</strong>.</p></li>
</ul>
<div class="centered">
<p><img data-src="images/composicion-funciones.svg" class="plain"
style="width:80.0%" /></p>
</div>
</section>


<section id="métodos" class="title-slide slide level2"
data-number="3.4">
<h2 data-number="3.4"><span class="header-section-number">3.4</span>
Métodos</h2>
<ul>
<li><p>Los <strong>métodos</strong> son, para la <strong>programación
orientada a <em>objetos</em></strong>, el equivalente a las
<strong>funciones</strong> para la <strong>programación
<em>funcional</em></strong>.</p></li>
<li><p>En programación orientada a objetos, los objetos son
<strong>datos <em>activos</em> o <em>inteligentes</em></strong> a los
que podemos <strong>enviar mensajes</strong> y que son capaces de
<strong>reaccionar y responder</strong> ante la recepción de esos
mensajes.</p></li>
<li><p>Si le mandamos un mensaje a un objeto, <strong>le estamos
pidiendo que ejecute un método</strong>. Al hacerlo, el objeto está
<strong>respondiendo</strong> a la recepción de ese mensaje.</p></li>
<li><p><strong>Los métodos son como funciones</strong> pero, al llamar a
un método, en la lista de argumentos siempre hay uno especialmente
destacado, que es <strong>el objeto que recibe la orden de ejecutar el
método</strong> y que, por tanto, es el objeto sobre el que recae
directamente la acción del método.</p></li>
<li><p>Por eso decimos que el objeto es quien ejecuta el método, o que
el método se invoca (o se llama) <strong>sobre ese
objeto</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.4.0.0.1">

<ul>
<li><p>La gramática de las llamadas a métodos es la siguiente:</p>
<div class="line-block"><span
style="color:teal">⟨<em>llamada_método</em>⟩</span> ::= <span
style="color:teal">⟨<em>objeto</em>⟩</span><strong><code>.</code></strong><span
style="color:teal">⟨<em>método</em>⟩</span><strong><code>(</code></strong>[<span
style="color:teal">⟨<em>lista_argumentos</em>⟩</span>]<strong><code>)</code></strong><br />
<span style="color:teal">⟨<em>objeto</em>⟩</span> ::= <span
style="color:teal">⟨<em>expresión</em>⟩</span><br />
<span style="color:teal">⟨<em>método</em>⟩</span> ::=
<strong><code>identificador</code></strong><br />
<span style="color:teal">⟨<em>lista_argumentos</em>⟩</span> ::= <span
style="color:teal">⟨<em>expresión</em>⟩</span>(<strong><code>,</code></strong>
<span style="color:teal">⟨<em>expresión</em>⟩</span>)*</div></li>
<li><p>Según esta gramática, las llamadas a métodos tienen esta
forma:</p>
<p><span
class="math display">o\texttt{.}m\texttt{(}a_1\texttt{,}\  a_2\texttt{,}\  \ldots\texttt{,}\  a_n\texttt{)}</span></p>
<p>donde:</p>
<ul>
<li><p><span class="math inline">\underline{o}</span> es el
<strong>objeto</strong> que recibe el mensaje (dicho de otra forma: el
objeto sobre el que se ejecuta el método).</p></li>
<li><p><span class="math inline">\underline{m}</span> es el
<strong>nombre</strong> del método.</p></li>
<li><p><span class="math inline">\underline{a_1}, \underline{a_2},
\ldots, \underline{a_n}</span> son los <strong>argumentos</strong> del
método (si los hay).</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.4.0.0.2">

<ul>
<li><p>Esta llamada se puede leer de cualquiera de estas formas:</p>
<ul>
<li><p>«Se <strong>llama</strong> (o <strong>invoca</strong>) al método
<span class="math inline">\underline{m}</span> sobre el objeto <span
class="math inline">\underline{o}</span> con los argumentos <span
class="math inline">\underline{a_1}, \underline{a_2},
\ldots, \underline{a_n}</span>».</p></li>
<li><p>«Se <strong>ejecuta</strong> el método <span
class="math inline">\underline{m}</span> sobre el objeto <span
class="math inline">\underline{o}</span> con los argumentos <span
class="math inline">\underline{a_1}, \underline{a_2}, \ldots,
\underline{a_n}</span>».</p></li>
<li><p>«Se <strong>envía el mensaje</strong> <span
class="math inline">\underline{m}</span> al objeto <span
class="math inline">\underline{o}</span> con los argumentos <span
class="math inline">\underline{a_1}, \underline{a_2}, \ldots,
\underline{a_n}</span>».</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.4.0.0.3">

<ul>
<li><p>En la práctica, no habría mucha diferencia entre tener un método
y hacer:</p>
<p><span
class="math display">o\texttt{.}m\texttt{(}a_1\texttt{,}\  a_2\texttt{,}\  \ldots\texttt{,}\  a_n\texttt{)}</span></p>
<p>y tener una función y hacer:</p>
<p><span class="math display">m\texttt{(}o\texttt{,}\
a_1\texttt{,}\  a_2\texttt{,}\  \ldots\texttt{,}\  a_n\texttt{)}</span></p></li>
<li><p>Pero conceptualmente, hay una gran diferencia entre un estilo y
otro:</p>
<ul>
<li><p>El primero es más <strong>orientado a objetos</strong>: decimos
que el <em>objeto</em> <span class="math inline">\underline{o}</span>
«recibe» un mensaje solicitando la ejecución del método <span
class="math inline">\underline{m}</span>.</p></li>
<li><p>En cambio, el segundo es más <strong>funcional</strong>: decimos
que la <em>función</em> <span class="math inline">\underline{m}</span>
se aplica a sus argumentos, de los cuales <span
class="math inline">\underline{o}</span> es uno más.</p></li>
</ul></li>
<li><p>Python es un lenguaje <em>multiparadigma</em> que soporta ambos
estilos y, por tanto, dispone de funciones y de métodos. Hasta que no
estudiemos la orientación a objetos, supondremos que un método es como
otra forma sintáctica de escribir una función.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.4.0.0.4">

<ul>
<li><p>Por ejemplo:</p>
<p>Las cadenas responden al método <code
class="sourceCode python">count</code>, que devuelve el número de veces
que aparece una subcadena dentro de la cadena:</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="st">&#39;hola caracola&#39;</span>.count(<span class="st">&#39;ol&#39;</span>)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="st">&#39;hola caracola&#39;</span>.count(<span class="st">&#39;a&#39;</span>)</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="dv">4</span></span></code></pre></div></li>
<li><p>Si <code class="sourceCode python">count</code> fuese una función
en Python en lugar de un método (cosa que no ocurre), recibiría dos
parámetros: la cadena y la subcadena. En tal caso, se usaría así:</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>count(<span class="st">&#39;hola caracola&#39;</span>, <span class="st">&#39;ol&#39;</span>)</span></code></pre></div>
<p>(Esto no funciona en Python.)</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.4.0.0.5">

<ul>
<li><p>Hemos visto que, para acceder a un método de un objeto, se
utiliza el <strong>operador <em>punto</em>
(<code>.</code>)</strong>.</p></li>
<li><p>Es un operador <em>binario</em>, por lo que requiere dos
operandos.</p></li>
<li><p>Su <strong>operando izquierdo</strong> debe ser un
<strong><em>objeto</em></strong>:</p>
<ul>
<li><p>Técnicamente, un <strong>objeto</strong> es un valor estructurado
que contiene elementos a los que se puede acceder mediante su
nombre.</p></li>
<li><p>A los elementos que contiene un objeto se les denomina
<strong>atributos</strong> de ese objeto.</p></li>
<li><p>Por tanto, <strong>los métodos son atributos</strong>, aunque un
objeto puede tener otros atributos que no son métodos y que veremos en
posteriores temas.</p></li>
</ul></li>
<li><p>Su <strong>operando derecho</strong> debe ser el nombre de un
<em>atributo</em> contenido en dicho objeto.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.4.0.0.6">

<ul>
<li><p>Dos consecuencias interesantes de lo anterior:</p>
<ul>
<li><p>El nombre de un método (como <code
class="sourceCode python">count</code>) es el
<strong>identificador</strong> de un atributo que pertenece al objeto
sobre el que se ejecuta el método.</p></li>
<li><p>Si <span style="color:teal">⟨<em>método</em>⟩</span> es el nombre
de un método válido para el objeto <span
style="color:teal">⟨<em>objeto</em>⟩</span>, entonces la expresión <span
style="color:teal">⟨<em>objeto</em>⟩</span><code>.</code><span
style="color:teal">⟨<em>método</em>⟩</span> (sin paréntesis detrás)
<strong>nos devuelve el propio método en sí</strong>.</p></li>
</ul></li>
<li><p>Por tanto, si le pedimos al intérprete que nos muestre el valor
de la expresión <code
class="sourceCode python"><span class="st">&#39;hola&#39;</span>.count</code>,
nos dirá algo así:</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="st">&#39;hola&#39;</span>.count</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>built<span class="op">-</span><span class="kw">in</span> method count of <span class="bu">str</span> <span class="bu">object</span> at <span class="bn">0x7f41e9cb6870</span><span class="op">&gt;</span></span></code></pre></div>
<p>(Los métodos son casos especiales de funciones y, por tanto, no
tienen forma normal.)</p></li>
<li><p>En resumen: la expresión <code
class="sourceCode python"><span class="st">&#39;hola&#39;</span>.count</code>
devuelve el propio método, y la expresión <code
class="sourceCode python"><span class="st">&#39;hola&#39;</span>.count(<span class="st">&#39;o&#39;</span>)</code>
devuelve el valor <code
class="sourceCode python"><span class="dv">1</span></code>.</p></li>
</ul>
<div class="caja centered">
<p><strong>Conclusión: los métodos (como las funciones) también son
valores.</strong></p>
</div>
</section>
<section class="slide level5" data-number="3.4.0.0.7">

<ul>
<li><p>Como el método pertenece al objeto, sólo existe en el contexto de
ese objeto.</p></li>
<li><p>Eso quiere decir que la expresión <code
class="sourceCode python"><span class="st">&#39;hola&#39;</span>.count</code>
devuelve el método <code class="sourceCode python">count</code> definido
sobre los objetos de tipo <code
class="sourceCode python"><span class="bu">str</span></code>.</p></li>
<li><p>En cambio, <code class="sourceCode python">count</code>, por sí
solo, no es nada, ya que sería como intentar evaluar una
<em>función</em> llamada <code class="sourceCode python">count</code>,
que no existe en Python.</p></li>
<li><p>Por tanto, la evaluación de la expresión <code
class="sourceCode python"><span class="st">&#39;hola&#39;</span>.count(<span class="st">&#39;o&#39;</span>)</code>
se haría de la siguiente forma:</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="st">&#39;hola&#39;</span>.count(<span class="st">&#39;o&#39;</span>)      <span class="co"># se evalúa &#39;hola&#39; (devuelve &#39;hola&#39;)</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="st">&#39;hola&#39;</span>.count(<span class="st">&#39;o&#39;</span>)    <span class="co"># se evalúa &#39;hola&#39;.count (devuelve un método)</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="st">&#39;hola&#39;</span>.count(<span class="st">&#39;o&#39;</span>)    <span class="co"># se evalúa &#39;o&#39; (devuelve &#39;o&#39;)</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="st">&#39;hola&#39;</span>.count(<span class="st">&#39;o&#39;</span>)    <span class="co"># se evalúa &#39;hola&#39;.count(&#39;o&#39;) (devuelve 1)</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span></span></code></pre></div>
<p>Observar que en el segundo paso se evalúa <code
class="sourceCode python"><span class="st">&#39;hola&#39;</span>.count</code>
y no <code class="sourceCode python">count</code>, ya que <code
class="sourceCode python">count</code> es un atributo del objeto <code
class="sourceCode python"><span class="st">&#39;hola&#39;</span></code>
y no existe fuera de las cadenas.</p></li>
</ul>
</section>
</section>
<section id="bibliografía"
class="title-slide slide level1 unnumbered unlisted">
<h1 class="unnumbered unlisted">Bibliografía</h1>
<div id="refs" class="references csl-bib-body hanging-indent"
data-entry-spacing="0" role="list">
<div id="ref-abelson_structure_1996" class="csl-entry" role="listitem">
Abelson, Harold, Gerald Jay Sussman, and Julie Sussman. 1996.
<em>Structure and Interpretation of Computer Programs</em>. 2nd ed.
Cambridge, Mass. : New York: MIT Press ; McGraw-Hill.
</div>
<div id="ref-blanco_calculo_2009" class="csl-entry" role="listitem">
Blanco, Javier, Silvina Smith, and Damián Barsotti. 2009. <em>Cálculo de
Programas</em>. Córdoba, Argentina: Universidad Nacional de Córdoba.
</div>
<div id="ref-python_software_foundation_sitio_nodate" class="csl-entry"
role="listitem">
Python Software Foundation. n.d. <span>“Sitio Web de Documentación de
<span>Python</span>.”</span> <a
href="https://docs.python.org/3">https://docs.python.org/3</a>.
</div>
<div id="ref-van-roy_concepts_2004" class="csl-entry" role="listitem">
Van-Roy, Peter, and Seif Haridi. 2004. <em>Concepts, Techniques, and
Models of Computer Programming</em>. Cambridge, Mass: MIT Press.
</div>
</div>
</section>
    </div>
  </div>

  <script src="./reveal.js/dist/reveal.js"></script>

  <!-- reveal.js plugins -->
  <script src="./reveal.js/plugin/notes/notes.js"></script>
  <script src="./reveal.js/plugin/search/search.js"></script>
  <script src="./reveal.js/plugin/zoom/zoom.js"></script>
  <script src="./reveal.js/plugin/reveal.js-menu/menu.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
        // Display controls in the bottom right corner
        controls: true,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: true,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'bottom-right',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: true,

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: false,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'default',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: true,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'slide',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'fade',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1280,

        height: 1080,
        // The display mode that will be used to show slides
        display: 'block',

        menu: {
          hideMissingTitles: true,
        },

        dependencies: [
          { src: './reveal.js/plugin/reveal.js-quiz/quiz/js/quiz.js', async: true, callback: function() { prepareQuizzes({preventUnanswered: true, checkAnswerText: 'Comprueba la respuesta', nextQuestionText: 'Siguiente &raquo;', backButtonText: '&laquo; Anterior', tryAgainText: 'Prueba de nuevo', preventUnansweredText: 'Selecciona una respuesta', questionCountText: 'Pregunta %current de %total', skipStartButton: true}); } }
        ],

        // reveal.js plugins
        plugins: [
          RevealMenu,
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    <script type="text/javascript">
       var title = document.getElementsByClassName('title')[0];
       title = title != null ? title.innerHTML : '';
       var author = document.getElementsByClassName('author')[0];
       author = author != null ? author.innerHTML : '';
       var date = document.getElementsByClassName('date')[0];
       date = date != null ? date.innerHTML : '';
       document.getElementById('header-left').innerHTML = '<a href="#/title-slide">' + title + '</a>';
       document.getElementById('footer-left').innerHTML = '<a href="https://pro.iesdonana.org">&copy; ' + author + ' (' + date + ')</a>';

       function updateHeader(nd) {
           var hr = document.getElementById('header-right');
           while (hr.children.length > 0) {
               hr.removeChild(hr.lastChild);
           }
           buscar(nd, 3, hr);
           buscar(nd, 2, hr);
           buscar(nd, 1, hr);
           hr.style.fontSize = Math.round(50 * Reveal.getScale()) + '%';
           hr.style.fontSize = Math.max(Number.parseInt(getComputedStyle(hr).fontSize), 12) + 'px';
           var hl = document.getElementById('header-left');
           hl.style.fontSize = hr.style.fontSize;
       }

       function buscar(nd, level, hr) {
           if (!nd.classList.contains('level' + (level - 1))) {
               for (var n = nd; n != null; n = n.previousSibling) {
                   if (n.nodeType == Node.TEXT_NODE) {
                       continue;
                   }
                   var cl = n.classList;
                   if (cl.contains('level' + level)) {
                       var h = n.querySelector('h' + level);
                   } else if (cl.contains('level' + (level - 1))) {
                       break;
                   } else {
                       continue;
                   }
                   if (h == null || Reveal.getCurrentSlide().id == 'title-slide') {
                       hr.innerHTML = '';
                   } else {
                       var el = document.createElement('a');
                       var href = '#/' + n.id;
                       el.href = href;
                       el.innerHTML = h.innerHTML;
                       var a = el.querySelector('a');
                       if (a !== null) {
                           a.href = href;
                       }
                       if (hr.innerHTML != '') {
                           hr.innerHTML = ' &mdash; ' + hr.innerHTML;
                       }
                       hr.insertBefore(el, hr.firstChild);
                   }
                   break;
               }
           }
       }

       // On Reveal.js ready event, copy header/footer <div>
       // into each `.slide-background` <div>
       Reveal.on('ready', event => {
           var header = document.getElementById('header');
           document.querySelector('.reveal').appendChild(header);
           updateHeader(Reveal.getCurrentSlide());
       });

       Reveal.on('slidechanged', event => {
           // event.previousSlide, event.currentSlide, event.indexh, event.indexv
           updateHeader(event.currentSlide);
       });
    </script>
    </body>
</html>
