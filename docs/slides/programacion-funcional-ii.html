<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Ricardo Pérez López">
  <title>Programación funcional II</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="shortcut icon" type="image/png" href="/assets/icons/icon.png">
  <link rel="stylesheet" href="reveal.js/css/reveal.css">
  <style type="text/css">
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #cb4b16; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #d33682; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #dc322f; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #93a1a1; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #268bd2; } /* DataType */
code span.dv { color: #d33682; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #d33682; } /* Float */
code span.fu { color: #268bd2; } /* Function */
code span.im { font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #268bd2; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #a57800; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #2aa198; } /* SpecialString */
code span.st { color: #2aa198; } /* String */
code span.va { color: #6c71c4; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="reveal.js/css/theme/solarized.css" id="theme">
  <link rel="stylesheet" href="custom.css"/>
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
    var mathElements = document.getElementsByClassName("math");
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") { katex.render(texText.data, mathElements[i], { displayMode: mathElements[i].classList.contains("display"), throwOnError: false } );
    }}});</script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css" />
  <link href="https://fonts.googleapis.com/css?family=Lato&display=swap" rel="stylesheet">
  <style type="text/css">
      #header-left {
          position: absolute;
          font-size: 25%;
          top: 0%;
          left: 0%;
          margin-left: 10px;
          margin-top: 10px;
      }
      #header-right {
          position: absolute;
          font-size: 25%;
          top: 0%;
          right: 0%;
          margin-right: 10px;
          margin-top: 10px;
      }
      #footer-left {
          position: absolute;
          font-size: 25%;
          bottom: 0%;
          left: 0%;
          margin-left: 10px;
          margin-bottom: 10px;
      }
  </style>
</head>
<body>
<div id="hidden" style="display:none;">
    <div id="header">
        <div id="header-left"></div>
        <div id="header-right"></div>
        <div id="footer-left"></div>
    </div>
</div>
<script type="text/javascript">
    document.addEventListener("DOMContentLoaded", function(event) {
        var title = document.getElementsByClassName('title')[0];
        title = title != null ? title.innerHTML : '';
        var author = document.getElementsByClassName('author')[0];
        author = author != null ? author.innerHTML : '';
        var date = document.getElementsByClassName('date')[0];
        date = date != null ? date.innerHTML : '';
        var el = document.createElement('a');
        var href = '#/title-slide';
        el.href = href;
        el.innerHTML = title;
        document.getElementById('header-left').appendChild(el);
        document.getElementById('footer-left').innerHTML = '&copy; ' + author + ' (' + date + ')';

        function updateHeader(nd) {
            var hr = document.getElementById('header-right');
            while (hr.children.length > 0) {
                hr.removeChild(hr.lastChild);
            }
            buscar(nd, 3, hr);
            buscar(nd, 2, hr);
            buscar(nd, 1, hr);
            hr.style.fontSize = Math.round(50 * Reveal.getScale()) + '%';
            hr.style.fontSize = Math.max(Number.parseInt(getComputedStyle(hr).fontSize), 12) + 'px';
            var hl = document.getElementById('header-left');
            hl.style.fontSize = hr.style.fontSize;
        }

        function buscar(nd, level, hr) {
            if (!nd.classList.contains('level' + (level - 1))) {
                for (var n = nd; n != null; n = n.previousSibling) {
                    var cl = n.classList;
                    if (cl.contains('level' + level)) {
                        var h = n.querySelector('h' + level);
                    } else if (cl.contains('level' + (level - 1))) {
                        break;
                    } else {
                        continue;
                    }
                    if (h == null || Reveal.getCurrentSlide().id == 'title-slide') {
                        hr.innerHTML = '';
                    } else {
                        var el = document.createElement('a');
                        var href = '#/' + n.id;
                        el.href = href;
                        el.innerHTML = h.innerHTML;
                        var a = el.querySelector('a');
                        if (a !== null) {
                            a.href = href;
                        }
                    }
                    if (hr.innerHTML != '') {
                        hr.innerHTML = ' &mdash; ' + hr.innerHTML;
                    }
                    hr.insertBefore(el, hr.firstChild);
                    break;
                }
            }
        }

        // On Reveal.js ready event, copy header/footer <div>
        // into each `.slide-background` <div>
        Reveal.addEventListener('ready', function(event) {
            var header = document.getElementById('header');
            document.querySelector('.reveal').appendChild(header);
            updateHeader(Reveal.getCurrentSlide());
        });

        Reveal.addEventListener('slidechanged', function(event) {
            // event.previousSlide, event.currentSlide, event.indexh, event.indexv
            updateHeader(event.currentSlide);
        });
    });
</script>
  <div class="reveal">
    <div class="slides">

<section>
<section id="title-slide" class="title-slide slide level1">
  <h1 class="title">Programación funcional II</h1>
  <p class="author">Ricardo Pérez López</p>
  <p class="date">IES Doñana, curso 2019/2020</p>
</section>
<section id="TOC" class="slide level2">
<ul>
<li><a href="#/abstracciones-funcionales"><span class="toc-section-number">1</span> Abstracciones funcionales</a></li>
<li><a href="#/composición-de-funciones"><span class="toc-section-number">2</span> Composición de funciones</a></li>
<li><a href="#/tipos-de-datos-compuestos"><span class="toc-section-number">3</span> Tipos de datos compuestos</a></li>
<li><a href="#/computabilidad"><span class="toc-section-number">4</span> Computabilidad</a></li>
<li><a href="#/funciones-de-orden-superior"><span class="toc-section-number">5</span> Funciones de orden superior</a></li>
</ul>
</section>
</section>

<section><section id="abstracciones-funcionales" class="title-slide slide level1"><h1><span class="header-section-number">1</span> Abstracciones funcionales</h1></section><section id="expresiones-lambda" class="title-slide slide level2"><h2><span class="header-section-number">1.1</span> Expresiones lambda</h2><ul>
<li><p>Las <strong>expresiones lambda</strong> (también llamadas <strong>abstracciones lambda</strong> o <strong>funciones anónimas</strong> en algunos lenguajes) son expresiones que capturan la idea abstracta de «<strong>función</strong>».</p></li>
<li><p>Son la forma más simple y primitiva de describir funciones en un lenguaje funcional.</p></li>
<li><p>Su sintaxis (simplificada) es:</p>
<div class="line-block"><span style="color:teal"><em>&lt;expr_lambda&gt;</em></span> ::= <strong><code>lambda</code></strong> [<span style="color:teal"><em>&lt;lista_parámetros&gt;</em></span>] <strong><code>:</code></strong> <span style="color:teal"><em>&lt;expresión&gt;</em></span><br />
<span style="color:teal"><em>&lt;lista_parámetros&gt;</em></span> := <span style="color:teal"><em>&lt;identificador&gt;</em></span> (<strong><code>,</code></strong> <span style="color:teal"><em>&lt;identificador&gt;</em></span>)*</div></li>
<li><p>Por ejemplo:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">lambda</span> x, y: x <span class="op">+</span> y</a></code></pre></div></li>
</ul></section><section id="parámetros-y-cuerpos" class="title-slide slide level3"><h3><span class="header-section-number">1.1.1</span> Parámetros y cuerpos</h3><ul>
<li><p>Los identificadores que aparecen entre la palabra clave <code>lambda</code> y el carácter de dos puntos (<code>:</code>) son los <strong>parámetros</strong> de la expresión lambda.</p></li>
<li><p>La expresión que aparece tras los dos puntos (<code>:</code>) es el <strong>cuerpo</strong> de la expresión lambda.</p></li>
<li><p>En el ejemplo anterior:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">lambda</span> x, y: x <span class="op">+</span> y</a></code></pre></div>
<ul>
<li><p>Los parámetros son <code>x</code> e <code>y</code>.</p></li>
<li><p>El cuerpo es <code>x + y</code>.</p></li>
<li><p>Esta expresión lambda captura la idea general de sumar dos valores (que en principio pueden ser de cualquier tipo, siempre y cuando admitan el operador <code>+</code>).</p></li>
</ul></li>
</ul></section><section id="aplicación-funcional" class="title-slide slide level3"><h3><span class="header-section-number">1.1.2</span> Aplicación funcional</h3><ul>
<li><p>De la misma manera que decíamos que podemos aplicar una función a unos argumentos, también podemos aplicar una expresión lambda a unos argumentos.</p></li>
<li><p>Recordemos que <em>aplicar</em> una función a unos argumentos producía el valor que la función asocia a esos argumentos en el conjunto imagen.</p></li>
<li><p>Por ejemplo, la aplicación de la función <span class="math inline">max</span> sobre los argumentos <span class="math inline">3</span> y <span class="math inline">5</span> se denota como <span class="math inline">max(3, 5)</span> y eso denota el valor <span class="math inline">5</span>.</p></li>
<li><p>Igualmente, la aplicación de una expresión lambda como</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">lambda</span> x, y: x <span class="op">+</span> y</a></code></pre></div>
<p>sobre los argumentos <code>4</code> y <code>3</code> se representa así:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1">(<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>)</a></code></pre></div></li>
</ul></section><section class="slide level4">

<ul>
<li><p>Si hacemos la siguiente definición:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb5-1" title="1">suma <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y</a></code></pre></div>
<p>a partir de ese momento podemos usar <code>suma</code> en lugar de su valor (la expresión lambda), por lo que podemos hacer:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" title="1">suma(<span class="dv">4</span>, <span class="dv">3</span>)</a></code></pre></div>
<p>en lugar de</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb7-1" title="1">(<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>)</a></code></pre></div></li>
</ul>
</section><section id="evaluación-de-una-aplicación-funcional" class="slide level4">
<h4><span class="header-section-number">1.1.2.2</span> Evaluación de una aplicación funcional</h4>
<ul>
<li><p>En nuestro modelo de sustitución, la <strong>evaluación de la aplicación de una expresión lambda</strong> consiste en <strong>sustituir</strong>, en el cuerpo de la expresión lambda, <strong>cada parámetro por su argumento correspondiente</strong> (por orden) y devolver la expresión resultante <em>parentizada</em> (entre paréntesis).</p></li>
<li><p>A esta operación se la denomina <strong>aplicación funcional</strong> o <strong>β-reducción</strong>.</p></li>
<li><p>Siguiendo con el ejemplo anterior:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb8-1" title="1">(<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>)</a></code></pre></div>
<p>sustituimos en el cuerpo de la expresión lambda los parámetros <code>x</code> e <code>y</code> por los argumentos <code>4</code> y <code>3</code>, respectivamente, y parentizamos la expresión resultante, lo que da:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb9-1" title="1">(<span class="dv">4</span> <span class="op">+</span> <span class="dv">3</span>)</a></code></pre></div>
<p>que simplificando (según las reglas del operador <code>+</code>) da <code>7</code>.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Lo mismo podemos hacer si definimos previamente la expresión lambda ligándola a un identificador:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb10-1" title="1">suma <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y</a></code></pre></div></li>
<li><p>Así, la aplicación de la expresión lambda resulta más fácil y clara de escribir:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb11-1" title="1">suma(<span class="dv">4</span>, <span class="dv">3</span>)</a></code></pre></div></li>
<li><p>En ambos casos, el resultado es el mismo (<code>7</code>).</p>
<div class="caja">
<p><strong>Importante:</strong></p>
<p>En <strong>Python</strong>, el <strong>orden de evaluación</strong> de cualquier expresión es <strong>de izquierda a derecha</strong>.</p>
</div></li>
</ul>
</section><section id="ejemplos" class="slide level4">
<h4><span class="header-section-number">1.1.2.4</span> Ejemplos</h4>
<ul>
<li><p>Dado el siguiente código:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb12-1" title="1">suma <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y</a></code></pre></div>
<p>¿Cuánto vale la expresión siguiente?</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb13-1" title="1">suma(<span class="dv">4</span>, <span class="dv">3</span>) <span class="op">*</span> suma(<span class="dv">2</span>, <span class="dv">7</span>)</a></code></pre></div>
<p>Según el modelo de sustitución, reescribimos:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb14-1" title="1">suma(<span class="dv">4</span>,<span class="dv">3</span>) <span class="op">*</span> suma(<span class="dv">2</span>, <span class="dv">7</span>)</a>
<a class="sourceLine" id="cb14-2" title="2"><span class="op">=</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>) <span class="op">*</span> suma(<span class="dv">2</span>, <span class="dv">7</span>)</a>
<a class="sourceLine" id="cb14-3" title="3"><span class="op">=</span> (<span class="dv">4</span> <span class="op">+</span> <span class="dv">3</span>) <span class="op">*</span> suma(<span class="dv">2</span>, <span class="dv">7</span>)</a>
<a class="sourceLine" id="cb14-4" title="4"><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> suma(<span class="dv">2</span>, <span class="dv">7</span>)</a>
<a class="sourceLine" id="cb14-5" title="5"><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">2</span>, <span class="dv">7</span>)</a>
<a class="sourceLine" id="cb14-6" title="6"><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> (<span class="dv">2</span> <span class="op">+</span> <span class="dv">7</span>)</a>
<a class="sourceLine" id="cb14-7" title="7"><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> <span class="dv">9</span></a>
<a class="sourceLine" id="cb14-8" title="8"><span class="op">=</span> <span class="dv">63</span></a></code></pre></div></li>
</ul>
</section><section id="variables-ligadas-y-libres" class="title-slide slide level3"><h3><span class="header-section-number">1.1.3</span> Variables ligadas y libres</h3><ul>
<li><p>Si un identificador aparece en la lista de parámetros de la expresión lambda, a ese identificador le llamamos <strong>variable ligada</strong> de la expresión lambda.</p></li>
<li><p>En caso contrario, le llamamos <strong>variable libre</strong> de la expresión lambda.</p></li>
<li><p>En el ejemplo anterior:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">lambda</span> x, y: x <span class="op">+</span> y</a></code></pre></div>
<p>los dos identificadores que aparecen en el cuerpo (<code>x</code> e <code>y</code>) son variables ligadas, ya que ambos aparecen en la lista de parámetros de la expresión lambda.</p></li>
<li><p>En cambio, en la expresión lambda:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">lambda</span> x, y: x <span class="op">+</span> y <span class="op">+</span> z</a></code></pre></div>
<p><code>x</code> e <code>y</code> son variables ligadas mientras que <code>z</code> es libre.</p></li>
</ul></section><section class="slide level4">

<ul>
<li><p>Para que una expresión lambda funcione, sus variables libres deben estar ligadas a algún valor en el entorno <strong>en el momento de evaluar una aplicación</strong> de la expresión lambda sobre unos argumentos.</p></li>
<li><p>Por ejemplo:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb17-1" title="1">prueba <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y <span class="op">+</span> z</a>
<a class="sourceLine" id="cb17-2" title="2">prueba(<span class="dv">4</span>, <span class="dv">3</span>)</a></code></pre></div>
<p>da error porque <code>z</code> no está definido (no está ligado a ningún valor en el entorno).</p></li>
<li><p>En cambio:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode numberSource python number-lines"><code class="sourceCode python"><a class="sourceLine" id="cb18-1" title="1">prueba <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y <span class="op">+</span> z</a>
<a class="sourceLine" id="cb18-2" title="2">z <span class="op">=</span> <span class="dv">9</span></a>
<a class="sourceLine" id="cb18-3" title="3">prueba(<span class="dv">4</span>, <span class="dv">3</span>)</a></code></pre></div>
<p>sí funciona (y devuelve <code>16</code>) porque en el momento de evaluar la expresión lambda (en la línea 3) el identificador <code>z</code> está ligado a un valor (<code>9</code>).</p></li>
<li><p>Observar que no es necesario que las variables libres estén ligadas en el entorno cuando se <em>crea</em> la expresión lambda, sino cuando se <em>aplica</em>.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Una expresión lambda cuyo cuerpo sólo contiene variables ligadas, es una expresión cuyo valor sólo va a depender de los argumentos que se usen cuando se aplique la expresión lambda.</p></li>
<li><p>En cambio, el valor de una expresión lambda que contenga variables libres dependerá no sólo de los valores de sus argumentos, sino también de los valores a los que estén ligadas las variables libres al evaluar la expresión lambda.</p></li>
<li><p>Por ejemplo, podemos escribir una expresión lambda que calcule la suma de tres números a partir de otra expresión lambda que calcule la suma de dos números:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb19-1" title="1"><span class="kw">lambda</span> x, y, z: suma(x, y) <span class="op">+</span> z</a></code></pre></div>
<p>En este caso, hay un identificador (<code>suma</code>) que no aparece en la lista de parámetros de la expresión lambda (por lo que es una variable libre).</p>
<p>Por tanto, el valor de la expresión lambda anterior dependerá de lo que valga <code>suma</code> (de lo que haga, de lo que devuelva…).</p></li>
</ul>
</section><section id="ámbito-de-una-variable-ligada" class="title-slide slide level3"><h3><span class="header-section-number">1.1.4</span> Ámbito de una variable ligada</h3><ul>
<li><p>Recordemos que el <strong>ámbito de una ligadura</strong> es la porción del programa en la que dicha ligadura tiene validez.</p></li>
<li><p>Hemos visto que <strong>un parámetro</strong> de una expresión lambda <strong>es una variable ligada</strong> en el cuerpo de dicha expresión lambda.</p></li>
<li><p>En realidad, lo que hace la expresión lambda es <strong>ligar al parámetro con la variable ligada que está dentro del cuerpo</strong>, y esa ligadura existe únicamente en el cuerpo de la expresión lambda.</p></li>
<li><p>Por tanto, <strong>el ámbito de una variable ligada es el cuerpo de la expresión lambda</strong> que la liga con su parámetro.</p></li>
<li><p>También se dice que la variable ligada tiene un <strong>ámbito local</strong> a la expresión lambda.</p></li>
<li><p>Por contraste, los identificadores que no tienen ámbito local se dice que tienen un <strong>ámbito global</strong>.</p></li>
</ul></section><section class="slide level4">

<ul>
<li><p>Por ejemplo:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode numberSource python number-lines"><code class="sourceCode python"><a class="sourceLine" id="cb20-1" title="1"><span class="co"># Aquí empieza el script (no hay más definiciones antes de esta línea):</span></a>
<a class="sourceLine" id="cb20-2" title="2">producto <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> x</a>
<a class="sourceLine" id="cb20-3" title="3">y <span class="op">=</span> producto(<span class="dv">3</span>)</a>
<a class="sourceLine" id="cb20-4" title="4">z <span class="op">=</span> x <span class="op">+</span> <span class="dv">1</span>       <span class="co"># da error</span></a></code></pre></div></li>
<li><p>La expresión lambda de la línea 2 tiene un parámetro (<code>x</code>) ligado a la variable ligada <code>x</code> situada en el cuerpo de la expresión lambda.</p></li>
<li><p>Por tanto, el ámbito de la variable ligada <code>x</code> es el <strong>cuerpo</strong> de la expresión lambda (<code>x * x</code>).</p></li>
<li><p>Eso quiere decir que, fuera de la expresión lambda, no es posible acceder al valor de la variable ligada, al encontrarnos <strong>fuera de su ámbito</strong>.</p></li>
<li><p>Por ello, la línea 4 dará un error al intentar acceder al valor de un identificador no ligado.</p></li>
</ul>
</section><section id="variables-sombreadas" class="title-slide slide level3"><h3><span class="header-section-number">1.1.5</span> Variables <em>sombreadas</em></h3><ul>
<li><p>¿Qué ocurre cuando una expresión lambda contiene como parámetros nombres que ya están definidos (ligados) en el entorno?</p></li>
<li><p>Por ejemplo:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode numberSource python number-lines"><code class="sourceCode python"><a class="sourceLine" id="cb21-1" title="1">x <span class="op">=</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb21-2" title="2">total <span class="op">=</span> (<span class="kw">lambda</span> x: x <span class="op">*</span> x)(<span class="dv">3</span>)  <span class="co"># Su valor es 9</span></a></code></pre></div></li>
<li><p>La <code>x</code> que aparece en la línea 1 es diferente a la que aparece en la lista de parámetros de la expresión lambda de la línea 2.</p></li>
</ul>
<!--

- Técnicamente, decimos que la expresión lambda introduce un nuevo *ámbito*
  (concepto que desarrollaremos más adelante).

-->
<ul>
<li><p>En este caso, decimos que <strong>el parámetro <code>x</code> <em>hace sombra</em></strong> al identificador <code>x</code> que, en el entorno, está ligado al valor 4.</p></li>
<li><p>Por tanto, el identificador <code>x</code> que aparece en el cuerpo de la expresión lambda <strong>hace referencia al parámetro <code>x</code> de la expresión lambda</strong>, y <strong>no</strong> al identificador <code>x</code> que está fuera de la expresión lambda (y que aquí está ligado al valor <code>4</code>).</p></li>
</ul></section><section class="slide level4">

<ul>
<li><p>Que el parámetro haga sombra al identificador de fuera significa que no podemos acceder a ese identificador externo desde el cuerpo de la expresión lambda como si fuera una variable libre.</p></li>
<li><p>Si necesitáramos acceder al valor de la <code>x</code> que está fuera de la expresión lambda, lo que podemos hacer es cambiar el nombre al parámetro <code>x</code>. Por ejemplo:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode numberSource python number-lines"><code class="sourceCode python"><a class="sourceLine" id="cb22-1" title="1">x <span class="op">=</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb22-2" title="2">total <span class="op">=</span> (<span class="kw">lambda</span> w: w <span class="op">*</span> x)(<span class="dv">3</span>)  <span class="co"># Su valor es 12</span></a></code></pre></div>
<p>Así, tendremos en la expresión lambda una variable ligada (el parámetro <code>w</code>) y una variable libre (el identificador <code>x</code>).</p></li>
</ul>
</section><section id="expresiones-lambda-y-entornos" class="title-slide slide level3"><h3><span class="header-section-number">1.1.6</span> Expresiones lambda y entornos</h3><ul>
<li><p>Recordemos que el <strong>entorno</strong> es el conjunto de todas las ligaduras que son accesibles en un punto concreto de un programa.</p></li>
<li><p>Para calcular el entorno en un punto dado, debemos tener en cuenta las ligaduras, así como los ámbitos de dichas ligaduras y las variables ligadas que hagan sombra a otras situadas en el mismo ámbito.</p></li>
</ul></section><section class="slide level4">

<ul>
<li><p>Por ejemplo:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode numberSource python number-lines"><code class="sourceCode python"><a class="sourceLine" id="cb23-1" title="1">x <span class="op">=</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb23-2" title="2">z <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb23-3" title="3">suma <span class="op">=</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y <span class="op">+</span> z)(<span class="dv">8</span>, <span class="dv">12</span>)</a>
<a class="sourceLine" id="cb23-4" title="4">y <span class="op">=</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb23-5" title="5">z <span class="op">=</span> <span class="dv">9</span></a></code></pre></div></li>
<li><p>En cada línea tendríamos los siguientes entornos:</p></li>
</ul>
<div class="columns">
<div class="column">
<figure>
<img data-src="images/lambda-entorno-linea1.svg" alt="Entorno en la línea 1" class="plain" style="width:50.0%" /><figcaption>Entorno en la línea 1</figcaption>
</figure>
<p></p>
</div><div class="column">
<figure>
<img data-src="images/lambda-entorno-linea2.svg" alt="Entorno en la línea 2" class="plain" style="width:50.0%" /><figcaption>Entorno en la línea 2</figcaption>
</figure>
<p></p>
</div>
</div>
</section><section class="slide level4">


<figure>
<img data-src="images/lambda-entorno-linea3.svg" alt="Entorno en la línea 3 fuera de la expresión lambda" class="plain" style="width:30.0%" /><figcaption>Entorno en la línea 3 fuera de la expresión lambda</figcaption>
</figure>
<p></p>
<p> </p>

<figure>
<img data-src="images/lambda-entorno-linea3-dentro.svg" alt="Entorno en la línea 3 en el cuerpo de la expresión lambda" class="plain" style="width:30.0%" /><figcaption>Entorno en la línea 3 en el cuerpo de la expresión lambda</figcaption>
</figure>
<p></p>
<!--

compound = true
node [fontname = "monospace"]
1 [shape = circle]
4 [shape = circle]
8 [shape = circle]
12 [shape = circle]
x [shape = plaintext, fillcolor = transparent, label = "x (global)"]
xl [shape = plaintext, fillcolor = transparent, label = "x (local)"]
yl [shape = plaintext, fillcolor = transparent, label = "y (local)"]
z [shape = plaintext, fillcolor = transparent, label = "z (global)"]

suma [shape = plaintext, fillcolor = transparent, label = "suma (global)"]
subgraph cluster0 {
    label = "lambda"
    bgcolor = white
    xl -> 8
    yl -> 12
}
suma -> xl [lhead = cluster0]
x -> 4
z -> 1

-->
</section><section class="slide level4">

<div class="columns">
<div class="column">
<figure>
<img data-src="images/lambda-entorno-linea4.svg" alt="Entorno en la línea 4" class="plain" style="width:40.0%" /><figcaption>Entorno en la línea 4</figcaption>
</figure>
<p></p>
</div><div class="column">
<figure>
<img data-src="images/lambda-entorno-linea5.svg" alt="Entorno en la línea 5" class="plain" style="width:40.0%" /><figcaption>Entorno en la línea 5</figcaption>
</figure>
<p></p>
</div>
</div>
</section><section id="renombrado-de-parámetros" class="title-slide slide level3"><h3><span class="header-section-number">1.1.7</span> Renombrado de parámetros</h3><ul>
<li><p>Los parámetros se pueden <em>renombrar</em> (siempre que se haga de forma adecuada) sin que se altere el significado de la expresión lambda.</p></li>
<li><p>A esta operación se la denomina <strong>α-conversión</strong>.</p></li>
<li><p>Un ejemplo de α-conversión es la que hicimos antes.</p></li>
<li><p>La α-conversión hay que hacerla correctamente para evitar efectos indeseados. Por ejemplo, en:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb24-1" title="1"><span class="kw">lambda</span> x, y: x <span class="op">+</span> y <span class="op">+</span> z</a></code></pre></div>
<p>si renombramos <code>x</code> a <code>z</code> tendríamos:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb25-1" title="1"><span class="kw">lambda</span> z, y: z <span class="op">+</span> y <span class="op">+</span> z</a></code></pre></div>
<p>lo que es claramente incorrecto. A este fenómeno indeseable se le denomina <strong>captura de variables</strong>.</p></li>
</ul></section><section id="estrategias-de-evaluación" class="title-slide slide level2"><h2><span class="header-section-number">1.2</span> Estrategias de evaluación</h2><ul>
<li><p>A la hora de evaluar una expresión existen varias estrategias diferentes que se pueden adoptar.</p></li>
<li><p>Cada lenguaje implementa sus propias estrategias de evaluación que están basadas en las que vamos a ver aquí.</p></li>
<li><p>Básicamente se trata de decidir, en cada paso de reducción, qué sub-expresión hay que reducir, en función de:</p>
<ul>
<li><p>El orden (de fuera adentro o de dentro afuera).</p></li>
<li><p>La necesidad o no de evaluar dicha expresión.</p></li>
</ul></li>
</ul></section><section id="orden-de-evaluación" class="title-slide slide level3"><h3><span class="header-section-number">1.2.1</span> Orden de evaluación</h3><ul>
<li><p>En un lenguaje de programación funcional puro se cumple la <strong>transparencia referencial</strong>, según la cual el valor de una expresión depende sólo del valor de sus sub-expresiones (también llamadas <em>redexes</em>).</p></li>
<li><p>Pero eso también implica que <strong>no importa el orden en el que se evalúen las sub-expresiones</strong>: el resultado debe ser siempre el mismo.</p></li>
<li><p>Gracias a ello podemos usar nuestro modelo de sustitución como modelo computacional.</p></li>
<li><p>Hay dos <strong>estrategias básicas de evaluación</strong>:</p>
<ul>
<li><p><strong>Orden aplicativo</strong>: reducir siempre el <em>redex</em> más <strong>interno</strong>.</p></li>
<li><p><strong>Orden normal</strong>: reducir siempre el <em>redex</em> más <strong>externo</strong>.</p></li>
</ul></li>
<li><p><strong>Python usa el orden aplicativo</strong>, salvo excepciones.</p></li>
</ul></section><section id="orden-aplicativo" class="slide level4">
<h4><span class="header-section-number">1.2.1.1</span> Orden aplicativo</h4>
<ul>
<li><p>El <strong>orden aplicativo</strong> consiste en evaluar las expresiones <em>de dentro afuera</em>, es decir, empezando siempre por el <em>redex</em> más <strong>interno</strong>.</p></li>
<li><p>Corresponde a lo que en muchos lenguajes de programación se denomina <strong>paso de argumentos por valor</strong>.</p></li>
<li><p>Ejemplo:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb26-1" title="1">cuadrado <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">*</span> x</a></code></pre></div>
<p>Según el orden aplicativo, la expresión <code>cuadrado(3 + 4)</code> se reduciría así:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb27-1" title="1">cuadrado(<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)</a>
<a class="sourceLine" id="cb27-2" title="2"><span class="op">=</span> cuadrado(<span class="dv">7</span>)</a>
<a class="sourceLine" id="cb27-3" title="3"><span class="op">=</span> (<span class="kw">lambda</span> x, y: x <span class="op">*</span> x)(<span class="dv">7</span>)</a>
<a class="sourceLine" id="cb27-4" title="4"><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> <span class="dv">7</span></a>
<a class="sourceLine" id="cb27-5" title="5"><span class="op">=</span> <span class="dv">49</span></a></code></pre></div>
<p>alcanzando la forma normal en 4 pasos de reducción.</p></li>
</ul>
</section><section id="orden-normal" class="slide level4">
<h4><span class="header-section-number">1.2.1.2</span> Orden normal</h4>
<ul>
<li><p>El <strong>orden normal</strong> consiste en evaluar las expresiones <em>de fuera adentro</em>, es decir, empezando siempre por el <em>redex</em> más <strong>externo</strong>.</p></li>
<li><p>Corresponde a lo que en muchos lenguajes de programación se denomina <strong>paso de argumentos por nombre</strong>.</p></li>
<li><p>Ejemplo:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb28-1" title="1">cuadrado <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">*</span> x</a></code></pre></div>
<p>Según el orden normal, la expresión <code>cuadrado(3 + 4)</code> se reduciría así:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb29-1" title="1">cuadrado(<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)</a>
<a class="sourceLine" id="cb29-2" title="2"><span class="op">=</span> (<span class="kw">lambda</span> x, y: x <span class="op">*</span> x)(<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)</a>
<a class="sourceLine" id="cb29-3" title="3"><span class="op">=</span> (<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>) <span class="op">*</span> (<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)</a>
<a class="sourceLine" id="cb29-4" title="4"><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)</a>
<a class="sourceLine" id="cb29-5" title="5"><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> <span class="dv">7</span></a>
<a class="sourceLine" id="cb29-6" title="6"><span class="op">=</span> <span class="dv">49</span></a></code></pre></div>
<p>alcanzando la forma normal en 5 pasos de reducción.</p></li>
</ul>
</section><section id="evaluación-estricta-y-no-estricta" class="title-slide slide level3"><h3><span class="header-section-number">1.2.2</span> Evaluación estricta y no estricta</h3><ul>
<li><p>Existe otra forma de ver la evaluación de una expresión:</p>
<ul>
<li><p><strong>Evaluación estricta</strong>: Reducir todos los <em>redexes</em> aunque no hagan falta.</p></li>
<li><p><strong>Evaluación no estricta</strong>: Reducir sólo los <em>redexes</em> que sean estrictamente necesarios para calcular el valor de la expresión.</p>
<p>A esta estrategia de evaluación se la denomina también <strong>evaluación perezosa</strong>.</p></li>
</ul></li>
</ul></section><section class="slide level4">

<ul>
<li><p>Por ejemplo:</p>
<p>Sabemos que la expresión <code>1/0</code> da un error de <em>división por cero</em>:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb30-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="dv">1</span><span class="op">/</span><span class="dv">0</span></a>
<a class="sourceLine" id="cb30-2" title="2">Traceback (most recent call last):</a>
<a class="sourceLine" id="cb30-3" title="3">File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb30-4" title="4"><span class="pp">ZeroDivisionError</span>: division by zero</a></code></pre></div></li>
<li><p>Supongamos que tenemos la siguiente definición:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb31-1" title="1">primero <span class="op">=</span> <span class="kw">lambda</span> x, y: x</a></code></pre></div>
<p>de forma que <code>primero</code> es una función que simplemente devuelve el primero de sus argumentos.</p></li>
<li><p>Es evidente que la función <code>primero</code> no necesita evaluar nunca su segundo argumento, ya que no lo utiliza (simplemente devuelve el primero de ellos). Por ejemplo, <code>primero(4, 3)</code> devuelve <code>3</code>.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Sabiendo eso… ¿qué valor devolvería la siguiente expresión?</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb32-1" title="1">primero(<span class="dv">4</span>, <span class="dv">1</span><span class="op">/</span><span class="dv">0</span>)</a></code></pre></div></li>
<li><p>Curiosamente, el resultado dependerá de si la evaluación es estricta o perezosa:</p>
<ul>
<li><p><strong>Si es estricta</strong>, el intérprete evaluará todos los argumentos de la expresión lambda aunque no se utilicen luego en su cuerpo. Por tanto, al evaluar <code>1/0</code> devolverá un error.</p>
<p>Es lo que ocurre cuando se evalúa siguiendo el <strong>orden aplicativo</strong>.</p></li>
<li><p>En cambio, <strong>si es perezosa</strong>, el intérprete evaluará únicamente aquellos argumentos que se usen en el cuerpo de la expresión lambda, y en este caso sólo se usa el primero, así que dejará sin evaluar el segundo, no dará error y devolverá directamente <code>4</code>.</p>
<p>Es lo que ocurre cuando se evalúa siguiendo el <strong>orden normal</strong>:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb33-1" title="1">primero(<span class="dv">4</span>, <span class="dv">1</span><span class="op">/</span><span class="dv">0</span>) <span class="op">=</span> (<span class="kw">lambda</span> x, y: x)(<span class="dv">4</span>, <span class="dv">1</span><span class="op">/</span><span class="dv">0</span>) <span class="op">=</span> <span class="dv">4</span></a></code></pre></div></li>
</ul></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>En <strong>Python</strong> la evaluación es <strong>estricta</strong>, salvo excepciones que veremos.</p></li>
<li><p>De hecho, la mayoría de los lenguajes de programación se basan en la evaluación estricta y el paso de argumentos por valor (por lo que siguen el orden aplicativo).</p></li>
<li><p><strong>Haskell</strong>, por ejemplo, es un lenguaje funcional puro que se basa en la evaluación perezosa y sigue el orden normal.</p></li>
<li><p>Todo tiene ventajas e inconvenientes.</p></li>
</ul>
</section><section id="funciones-y-procesos" class="title-slide slide level2"><h2><span class="header-section-number">1.3</span> Funciones y procesos</h2><ul>
<li><p>Los <strong>procesos</strong> son entidades abstractas que habitan los ordenadores.</p></li>
<li><p>Conforme van evolucionando, los procesos manipulan otras entidades abstractas llamadas <strong>datos</strong>.</p></li>
<li><p>La evolución de un proceso está dirigida por un patrón de reglas llamada <strong>programa</strong>.</p></li>
<li><p>Los programadores crean programas para dirigir a los procesos.</p></li>
<li><p>Es como decir que los programadores son magos que invocan a los espíritus del ordenador con sus conjuros.</p></li>
</ul></section><section class="slide level4">

<ul>
<li><p>Una función describe la evolución local de un <strong>proceso</strong>.</p></li>
<li><p>En cada paso se calcula el siguiente estado del proceso basándonos en el estado actual y en las reglas definidas por la función.</p></li>
<li><p>Nos gustaría ser capaces de visualizar y de realizar afirmaciones sobre el comportamiento global del proceso cuya evolución local está definida por la función.</p></li>
<li><p>Esto, en general, es muy difícil, pero al menos vamos a describir algunos de los modelos típicos de evolución de los procesos.</p></li>
</ul>
</section><section id="registros-de-activación" class="title-slide slide level2"><h2><span class="header-section-number">1.4</span> Registros de activación</h2></section></section>
<section id="composición-de-funciones" class="title-slide slide level1"><h1><span class="header-section-number">2</span> Composición de funciones</h1></section>
<section><section id="tipos-de-datos-compuestos" class="title-slide slide level1"><h1><span class="header-section-number">3</span> Tipos de datos compuestos</h1></section><section id="cadenas" class="title-slide slide level2"><h2><span class="header-section-number">3.1</span> Cadenas</h2></section><section id="listas" class="title-slide slide level2"><h2><span class="header-section-number">3.2</span> Listas</h2></section></section>
<section><section id="computabilidad" class="title-slide slide level1"><h1><span class="header-section-number">4</span> Computabilidad</h1></section><section id="funciones-recursivas" class="title-slide slide level2"><h2><span class="header-section-number">4.1</span> Funciones recursivas</h2></section><section id="recursividad-lineal" class="title-slide slide level3"><h3><span class="header-section-number">4.1.1</span> Recursividad lineal</h3></section><section id="procesos-lineales-recursivos" class="slide level4">
<h4><span class="header-section-number">4.1.1.1</span> Procesos lineales recursivos</h4>
</section><section id="procesos-lineales-iterativos" class="slide level4">
<h4><span class="header-section-number">4.1.1.2</span> Procesos lineales iterativos</h4>
</section><section id="recursividad-en-árbol" class="title-slide slide level3"><h3><span class="header-section-number">4.1.2</span> Recursividad en árbol</h3></section><section id="un-lenguaje-turing-completo" class="title-slide slide level2"><h2><span class="header-section-number">4.2</span> Un lenguaje Turing-completo</h2></section></section>
<section><section id="funciones-de-orden-superior" class="title-slide slide level1"><h1><span class="header-section-number">5</span> Funciones de orden superior</h1></section><section id="map" class="title-slide slide level2"><h2><span class="header-section-number">5.1</span> <code>map()</code></h2></section><section id="filter" class="title-slide slide level2"><h2><span class="header-section-number">5.2</span> <code>filter()</code></h2></section><section id="reduce" class="title-slide slide level2"><h2><span class="header-section-number">5.3</span> <code>reduce()</code></h2></section></section>
    </div>
  </div>

  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Display the page number of the current slide
        slideNumber: true,
        // Push each slide change to the browser history
        history: true,
        // Transition style
        transition: 'slide', // none/fade/slide/convex/concave/zoom
        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1280,
        height: 1080,

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'reveal.js/plugin/notes/notes.js', async: true },
          { src: 'reveal.js/plugin/reveal.js-menu/menu.js', async: true },
          { src: 'reveal.js/plugin/reveal.js-quiz/quiz/js/quiz.js', async: true, callback: function() { prepareQuizzes({preventUnanswered: true, checkAnswerText: 'Comprueba la respuesta', nextQuestionText: 'Siguiente &raquo;', backButtonText: '&laquo; Anterior', tryAgainText: 'Prueba de nuevo', preventUnansweredText: 'Selecciona una respuesta', questionCountText: 'Pregunta %current de %total', skipStartButton: true}); } },
          { src: 'reveal.js/plugin/reveal-code-focus/vendor/highlight.js/highlight.pack.js' },
          { src: 'reveal.js/plugin/reveal-code-focus/reveal-code-focus.js', async: true, callback: function() { RevealCodeFocus(); } },
          { src: 'reveal.js/plugin/search/search.js', async: true },
          { src: 'reveal.js/plugin/customcontrols/customcontrols.js', async: true }
        ],

        customcontrols: {
          controls: [
            { icon: '<i class="fa fa-question-circle"></i>',
			  css: 'position: fixed; right: 50px; bottom: 50px; z-index: 30; font-size: 24px;',
			  action: 'Reveal.toggleHelp(); return false;'
			}
          ]
        },

        menu: {
          numbers: true,
          hideMissingTitles: true,
          themes: true,
          themesPath: 'reveal.js/css/theme/'
        }
      });
    </script>
    </body>
</html>
