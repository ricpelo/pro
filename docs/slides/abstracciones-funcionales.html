<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Ricardo Pérez López">
  <title>Abstracciones funcionales</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="./reveal.js/dist/reset.css">
  <link rel="stylesheet" href="./reveal.js/dist/reveal.css">
  <style>
    .reveal .sourceCode {  /* see #7635 */
      overflow: visible;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      { color: #268bd2;  }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #cb4b16; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #d33682; } /* BaseN */
    code span.bu { color: #4070a0; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #dc322f; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #93a1a1; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #6c71c4; } /* DataType */
    code span.dv { color: #d33682; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #d33682; } /* Float */
    code span.fu { color: #4070a0; } /* Function */
    code span.im { font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #268bd2; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #a57800; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #2aa198; } /* SpecialString */
    code span.st { color: #2aa198; } /* String */
    code span.va { color: #6c71c4; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    /* CSS for citations */
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
      margin-bottom: 0em;
    }
    .hanging-indent div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }  </style>
  <link rel="stylesheet" href="./reveal.js/dist/theme/solarized.css" id="theme">
  <link rel="stylesheet" href="custom.css"/>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css" />
  <link href="https://fonts.googleapis.com/css?family=Lato&display=swap" rel="stylesheet">
  <style type="text/css">
      #header-left {
          position: absolute;
          font-size: 25%;
          top: 0%;
          left: 0%;
          margin-left: 10px;
          margin-top: 10px;
      }
      #header-right {
          position: absolute;
          font-size: 25%;
          top: 0%;
          right: 0%;
          margin-right: 10px;
          margin-top: 10px;
      }
      #footer-left {
          position: absolute;
          font-size: 25%;
          bottom: 0%;
          left: 0%;
          margin-left: 10px;
          margin-bottom: 10px;
      }
  </style>
</head>
<body>
<div id="hidden" style="display:none;">
    <div id="header">
        <div id="header-left"></div>
        <div id="header-right"></div>
        <div id="footer-left"></div>
    </div>
</div>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">Abstracciones funcionales</h1>
  <p class="author">Ricardo Pérez López</p>
  <p class="date">IES Doñana, curso 2025/2026</p>
</section>
<section id="TOC">
<nav role="doc-toc"> 
<ul>
<li><a href="#/abstracciones-lambda"
id="/toc-abstracciones-lambda"><span class="toc-section-number">1</span>
Abstracciones lambda</a></li>
<li><a href="#/ámbitos" id="/toc-ámbitos"><span
class="toc-section-number">2</span> Ámbitos</a></li>
<li><a href="#/funciones-recursivas"
id="/toc-funciones-recursivas"><span class="toc-section-number">3</span>
Funciones recursivas</a></li>
<li><a href="#/abstracciones-funcionales"
id="/toc-abstracciones-funcionales"><span
class="toc-section-number">4</span> Abstracciones funcionales</a></li>
</ul>
</nav>
</section>

<section>
<section id="abstracciones-lambda" class="title-slide slide level1"
data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span>
Abstracciones lambda</h1>

</section>
<section id="expresiones-lambda" class="title-slide slide level2"
data-number="1.1">
<h2 data-number="1.1"><span class="header-section-number">1.1</span>
Expresiones lambda</h2>
<ul>
<li><p>Las <strong>expresiones lambda</strong> (también llamadas
<strong>abstracciones lambda</strong> o <strong>funciones
anónimas</strong> en algunos lenguajes) son expresiones que capturan la
idea abstracta de «<strong>función</strong>».</p></li>
<li><p>Son la forma más simple y primitiva de describir funciones en un
lenguaje funcional.</p></li>
<li><p>Su sintaxis (simplificada) es:</p>
<div class="line-block"><span
style="color:teal">⟨<em>expresión_lambda</em>⟩</span> ::=
<strong><code>lambda</code></strong> [<span
style="color:teal">⟨<em>lista_parámetros</em>⟩</span>]<strong><code>:</code></strong>
<span style="color:teal">⟨<em>expresión</em>⟩</span><br />
<span style="color:teal">⟨<em>lista_parámetros</em>⟩</span> :=
<strong><code>identificador</code></strong>
(<strong><code>,</code></strong>
<strong><code>identificador</code></strong>)*</div></li>
<li><p>Por ejemplo, la siguiente expresión lambda captura la idea
general de «<em>suma</em>»:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span></code></pre></div></li>
</ul>
</section>

<section id="parámetros-y-cuerpos" class="title-slide slide level2"
data-number="1.2">
<h2 data-number="1.2"><span class="header-section-number">1.2</span>
Parámetros y cuerpos</h2>
<ul>
<li><p>Los identificadores que aparecen entre la palabra clave <code
class="sourceCode python"><span class="kw">lambda</span></code> y el
carácter de dos puntos (<code>:</code>) son los
<strong>parámetros</strong> de la expresión lambda.</p></li>
<li><p>La expresión que aparece tras los dos puntos (<code>:</code>) es
el <strong>cuerpo</strong> de la expresión lambda, donde pueden aparecer
los parámetros además de otros elementos.</p></li>
<li><p>En el ejemplo anterior:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span></code></pre></div>
<ul>
<li><p>Los parámetros son <code class="sourceCode python">x</code> e
<code class="sourceCode python">y</code>.</p></li>
<li><p>El cuerpo es <code
class="sourceCode python">x <span class="op">+</span> y</code>.</p></li>
<li><p>Esta expresión lambda captura la idea general de sumar dos
valores (que en principio pueden ser de cualquier tipo, siempre y cuando
admitan el operador <code>+</code>).</p></li>
<li><p>En sí misma, esa expresión devuelve un valor válido que
representa a una función.</p></li>
</ul></li>
</ul>
</section>

<section id="aplicación-funcional" class="title-slide slide level2"
data-number="1.3">
<h2 data-number="1.3"><span class="header-section-number">1.3</span>
Aplicación funcional</h2>
<ul>
<li><p>De la misma manera que podemos aplicar una función a unos
argumentos, también podemos aplicar una expresión lambda a unos
argumentos.</p></li>
<li><p>Por ejemplo, la aplicación de la función <code
class="sourceCode python"><span class="bu">max</span></code> sobre los
argumentos <code
class="sourceCode python"><span class="dv">3</span></code> y <code
class="sourceCode python"><span class="dv">5</span></code> es una
expresión que se escribe como <code
class="sourceCode python"><span class="bu">max</span>(<span class="dv">3</span>, <span class="dv">5</span>)</code>
y que denota el valor <strong>cinco</strong>.</p></li>
<li><p>Igualmente, la aplicación de una expresión lambda como</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span></code></pre></div>
<p>sobre los argumentos <code
class="sourceCode python"><span class="dv">4</span></code> y <code
class="sourceCode python"><span class="dv">3</span></code> se representa
así:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>)</span></code></pre></div>
<p>O sea, que la expresión lambda representa el papel de una
función.</p></li>
</ul>
</section>
<section id="evaluación-de-una-aplicación-funcional"
class="title-slide slide level3" data-number="1.3.1">
<h3 data-number="1.3.1"><span class="header-section-number">1.3.1</span>
Evaluación de una aplicación funcional</h3>
<ul>
<li><p>En nuestro <em>modelo de sustitución</em>, la <strong>evaluación
de la aplicación de una expresión lambda</strong> consiste en
<strong>sustituir</strong>, en el cuerpo de la expresión lambda,
<strong>cada parámetro por su argumento correspondiente</strong> (por
orden) y devolver la expresión resultante <em>parentizada</em> (o sea,
entre paréntesis).</p></li>
<li><p>A esta operación se la denomina <strong>aplicación
funcional</strong> o <strong>β-reducción</strong>.</p></li>
<li><p>Siguiendo con el ejemplo anterior:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>)</span></code></pre></div>
<p>sustituimos en el cuerpo de la expresión lambda los parámetros <code
class="sourceCode python">x</code> e <code
class="sourceCode python">y</code> por los argumentos <code
class="sourceCode python"><span class="dv">4</span></code> y <code
class="sourceCode python"><span class="dv">3</span></code>,
respectivamente, y parentizamos la expresión resultante, lo que da:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>(<span class="dv">4</span> <span class="op">+</span> <span class="dv">3</span>)</span></code></pre></div>
<p>que simplificando (según las reglas del operador <code>+</code>) da
<code
class="sourceCode python"><span class="dv">7</span></code>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.3.1.0.1">

<ul>
<li><p>Es importante hacer notar que el cuerpo de una expresión lambda
sólo se evalúa cuando se lleva a cabo una β-reducción (es decir, cuando
se aplica la expresión lambda a unos argumentos), y no antes.</p></li>
<li><p>Por tanto, el cuerpo de la expresión lambda no se evalúa cuando
se define la expresión.</p></li>
<li><p>Por ejemplo, al evaluar la expresión:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span></code></pre></div>
<p>el intérprete no evalúa la expresión del cuerpo (<code
class="sourceCode python">x <span class="op">+</span> y</code>), sino
que crea un valor de tipo «función» pero sin entrar a ver «qué hay» en
el cuerpo.</p>
<p>Sólo se mira lo que hay en el cuerpo cuando se aplica la expresión
lambda a unos argumentos.</p></li>
<li><p>En particular, podemos tener una expresión lambda como la
siguiente, que sólo dará error cuando se aplique a un argumento, no
antes:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lambda</span> x: x <span class="op">+</span> <span class="dv">1</span><span class="op">/</span><span class="dv">0</span></span></code></pre></div></li>
</ul>
</section>

<section id="funciones-con-nombre" class="title-slide slide level3"
data-number="1.3.2">
<h3 data-number="1.3.2"><span class="header-section-number">1.3.2</span>
Funciones con nombre</h3>
<ul>
<li><p>Si hacemos la siguiente definición:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>suma <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span></code></pre></div>
<p>le estamos dando un nombre a la expresión lambda, es decir, a una
función.</p></li>
<li><p>A partir de ese momento podemos usar <code
class="sourceCode python">suma</code> en lugar de su valor (la expresión
lambda), por lo que podemos hacer:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>suma(<span class="dv">4</span>, <span class="dv">3</span>)</span></code></pre></div>
<p>en lugar de</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>)</span></code></pre></div></li>
<li><p>Cuando aplicamos a sus argumentos una función así definida
también podemos decir que estamos <strong>invocando</strong> o
<strong>llamando</strong> a la función. Por ejemplo, en <code
class="sourceCode python">suma(<span class="dv">4</span>, <span class="dv">3</span>)</code>
estamos <em>llamando</em> a la función <code
class="sourceCode python">suma</code>, o hay una <em>llamada</em> a la
función <code class="sourceCode python">suma</code>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.3.2.0.1">

<ul>
<li><p>La evaluación de la llamada a <code
class="sourceCode python">suma(<span class="dv">4</span>, <span class="dv">3</span>)</code>
implicará realizar los siguientes tres pasos y en este orden:</p>
<ol type="1">
<li><p>Sustituir el nombre de la función <code
class="sourceCode python">suma</code> por su definición, es decir, por
la expresión lambda a la cual está ligado.</p></li>
<li><p>Evaluar los argumentos que aparecen en la llamada.</p></li>
<li><p>Aplicar la expresión lambda a sus argumentos
(β-reducción).</p></li>
</ol></li>
<li><p>Esto implica la siguiente secuencia de reescrituras:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>suma(<span class="dv">4</span>, <span class="dv">3</span>)                    <span class="co"># evalúa suma y devuelve su definición</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>)  <span class="co"># evalúa 4 y devuelve 4</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>)  <span class="co"># evalúa 3 y devuelve 3</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>)  <span class="co"># aplica la expresión lambda sus argumentos</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">4</span> <span class="op">+</span> <span class="dv">3</span>)                     <span class="co"># evalúa 4 + 3 y devuelve 7</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">7</span></span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="1.3.2.0.2">

<ul>
<li><p>Como una expresión lambda es una función, <strong>aplicar una
expresión lambda a unos argumentos es como llamar a una función
pasándole dichos argumentos</strong>.</p></li>
<li><p>Por tanto, también podemos decir que <strong><em>llamamos</em> o
<em>invocamos</em> una expresión lambda</strong>, pasándole unos
argumentos durante esa llamada.</p></li>
<li><p>En consecuencia, ampliamos ahora nuestra gramática de las
expresiones en Python incorporando las expresiones lambda como un tipo
de función:</p>
<div class="line-block"><span
style="color:teal">⟨<em>llamada_función</em>⟩</span> ::= <span
style="color:teal">⟨<em>función</em>⟩</span><strong><code>(</code></strong>[<span
style="color:teal">⟨<em>lista_argumentos</em>⟩</span>]<strong><code>)</code></strong><br />
<span style="color:teal">⟨<em>función</em>⟩</span> ::=
<strong><code>identificador</code></strong><br />
                  | <strong><code>(</code></strong><span
style="color:teal">⟨<em>expresión_lambda</em>⟩</span><strong><code>)</code></strong><br />
<span style="color:teal">⟨<em>expresión_lambda</em>⟩</span> ::=
<strong><code>lambda</code></strong> [<span
style="color:teal">⟨<em>lista_parámetros</em>⟩</span>]<strong><code>:</code></strong>
<span style="color:teal">⟨<em>expresión</em>⟩</span><br />
<span style="color:teal">⟨<em>lista_parámetros</em>⟩</span> ::=
<strong><code>identificador</code></strong>(<strong><code>,</code></strong>
<strong><code>identificador</code></strong>)*<br />
<span style="color:teal">⟨<em>lista_argumentos</em>⟩</span> ::= <span
style="color:teal">⟨<em>expresión</em>⟩</span>(<strong><code>,</code></strong>
<span style="color:teal">⟨<em>expresión</em>⟩</span>)*</div></li>
</ul>
</section>
<section id="ejemplo" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejemplo</h5>
<ul>
<li><p>Dado el siguiente código:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>suma <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span></code></pre></div>
<p>¿Cuánto vale la expresión siguiente?</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>suma(<span class="dv">4</span>, <span class="dv">3</span>) <span class="op">*</span> suma(<span class="dv">2</span>, <span class="dv">7</span>)</span></code></pre></div>
<p>Según el modelo de sustitución, reescribimos:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>suma(<span class="dv">4</span>, <span class="dv">3</span>) <span class="op">*</span> suma(<span class="dv">2</span>, <span class="dv">7</span>)                    <span class="co"># definición de suma</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>) <span class="op">*</span> suma(<span class="dv">2</span>, <span class="dv">7</span>)  <span class="co"># evaluación de 4</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>) <span class="op">*</span> suma(<span class="dv">2</span>, <span class="dv">7</span>)  <span class="co"># evaluación de 3</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>) <span class="op">*</span> suma(<span class="dv">2</span>, <span class="dv">7</span>)  <span class="co"># aplicación a 4 y 3</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">4</span> <span class="op">+</span> <span class="dv">3</span>) <span class="op">*</span> suma(<span class="dv">2</span>, <span class="dv">7</span>)                     <span class="co"># evaluación de 4 + 3</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> suma(<span class="dv">2</span>, <span class="dv">7</span>)                           <span class="co"># definición de suma</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">2</span>, <span class="dv">7</span>)           <span class="co"># evaluación de 2</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">2</span>, <span class="dv">7</span>)           <span class="co"># evaluación de 7</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">2</span>, <span class="dv">7</span>)           <span class="co"># aplicación a 2 y 7</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> (<span class="dv">2</span> <span class="op">+</span> <span class="dv">7</span>)                              <span class="co"># evaluación de 2 + 7</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> <span class="dv">9</span>                                    <span class="co"># evaluación de 7 * 9</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">63</span></span></code></pre></div></li>
</ul>
</section>


<section id="identificadores-locales-y-libres-de-una-expresión-lambda"
class="title-slide slide level2" data-number="1.4">
<h2 data-number="1.4"><span class="header-section-number">1.4</span>
Identificadores locales y libres de una expresión lambda</h2>
<ul>
<li><p>Si un <em>identificador</em> de los que aparecen en el
<em>cuerpo</em> de una expresión lambda también aparece en la <em>lista
de parámetros</em> de esa expresión lambda, decimos que es un
<strong>identificador local</strong> de la expresión lambda.</p></li>
<li><p>En caso contrario, le llamamos <strong>identificador
libre</strong> de la expresión lambda.</p></li>
<li><p>En el ejemplo anterior:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span></code></pre></div>
<p>los dos identificadores que aparecen en el cuerpo (<code
class="sourceCode python">x</code> e <code
class="sourceCode python">y</code>) aparecen también en la lista de
parámetros de la expresión lambda, por lo que ambos son identificadores
locales y no hay ningún identificador libre.</p></li>
<li><p>En cambio, en la expresión lambda:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lambda</span> x, y: x <span class="op">+</span> y <span class="op">+</span> z</span></code></pre></div>
<p><code class="sourceCode python">x</code> e <code
class="sourceCode python">y</code> son identificadores locales (porque
aparecen en la lista de parámetros de la expresión lambda), mientras que
<code class="sourceCode python">z</code> es un identificador
libre.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.4.0.0.1">

<ul>
<li><p>En realidad, <strong>un <em>identificador local</em> y un
<em>parámetro</em> están vinculados, hasta el punto en que podemos
considerar que son la misma cosa</strong>.</p></li>
<li><p>Tan sólo cambia su denominación dependiendo del lugar donde
aparece su identificador en la expresión lambda:</p>
<ul>
<li><p>Cuando aparece <strong>antes</strong> del «<code>:</code>», le
llamamos «<em>parámetro</em>».</p></li>
<li><p>Cuando aparece <strong>después</strong> del «<code>:</code>», le
llamamos «<em>identificador local</em>».</p></li>
</ul></li>
<li><p>Por ejemplo: en la siguiente expresión lambda:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>       ┬     ┬</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>       │     └────── identificador local</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>       └── parámetro</span></code></pre></div>
<p>el identificador <code class="sourceCode python">x</code> aparece dos
veces, pero en los dos casos representa la misma cosa. Tan sólo se llama
de distinta forma («<em>parámetro</em>» o «<em>identificador
local</em>») dependiendo de dónde aparece.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.4.0.0.2">

<ul>
<li><p>A los identificadores locales se les llama así porque son
<em>locales</em> a la expresión lambda, es decir, que
<strong>pertenencen a dicha expresión lambda y no existen fuera de
ella</strong>.</p>
<p>Tiene mucho que ver con el concepto de <em>ámbito</em> que veremos a
continuación.</p></li>
</ul>
</section>
</section>
<section>
<section id="ámbitos" class="title-slide slide level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span>
Ámbitos</h1>

</section>
<section id="ámbitos-léxicos" class="title-slide slide level2"
data-number="2.1">
<h2 data-number="2.1"><span class="header-section-number">2.1</span>
Ámbitos léxicos</h2>
<ul>
<li><p>Un <strong>ámbito léxico</strong> (también llamado <strong>ámbito
estático</strong>) es una porción del código fuente de un
programa.</p></li>
<li><p>Decimos que <strong>ciertas construcciones sintácticas determinan
ámbitos léxicos</strong>.</p></li>
<li><p>Cuando una construcción determina un ámbito léxico, <strong>la
sintaxis del lenguaje establece dónde empieza y acaba</strong> ese
ámbito léxico en el código fuente.</p></li>
<li><p>Por tanto, siempre se puede determinar sin ambigüedad si
<strong>una instrucción está dentro de un determinado ámbito
léxico</strong>, tan sólo leyendo el código fuente del programa y sin
necesidad de ejecutarlo.</p></li>
<li><p>Eso significa que el concepto de <em>ámbito léxico</em> es un
concepto <strong>estático</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.1.0.0.1">

<ul>
<li><p>Por ejemplo: en el lenguaje de programación Java, los
<em>bloques</em> son estructuras sintácticas delimitadas por llaves
<code>{</code> y <code>}</code> que contienen instrucciones.</p></li>
<li><p>Los bloques de Java definen ámbitos léxicos; por tanto, si una
instrucción está dentro de un bloque (es decir, si está situada entre
las llaves <code>{</code> y <code>}</code> que delimitan el bloque),
entonces esa instrucción se encuentra dentro del ámbito léxico que
define el bloque.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.1.0.0.2">

<ul>
<li><p>Además de los ámbitos léxicos, existen también los llamados
<strong>ámbitos dinámicos</strong>, que funcionan de otra forma y que no
estudiaremos en este curso.</p></li>
<li><p>La mayoría de los lenguajes de programación usan ámbitos léxicos,
salvo excepciones (como LISP o los <em>shell scripts</em>) que usan
ámbitos dinámicos.</p></li>
<li><p>Por esa razón, a partir de ahora, cuando hablemos de «ámbitos»
sin especificar de qué tipo, nos estaremos siempre refiriendo a «ámbitos
léxicos».</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.1.0.0.3">

<ul>
<li><p>Los ámbitos <strong>se pueden anidar recursivamente</strong>, o
sea, que pueden estar contenidos unos dentro de otros.</p></li>
<li><p>Por tanto, una instrucción puede estar en varios ámbitos al mismo
tiempo (anidados unos dentro de otros).</p></li>
<li><p>De todos ellos, el <strong>ámbito más interno</strong> es el que
no contiene, a su vez, a ningún otro ámbito.</p></li>
<li><p>En un momento dado, el <strong>ámbito actual</strong> es el
ámbito más interno en el que se encuentra la instrucción que se está
ejecutando actualmente (es decir, la <strong>instrucción
actual</strong>).</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.1.0.0.4">

<ul>
<li><p>El concepto de <em>ámbito</em> no es nada trivial y, a medida que
vayamos incorporando nuevos elementos al lenguaje, tendremos que ir
adaptándolo para tener en cuenta más condicionantes.</p></li>
<li><p>Hasta ahora sólo hemos tenido un ámbito, llamado <strong>ámbito
global</strong>:</p>
<ul>
<li><p>Si se está ejecutando un <em>script</em> en el intérprete por
lotes (con <code>python script.py</code>), el <em>ámbito global</em>
abarca todo el <em>script</em>, desde la primera instrucción hasta la
última.</p></li>
<li><p>Si estamos en el intérprete interactivo (con <code>python</code>
o <code>ipython3</code>), el <em>ámbito global</em> abarca toda nuestra
sesión con el intérprete, desde que arrancamos la sesión hasta que
finalizamos la misma.</p></li>
</ul></li>
<li><p>Por tanto:</p>
<ul>
<li><p>En el momento en que se empieza a ejecutar un <em>script</em> o
se arranca una sesión con el intérprete interactivo, se entra en el
<em>ámbito global</em>.</p></li>
<li><p>Del ámbito global sólo se sale cuando se finaliza la ejecución
del <em>script</em> o se cierra el intérprete interactivo.</p></li>
</ul></li>
</ul>
<!--

---

- Se denominan **definiciones globales** a las definiciones que se ejecutan
  cuando el ámbito actual es el ámbito global.

- Las ligaduras que crean las definiciones globales se denominan **ligaduras
  globales** o **ligaduras de ámbito global**.

- Por ejemplo, en el siguiente _script_ se ejecutan cuatro instrucciones. El
  ámbito actual de cada una de las instrucciones es el ámbito global, que es el
  único ámbito que existe en el _script_:

  ::: centered
  ![](images/ambito-global.png){width=40% .plain width=80%}
:::



-->
</section>

<section id="ámbito-de-una-definición-y-de-una-ligadura"
class="title-slide slide level2" data-number="2.2">
<h2 data-number="2.2"><span class="header-section-number">2.2</span>
Ámbito de una definición y de una ligadura</h2>
<ul>
<li><p>El <strong>ámbito de una definición</strong> es el ámbito actual
de esa definición (es decir, el ámbito más interno donde aparece esa
definición).</p></li>
<li><p>Por extensión, llamamos <strong>ámbito de una ligadura</strong>
al ámbito de la definición que, al ejecutarse, creará la ligadura (es
decir, el ámbito más interno donde aparece la definición que, al
ejecutarse, creará la ligadura en tiempo de ejecución).</p></li>
<li><p>En la práctica, es lo mismo hablar del «ámbito de una definición»
que del «ámbito de la ligadura que se creará al ejecutar la definición»,
ya que son la misma cosa.</p></li>
<li><p>Decimos que la <em>definición</em> (y la <em>ligadura</em>
correspondiente que se creará al ejecutar esa definición) es
<strong>local</strong> a su ámbito.</p></li>
<li><p>Si ese ámbito es el ámbito <em>global</em>, decimos que la
<em>definición</em> (y la <em>ligadura</em> que se creará al ejecutar
esa definición) es <strong>global</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.2.0.0.1">

<ul>
<li><p>Por ejemplo, en el siguiente <em>script</em> se ejecutan cuatro
definiciones.</p></li>
<li><p>El ámbito actual de cada una de las instrucciones es el ámbito
<em>global</em>, que es el único ámbito que existe en el
<em>script</em>:</p>
<div class="centered">
<p><img data-src="images/ambito-global.png" class="plain"
style="width:40.0%" /></p>
</div></li>
<li><p>En consecuencia:</p>
<ul>
<li><p>Las cuatro definiciones tienen <strong>ámbito global</strong> (y
son, por tanto, <strong>definiciones globales</strong>).</p></li>
<li><p>Cuando se ejecuten, esas definiciones crearán <strong>ligaduras
globales</strong>.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="2.2.0.0.2">

<ul>
<li><p>Como estamos usando un lenguaje de programación que trabaja con
<em>ámbitos léxicos</em>, <strong>el ámbito de una definición siempre
vendrá determinado por una <em>construcción sintáctica</em></strong> del
lenguaje.</p></li>
<li><p>Por tanto:</p>
<ul>
<li><p>Sus <em>límites</em> vienen marcados únicamente por la
<em>sintaxis</em> de la construcción que determina el ámbito de esa
definición.</p></li>
<li><p>El ámbito de la definición se puede determinar simplemente
leyendo el código fuente del programa, observando dónde empieza y dónde
acaba esa construcción, sin tener que ejecutarlo.</p>
<p>Es decir, que se puede determinar de forma
<em>estática</em>.</p></li>
</ul></li>
</ul>
</section>
<section id="almacenamiento" class="title-slide slide level3"
data-number="2.2.1">
<h3 data-number="2.2.1"><span class="header-section-number">2.2.1</span>
Almacenamiento</h3>
<ul>
<li><p>Sabemos que las ligaduras se almacenan en <em>espacios de
nombres</em>.</p></li>
<li><p>En Python, hay dos lugares donde se pueden almacenar ligaduras y,
por tanto, hay dos posibles espacios de nombres: los objetos y los
marcos.</p></li>
<li><p>Así que tenemos dos posibilidades:</p>
<ol>
<li><p>Si el identificador que se está ligando es un <em>atributo</em>
de un objeto, entonces la ligadura se almacenará en el objeto.</p></li>
<li><p>En caso contrario, la ligadura se almacenará en un marco que
depende del <em>ámbito actual</em>.</p></li>
</ol></li>
<li><p>Veamos cada caso con más detalle.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.2.1.0.1">

<ol type="1">
<li><p>Cuando se crea una ligadura dentro de un objeto en Python usando
el operador punto (<code>.</code>), el espacio de nombres será el propio
objeto, ya que los objetos son espacios de nombres en Python. En tal
caso, la ligadura asocia un <em>atributo</em> del objeto con un
valor.</p>
<p>Por ejemplo, si en Python hacemos:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>math.x <span class="op">=</span> <span class="dv">75</span></span></code></pre></div>
<p>estamos creando la ligadura <code>x</code> → <code>75</code> en el
espacio de nombres que representa el módulo <code>math</code>, el cual
es un objeto en Python y, por tanto, es quien almacena la ligadura.</p>
<p>Así que el espacio de nombres ha sido seleccionado a través del
operador punto (<code>.</code>) para resolver el atributo dentro del
objeto, y no depende del ámbito donde se encuentre la sentencia <code
class="sourceCode python">math.x <span class="op">=</span> <span class="dv">75</span></code>.</p></li>
</ol>
</section>
<section class="slide level5" data-number="2.2.1.0.2">

<ol start="2" type="1">
<li><p>Si la ligadura no se crea dentro de un objeto usando el operador
punto (<code>.</code>), entonces el espacio de nombres dependerá del
ámbito:</p>
<ol type="a">
<li><p>Si el ámbito donde se crea la ligadura lleva asociado un espacio
de nombres, ese espacio de nombres almacenará las ligaduras que se crean
dentro de ese ámbito.</p></li>
<li><p>Si no, entonces la ligadura se almacenará en el espacio de
nombres del ámbito más interno que contenga al actual y que sí lleve
asociado un espacio de nombres.</p></li>
</ol>
<p>Por tanto, a la hora de almacenar una ligadura, se van mirando todos
los ámbitos desde el ámbito actual, pasando por todos los ámbitos que
incluyen a éste (en orden, del más interno al más externo), hasta
encontrar el primer ámbito que lleve asociado un espacio de nombres.</p>
<p>En cualquier caso, aquí el espacio de nombres seleccionado siempre
será un marco.</p>
<p>Cuando la ligadura se almacena en el marco global, se dice que tiene
<strong>almacenamiento global</strong>.</p></li>
</ol>
</section>

<section id="visibilidad" class="title-slide slide level3"
data-number="2.2.2">
<h3 data-number="2.2.2"><span class="header-section-number">2.2.2</span>
Visibilidad</h3>
<ul>
<li>La visibilidad de una ligadura indica cuándo y de qué manera es
visible esa ligadura.</li>
</ul>
<ol type="1">
<li><p>Si el identificador ligado es un <strong>atributo de un
objeto</strong>, la ligadura sólo será visible dentro del objeto.</p>
<p>En tal caso, decimos que la visibilidad de la ligadura (y del
correspondiente atributo ligado) es <strong>local al objeto</strong> que
contiene el atributo.</p>
<p>Eso significa que debemos indicar (usando el operador punto
(<code>.</code>)) el objeto que contiene a la ligadura para poder
acceder a ella, lo que significa que también debemos tener acceso al
propio objeto que la contiene.</p></li>
</ol>
</section>
<section class="slide level5" data-number="2.2.2.0.1">

<ol start="2" type="1">
<li><p>Si el identificador ligado <strong>NO es un atributo de un
objeto</strong>, la ligadura sólo será visible en el ámbito donde se
definió la ligadura, el cual va asociado al marco donde se almacena la
ligadura.</p>
<p>Ese ámbito representa una «región» cuyas fronteras limitan la porción
del código fuente en la que es visible esa ligadura.</p>
<p>En tal caso, decimos que la <strong>visibilidad</strong> de la
ligadura es <strong>local a su ámbito</strong>.</p>
<p>Eso significa que <strong>no es posible acceder a esa ligadura fuera
de su ámbito</strong>; sólo es visible dentro de él.</p>
<p>Si el ámbito es el global, decimos que la ligadura tiene
<strong>visibilidad global</strong>.</p></li>
</ol>
</section>

<section id="tiempo-de-vida" class="title-slide slide level3"
data-number="2.2.3">
<h3 data-number="2.2.3"><span class="header-section-number">2.2.3</span>
Tiempo de vida</h3>
<ul>
<li><p>El <strong>tiempo de vida</strong> de una ligadura representa el
periodo de tiempo durante el cual <em>existe</em> esa ligadura, es
decir, el periodo comprendido desde su creación y almacenamiento en la
memoria hasta su posterior destrucción.</p></li>
<li><p>En la mayoría de los lenguajes (incluyendo Python y Java), una
ligadura <strong>empieza a existir</strong> justo donde se crea, es
decir, en el punto donde se ejecuta la instrucción que define la
ligadura.</p>
<p>Por tanto, no es posible <em>acceder</em> a esa ligadura
<em>antes</em> de ese punto, ya que no existe hasta entonces.</p></li>
<li><p>Por otra parte, el momento en que una ligadura <strong>deja de
existir</strong> depende su almacenamiento:</p>
<ul>
<li><p>Si se almacena en un objeto, es porque la ligadura está ligando
un atributo de ese objeto a un determinado valor. En tal caso, la
ligadura dejará de existir cuando se elimine el objeto de la memoria, o
bien, cuando se elimine el atributo ligado.</p></li>
<li><p>En caso contrario, la ligadura dejará de existir allí donde
termine su ámbito.</p></li>
</ul></li>
</ul>
<!--

- Eso significa que la **visibilidad** de una ligadura y el **acceso** a una
  ligadura son conceptos distintos:

  - La **visibilidad** de una ligadura la define su ámbito, y es, por tanto, un
    concepto **_estático_**.

  - La posibilidad de **acceder** a una ligadura depende de si esa ligadura ya
    se ha creado previamente al intentar acceder a ella durante la ejecución
    del programa, y es un concepto **_estático_** si el lenguaje es compilado,
    o **_dinámico_** si es interpretado.

-->
</section>
<section class="slide level5" data-number="2.2.3.0.1">

<ul>
<li><p>En el siguiente ejemplo vemos cómo hay varias definiciones que,
al ejecutarse, crearán ligaduras en un determinado ámbito, pero no en un
objeto (ya que no se están creando atributos dentro de ningún
objeto):</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode numberSource python number-lines"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1"></a>x <span class="op">=</span> <span class="dv">25</span></span>
<span id="cb20-2"><a href="#cb20-2"></a>y <span class="op">=</span> <span class="dv">99</span></span>
<span id="cb20-3"><a href="#cb20-3"></a>z <span class="op">=</span> y</span>
<span id="cb20-4"><a href="#cb20-4"></a>nombre <span class="op">=</span> <span class="st">&#39;Manolo&#39;</span></span></code></pre></div></li>
<li><p>Todas esas definiciones son globales y, por tanto, las ligaduras
que crean al ejecutarse son ligaduras globales o de ámbito global, y se
almacenan en el marco global.</p></li>
<li><p>Al no tratarse de atributos de objetos, la visibilidad y el
tiempo de vida de las ligaduras vendrán determinadas por sus
ámbitos.</p></li>
<li><p>En consecuencia, la visibilidad de todas esas ligaduras será el
ámbito global, ya que son ligaduras globales. Por tanto, decimos que su
<strong>visibilidad</strong> es <strong>global</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.2.3.0.2">

<ul>
<li><p>Por otra parte, como esas ligaduras no se crean sobre atributos
de objetos, empezarán a existir justo donde se crean, y terminarán de
existir al final de su ámbito.</p></li>
<li><p>Por ejemplo, la ligadura <code>y</code> → <code>99</code>
empezará a existir en la línea 2 y terminará al final del
<em>script</em>, que es donde termina su ámbito (que, en este ejemplo,
es el ámbito global).</p></li>
<li><p>En consecuencia, el <strong>tiempo de vida</strong> de la
ligadura será el periodo comprendido desde su creación (en la línea 2)
hasta el final de su ámbito.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.2.3.0.3">

<ul>
<li><p>Cuando la ligadura se crea sobre un <strong>atributo</strong> de
un <em>objeto</em> de Python, entonces ese objeto almacenará la ligadura
y será, por tanto, su espacio de nombres.</p></li>
<li><p>Recordemos que, por ejemplo, cuando importamos un módulo usando
la sentencia <code
class="sourceCode python"><span class="im">import</span></code>, podemos
acceder al objeto que representa ese módulo usando su nombre, lo que nos
permite acceder a sus atributos y crear otros nuevos.</p></li>
<li><p>Esos atributos y sus ligaduras correspondientes sólo son visibles
cuando accedemos a ellos usando el operador punto (<code>.</code>) a
través del objeto que lo contiene.</p></li>
<li><p>Por tanto, los atributos no son visibles fuera del objeto, y
debemos usar el operador punto (<code>.</code>) para acceder a
ellos:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> math</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> math.pi</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="fl">3.141592653589793</span>     <span class="co"># El nombre &#39;pi&#39; es visible dentro del objeto</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> pi                <span class="co"># El nombre &#39;pi&#39; no es visible fuera del objeto</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>Traceback (most recent call last):</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="pp">NameError</span>: name <span class="st">&#39;pi&#39;</span> <span class="kw">is</span> <span class="kw">not</span> defined</span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="2.2.3.0.4">

<ul>
<li><p>Igualmente, si creamos un nuevo atributo dentro del objeto, la
ligadura entre el atributo y su valor sólo existirá en el propio objeto
y, por tanto, sólo será visible cuando accedamos al atributo a través
del objeto donde se ha creado.</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> math</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> math.x <span class="op">=</span> <span class="dv">95</span>       <span class="co"># Creamos un nuevo atributo en el objeto</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> math.x            <span class="co"># El nombre &#39;x&#39; es visible dentro del objeto</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="dv">95</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> x                 <span class="co"># El nombre &#39;x&#39; no es visible fuera del objeto</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>Traceback (most recent call last):</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="pp">NameError</span>: name <span class="st">&#39;x&#39;</span> <span class="kw">is</span> <span class="kw">not</span> defined</span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="2.2.3.0.5">

<ul>
<li><p>En resumen:</p>
<ul>
<li><p>Para poder acceder a un atributo de un objeto debemos indicar
éste y usar el operador punto (<code>.</code>).</p></li>
<li><p>Por tanto, la <strong>visibilidad</strong> de su ligadura
correspondiente no vendrá determinada por un ámbito, sino por el objeto
que contiene al atributo (y que, por consiguiente, también contiene a su
ligadura).</p></li>
</ul></li>
</ul>
</section>
<section id="resumen" class="title-slide slide level4"
data-number="2.2.3.1">
<h4 data-number="2.2.3.1"><span
class="header-section-number">2.2.3.1</span> Resumen</h4>
<div class="caja">
<p><strong>Ámbito (léxico):</strong></p>
<p>Porción del código fuente de un programa. Los límites de ese ámbito
sólo vienen determinados por la sintaxis del lenguaje, ya que ciertas
construcciones sintácticas determinan su propio ámbito.</p>
</div>
<div class="caja">
<p><strong>Ámbito de una definición:</strong></p>
<p>El ámbito actual de la definición; es decir: el ámbito más interno
donde aparece la definición.</p>
</div>
<div class="caja">
<p><strong>Ámbito de una ligadura:</strong></p>
<p>El ámbito de la instrucción que creará la ligadura en tiempo de
ejecución. Por ejemplo, si la instrucción es una definición, se
corresponde con el ámbito de la definición.</p>
</div>
</section>
<section class="slide level5" data-number="2.2.3.1.1">

<div class="caja">
<p><strong>Visibilidad de una ligadura:</strong></p>
<p>Determina dónde es visible una ligadura dentro del programa.</p>
<p>Esa visibilidad depende de si el identificador ligado es un atributo
de un objeto o no:</p>
<ol type="a">
<li><p>Si es un atributo de un objeto, la visibilidad será el objeto que
contiene la ligadura.</p></li>
<li><p>En caso contrario, la visibilidad será el ámbito de la
ligadura.</p></li>
</ol>
</div>
</section>
<section class="slide level5" data-number="2.2.3.1.2">

<div class="caja">
<p><strong>Tiempo de vida de una ligadura:</strong></p>
<p>El periodo de tiempo durante el cual <em>existe</em> esa ligadura, es
decir, el periodo comprendido desde su creación y almacenamiento en la
memoria hasta su posterior destrucción.</p>
<p>Su tiempo de vida empieza siempre en el momento en que se crea la
ligadura, y su final depende de si el identificador ligado es un
atributo de un objeto o no:</p>
<ol type="a">
<li><p>Si es un atributo de un objeto, el tiempo de vida acabará cuando
se destruya el objeto que lo contiene (o cuando se elimine el atributo
ligado).</p></li>
<li><p>En caso contrario, el tiempo de vida acabará al final del ámbito
de la ligadura.</p></li>
</ol>
</div>
<div class="caja">
<p><strong>Almacenamiento de una ligadura:</strong></p>
<ul>
<li><p>Determina el <strong>espacio de nombres</strong> donde se
almacenará la ligadura.</p></li>
<li><p>En Python:</p></li>
</ul>
<ol type="a">
<li><p>Si el identificador ligado es un atributo de un objeto, el
espacio de nombres será el objeto que lo contiene.</p></li>
<li><p>En caso contrario, el espacio de nombres será el marco asociado
al ámbito de la ligadura.</p></li>
</ol>
</div>
</section>



<section id="ámbito-de-un-identificador"
class="title-slide slide level2" data-number="2.3">
<h2 data-number="2.3"><span class="header-section-number">2.3</span>
Ámbito de un identificador</h2>
<ul>
<li><p>A veces, por economía del lenguaje, se suele hablar del
«<strong><em>ámbito de un identificador</em></strong>», en lugar de
hablar del «<em>ámbito de la ligadura que liga ese identificador con un
valor</em>».</p></li>
<li><p>Por ejemplo, en el siguiente <em>script</em>:</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="dv">25</span></span></code></pre></div>
<p>tenemos que:</p>
<ul>
<li><p>En el ámbito global, hay una definición que liga al identificador
<code class="sourceCode python">x</code> con el valor <code
class="sourceCode python"><span class="dv">25</span></code>.</p></li>
<li><p>Por tanto, se dice que <strong>el <em>ámbito de esa ligadura</em>
es el ámbito global</strong>.</p></li>
<li><p>Pero también se suele decir que «<em>el identificador <code
class="sourceCode python">x</code> es global</em>» o, simplemente, que
«<em><code class="sourceCode python">x</code> es global</em>».</p></li>
</ul></li>
<li><p>O sea, se <strong>asocia al ámbito</strong> no la ligadura, sino
<strong>el identificador en sí</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.3.0.0.1">

<ul>
<li><p>Pero hay que tener cuidado, ya que ese mismo identificador puede
aparecer en ámbitos diferentes y, por tanto, ligarse en ámbitos
diferentes.</p></li>
<li><p>Así que no tendría sentido hablar del ámbito que tiene ese
identificador (ya que podría tener varios) sino, más bien, <strong>del
ámbito que tiene <em>una aparición concreta</em> de ese
identificador</strong>.</p></li>
<li><p>Por eso, sólo deberíamos hablar del ámbito de un identificador
cuando no haya ninguna ambigüedad respecto a qué aparición concreta nos
estamos refiriendo.</p></li>
<li><p>Por ejemplo, en el siguiente <em>script</em>:</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode numberSource python number-lines"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1"></a>x <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb24-2"><a href="#cb24-2"></a>suma <span class="op">=</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">2</span>, <span class="dv">3</span>)</span></code></pre></div>
<p>el identificador <code class="sourceCode python">x</code> que aparece
en la línea 1 y el identificador <code
class="sourceCode python">x</code> que aparece en la línea 2 pertenecen
a ámbitos distintos (como veremos en breve) aunque sea el mismo
identificador.</p></li>
</ul>
</section>

<section id="ámbito-de-un-parámetro" class="title-slide slide level2"
data-number="2.4">
<h2 data-number="2.4"><span class="header-section-number">2.4</span>
Ámbito de un parámetro</h2>
<ul>
<li><p><strong>El cuerpo de la expresión lambda determina un
ámbito.</strong></p></li>
<li><p>Por ejemplo, supongamos la siguiente llamada a una expresión
lambda:</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">2</span>, <span class="dv">3</span>)</span></code></pre></div></li>
<li><p><strong>Al llamar a la expresión lambda</strong> (es decir, al
aplicar la expresión lambda a unos argumentos), se empieza a ejecutar su
cuerpo y, por tanto, <strong>se entra en dicho ámbito</strong>.</p></li>
<li><p>En ese momento, <strong>se crea un nuevo marco</strong> en la
memoria, que representa esa ejecución concreta de dicha expresión
lambda.</p></li>
<li><p>Lo que ocurre justo a continuación es que <strong>cada parámetro
de la expresión lambda se liga a uno de los argumentos</strong> en el
orden en que aparecen en la llamada a la expresión lambda (primer
parámetro con primer argumento, segundo con segundo, etcétera).</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.4.0.0.1">

<ul>
<li><p>En el ejemplo anterior, es como si el intérprete ejecutara las
siguientes definiciones dentro del ámbito de la expresión lambda:</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> <span class="dv">3</span></span></code></pre></div></li>
<li><p>Las ligaduras que crean esas definiciones <strong>se almacenan en
el marco de la expresión lambda</strong>.</p></li>
<li><p>Ese marco se eliminará de la memoria al salir del ámbito de la
expresión lambda, es decir, cuando se termine de ejecutar el cuerpo de
la expresión lambda.</p>
<p>Por tanto, las ligaduras se destruyen de la memoria al eliminarse el
marco que las almacena.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.4.0.0.2">

<ul>
<li><p>La próxima vez que se llame a la expresión lambda, se volverán a
ligar sus parámetros con los argumentos que haya en esa
llamada.</p></li>
<li><p>Por ejemplo, supongamos que tenemos esta situación:</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>suma <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> suma(<span class="dv">4</span>, <span class="dv">3</span>)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> suma(<span class="dv">8</span>, <span class="dv">9</span>)</span></code></pre></div></li>
<li><p>En la primera llamada, se entrará en el ámbito determinado por el
cuerpo la expresión lambda, se creará el marco que representa a esa
llamada, y se ejecutarán las siguientes definiciones dentro del
ámbito:</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> <span class="dv">3</span></span></code></pre></div>
<p>lo que creará las correspondientes ligaduras y las almacenará en el
marco de esa llamada.</p>
<p>Despues, evaluará el cuerpo de la expresión lambda y devolverá el
resultado, saliendo del cuerpo de la expresión lambda y, por tanto, del
ámbito que determina dicho cuerpo, lo que hará que se destruya el marco
y, en consecuencia, las ligaduras que contiene.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.4.0.0.3">

<ul>
<li><p>En la siguiente llamada ocurrirá lo mismo pero, esta vez, las
definiciones que se ejecutarán serán las siguientes:</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="dv">8</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> <span class="dv">9</span></span></code></pre></div>
<p>lo que creará otras ligaduras, que serán destruidas luego cuando se
destruya el marco que las contiene, al finalizar la ejecución del cuerpo
de la expresión lambda.</p></li>
<li><p>Es importante hacer notar que <strong>en ningún momento se está
haciendo un <em>rebinding</em> de los parámetros</strong>, ya que cada
vez que se llama de nuevo a la expresión lambda, se está creando una
ligadura nueva sobre un identificador que no estaba ligado.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.4.0.0.4">

<ul>
<li><p>En consecuencia, podemos decir que:</p>
<ul>
<li><p>El <strong>ámbito de la ligadura</strong> entre un parámetro y su
argumento es el <strong>cuerpo</strong> de la expresión lambda, así que
la <strong>visibilidad</strong> del parámetro (y de la ligadura) es ese
cuerpo.</p></li>
<li><p>Esa ligadura se crea justo después de entrar en ese ámbito, así
que se puede <strong>acceder</strong> a ella en cualquier parte del
cuerpo de la expresión lambda.</p></li>
<li><p>El <strong>espacio de nombres</strong> que almacena las ligaduras
entre parámetros y argumentos es el <strong>marco</strong> que se crea
al llamar a la expresión lambda.</p></li>
</ul></li>
<li><p>Esto se resume diciendo que «el <strong>ámbito de un
parámetro</strong> es el <strong>cuerpo</strong> de su expresión
lambda».</p></li>
<li><p>También se dice que el parámetro tiene un <strong>ámbito
<em>local</em></strong> y un <strong>almacenamiento
<em>local</em></strong> al cuerpo de la expresión lambda.</p>
<p>Resumiendo: el parámetro es <strong>local</strong> a dicha expresión
lambda.</p></li>
<li><p>Por tanto, <strong>sólo podemos acceder al valor de un parámetro
dentro del cuerpo de su expresión lambda</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.4.0.0.5">

<!-- Esta diapositiva está repetida en una sección posterior -->
<ul>
<li><p>Por ejemplo, en el siguiente código:</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>suma <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span></code></pre></div>
<p>el cuerpo de la expresión lambda ligada a <code
class="sourceCode python">suma</code> determina su propio
ámbito.</p></li>
<li><p>Por tanto, en el siguiente código tenemos dos ámbitos: el ámbito
global (más externo) y el ámbito del cuerpo de la expresión lambda (más
interno y anidado dentro del ámbito global):</p>
<div class="centered">
<p><img data-src="images/ambitos-anidados.png" class="plain"
style="width:60.0%" /></p>
</div></li>
<li><p>Además, cada vez que se llama a <code
class="sourceCode python">suma</code>, la ejecución del programa entra
en su cuerpo, lo que crea un nuevo marco que almacena las ligaduras
entre sus parámetros y los argumentos usados en esa llamada.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.4.0.0.6">

<div class="caja">
<p><strong>En resumen:</strong></p>
<ul>
<li><p>El <strong>ámbito de un parámetro</strong> es el ámbito de la
ligadura que se establece entre éste y su argumento correspondiente, y
se corresponde con el <strong>cuerpo</strong> de la expresión lambda
donde aparece.</p></li>
<li><p>Por tanto, el parámetro sólo existe dentro del cuerpo de la
expresión lambda y no podemos <strong>acceder</strong> a su valor fuera
del mismo; por eso se dice que tiene un <strong>ámbito
<em>local</em></strong> a la expresión lambda.</p></li>
<li><p>Además, <strong>la ligadura</strong> entre el parámetro y su
argumento <strong>se almacena en el marco</strong> de la llamada a la
expresión lambda, y por eso se dice que tiene un <strong>almacenamiento
<em>local</em></strong> a la expresión lambda.</p></li>
</ul>
</div>
</section>
<section class="slide level5" data-number="2.4.0.0.7">

<ul>
<li><p>Los ámbitos léxicos permiten ligaduras locales a ciertas
construcciones sintácticas, lo cual nos permite programar definiendo
partes suficientemente independientes entre sí (que es la base de la
<em>programación modular</em>).</p></li>
<li><p>Por ejemplo, nos permite crear funciones sin preocuparnos de si
los nombres de los parámetros ya han sido utilizados en otras partes del
programa.</p></li>
</ul>
</section>

<section id="ámbito-de-un-identificador-local"
class="title-slide slide level2" data-number="2.5">
<h2 data-number="2.5"><span class="header-section-number">2.5</span>
Ámbito de un identificador local</h2>
<ul>
<li><p>Hemos visto que a los <strong>parámetros</strong> de una
expresión lambda se les llama <strong>identificadores locales</strong>
cuando aparecen dentro del cuerpo de dicha expresión lambda.</p></li>
<li><p>Por tanto, todo lo que se dijo sobre el ámbito de un parámetro se
aplica exactamente igual al ámbito de un identificador local.</p></li>
<li><p>Recordemos que el ámbito de un parámetro es el cuerpo de su
expresión lambda, que es la porción de código donde podemos acceder al
valor del argumento con el que está ligado.</p></li>
<li><p>Por tanto, <strong>el <em>ámbito</em> de un identificador local
es el <em>cuerpo</em> de la expresión lambda</strong> donde aparece, y
es el único lugar dentro del cual podremos acceder al valor del
identificador local (que también será el valor del argumento con el que
está ligada).</p></li>
<li><p>Por eso también se dice que el identificador local tiene un
<strong>ámbito local</strong> al cuerpo de la expresión lambda.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.5.0.0.1">

<div class="caja">
<p><strong>En resumen:</strong></p>
<ul>
<li><p>El <strong>ámbito de un identificador local</strong> es el ámbito
de la ligadura que se crea entre ésto y su argumento correspondiente, y
se corresponde con el <strong>cuerpo</strong> de la expresión lambda
donde aparece.</p></li>
<li><p>Por tanto, el identificador local sólo existe dentro del cuerpo
de la expresión lambda y no podemos <strong>acceder</strong> a su valor
fuera del mismo; por eso se dice que tiene un <strong>ámbito
<em>local</em></strong> a la expresión lambda.</p></li>
<li><p>Además, <strong>la ligadura</strong> entre el identificador local
y su argumento <strong>se almacena en el marco</strong> de la llamada a
la expresión lambda, y por eso se dice que tiene un
<strong>almacenamiento <em>local</em></strong> a la expresión
lambda.</p></li>
</ul>
</div>
<ul>
<li>O sea: con los <strong>identificadores locales</strong> ocurre
exactamente lo mismo que con los <strong>parámetros</strong>, ya que, de
hecho, <strong>un parámetro y un identificador local son la misma
cosa</strong>, como ya hemos visto.</li>
</ul>
</section>
<section id="ejemplo-1" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejemplo</h5>
<ul>
<li><p>En el siguiente <em>script</em>:</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode numberSource python number-lines"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1"></a><span class="co"># Aquí empieza el script (no hay más definiciones antes de esta línea):</span></span>
<span id="cb31-2"><a href="#cb31-2"></a>producto <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> x</span>
<span id="cb31-3"><a href="#cb31-3"></a>y <span class="op">=</span> producto(<span class="dv">3</span>)</span>
<span id="cb31-4"><a href="#cb31-4"></a>z <span class="op">=</span> x <span class="op">+</span> <span class="dv">1</span>       <span class="co"># da error</span></span></code></pre></div></li>
<li><p>Hay dos ámbitos: el ámbito global y el ámbito local definido por
el cuerpo de la expresión lambda (la expresión <code
class="sourceCode python">x <span class="op">*</span> x</code>).</p></li>
<li><p>La expresión lambda de la línea 2 tiene un parámetro (<code
class="sourceCode python">x</code>) que aparece como el identificador
local <code class="sourceCode python">x</code> en el cuerpo de la
expresión lambda.</p></li>
<li><p>El ámbito del identificador local <code
class="sourceCode python">x</code> es el <strong>cuerpo</strong> de la
expresión lambda.</p></li>
<li><p>Por tanto, fuera del cuerpo de la expresión lambda, no es posible
acceder al valor del identificador local <code
class="sourceCode python">x</code>, al encontrarnos <strong>fuera de su
ámbito</strong> (la ligadura <strong>sólo es visible dentro del
cuerpo</strong> de la expresión lambda).</p></li>
<li><p>Por eso, la línea 4 dará un error al intentar acceder al valor
del identificador <code class="sourceCode python">x</code>, cuya
ligadura no es visible fuera de la expresión lambda.</p></li>
</ul>
</section>

<section id="ámbito-de-un-identificador-libre"
class="title-slide slide level2" data-number="2.6">
<h2 data-number="2.6"><span class="header-section-number">2.6</span>
Ámbito de un identificador libre</h2>
<ul>
<li><p>Los identificadores y ligaduras que no tienen ámbito local se
dice que tienen un <strong>ámbito <em>no local</em></strong> o, a veces,
un <strong>ámbito <em>más global</em></strong>.</p>
<p>Si, además, ese ámbito resulta ser el <strong>ámbito global</strong>,
decimos directamente que esos identificadores o ligaduras son
<strong>globales</strong>.</p></li>
<li><p>Por ejemplo, los <strong>identificadores libres</strong> que
aparecen en una expresión lambda no son locales a dicha expresión (ya
que no representan parámetros de la expresión) y, por tanto, tienen un
ámbito más global que el cuerpo de dicha expresión lambda y se
almacenarán en otro espacio de nombres distinto al marco que se crea al
llamar a la expresión lambda.</p></li>
</ul>
</section>
</section>
<section>
<section id="funciones-recursivas" class="title-slide slide level1"
data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span>
Funciones recursivas</h1>

</section>
<section id="definición" class="title-slide slide level2"
data-number="3.1">
<h2 data-number="3.1"><span class="header-section-number">3.1</span>
Definición</h2>
<ul>
<li><p>Una <strong>función recursiva</strong> es aquella que se define
en términos de sí misma.</p></li>
<li><p>Eso quiere decir que, durante la ejecución de una llamada a la
función, se ejecuta otra llamada a la misma función, es decir, que la
función se llama a sí misma directa o indirectamente.</p></li>
<li><p>La forma más sencilla y habitual de función recursiva es aquella
en la que <strong>la propia definición de la función contiene una o
varias llamadas a ella misma</strong>. En tal caso, decimos que la
función se llama a sí misma <em>directamente</em> o que hay una
<strong>recursividad directa</strong>.</p>
<p>Ese es el tipo de recursividad que vamos a estudiar.</p></li>
<li><p>Las definiciones recursivas son el mecanismo básico para ejecutar
<strong>repeticiones de instrucciones</strong> en un lenguaje de
programación funcional.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.1.0.0.1">

<ul>
<li><p>Por ejemplo: <span class="math display">f(n) = n + f(n +
1)</span></p></li>
<li><p>Esta función matemática es <em>recursiva</em> porque aparece ella
misma en su propia definición.</p>
<p>Para calcular el valor de <span class="math inline">f(n)</span>
tenemos que volver a utilizar la propia función <span
class="math inline">f</span>.</p></li>
<li><p>Por ejemplo: <span class="math display">f(1) = 1 + f(2) = 1 + 2 +
f(3) = 1 + 2 + 3 + f(4) = \ldots</span></p></li>
<li><p>Cada vez que una función se llama a sí misma decimos que se
realiza una <strong>llamada recursiva</strong> o <strong>paso
recursivo</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.1.0.0.2">

<div class="centered">
<p><img data-src="images/pintura-recursiva.jpg" class="plain"
style="width:100.0%" /></p>
</div>
</section>
<section id="ejercicio" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejercicio</h5>
<ol class="example" type="1">
<li>Desde el principio del curso ya hemos estado trabajando con
estructuras que pueden tener una definición recursiva. ¿Cuáles son?</li>
</ol>
</section>

<section id="casos-base-y-casos-recursivos"
class="title-slide slide level2" data-number="3.2">
<h2 data-number="3.2"><span class="header-section-number">3.2</span>
Casos base y casos recursivos</h2>
<ul>
<li><p>Resulta importante que una definición recursiva se detenga alguna
vez y proporcione un resultado, ya que si no, no sería útil (tendríamos
lo que se llama una <strong>recursión infinita</strong>).</p></li>
<li><p>Por tanto, en algún momento, la recursión debe alcanzar un punto
en el que la función no se llame a sí misma y se detenga.</p></li>
<li><p>Para ello, es necesario que la función, en cada paso recursivo,
se vaya acercando cada vez más a ese punto.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.0.0.1">

<ul>
<li><p>Ese punto en el que la función recursiva <strong>no se llama a sí
misma</strong>, se denomina <strong>caso base</strong>, y puede haber
más de uno.</p></li>
<li><p>Los casos base, por tanto, determinan bajo qué condiciones la
función no se llamará a sí misma, o dicho de otra forma, con qué valores
de sus argumentos la función devolverá directamente un valor y no
provocará una nueva llamada recursiva.</p></li>
<li><p>Los demás casos, que sí provocan llamadas recursivas, se
denominan <strong>casos recursivos</strong>.</p></li>
</ul>
</section>

<section id="el-factorial" class="title-slide slide level2"
data-number="3.3">
<h2 data-number="3.3"><span class="header-section-number">3.3</span> El
factorial</h2>
<ul>
<li><p>El ejemplo más típico de función recursiva es el
<strong>factorial</strong>.</p></li>
<li><p>El factorial de un número natural <span
class="math inline">n</span> se representa por <span
class="math inline">n!</span> y se define como el producto de todos los
números desde 1 hasta <span class="math inline">n</span>: <span
class="math display">n! =
n\cdot(n-1)\cdot(n-2)\cdot\cdots\cdot1</span></p>
<p>Por ejemplo: <span class="math display">6! =
6\cdot5\cdot4\cdot3\cdot2\cdot1 = 720</span></p></li>
<li><p>Pero para calcular <span class="math inline">6!</span> también se
puede calcular <span class="math inline">5!</span> y después multiplicar
el resultado por 6, ya que: <span class="math display">6! =
6\cdot\overbrace{5\cdot4\cdot3\cdot2\cdot1}^{5!}</span> <span
class="math display">6! = 6\cdot5!</span></p></li>
<li><p>Por tanto, el factorial se puede definir de forma
<strong>recursiva</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.0.0.1">

<ul>
<li><p>Tenemos el <strong>caso recursivo</strong>, pero necesitamos al
menos un <strong>caso base</strong> para evitar que la recursión se haga
<em>infinita</em>.</p></li>
<li><p>El caso base del factorial se obtiene sabiendo que el factorial
de 0 es directamente 1 (no hay que llamar al factorial recursivamente):
<span class="math display">0! = 1</span></p></li>
<li><p>Combinando ambos casos tendríamos:</p>
<p><span class="math display">n! = \begin{cases}
         1 &amp; \text{si } n = 0 \text{\quad(caso base)} \\
         n\cdot(n-1)! &amp; \text{si } n &gt; 0 \text{\quad(caso
recursivo)}
       \end{cases}</span></p></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.0.0.2">

<ul>
<li><p>La <strong>especificación</strong> de una función que calcule el
factorial de un número sería:</p>
<p><span class="math display">\left\{\begin{array}{ll}
  \text{\textbf{Pre}}: &amp; n \geq 0 \\[0.5em]
&amp; \texttt{factorial(\(n\):\,int)\;-&gt;\;int} \\[0.5em]
\text{\textbf{Post}}: &amp; \texttt{factorial(\(n\))} = n!
\end{array}\right.</span></p></li>
<li><p>Y su <strong>implementación</strong> en Python podría ser la
siguiente:</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>factorial <span class="op">=</span> <span class="kw">lambda</span> n: <span class="dv">1</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> n <span class="op">*</span> factorial(n <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div>
<p>que sería prácticamente una traducción literal de la definición
recursiva de factorial que acabamos de obtener.</p></li>
</ul>
</section>

<section id="diseño-de-funciones-recursivas"
class="title-slide slide level2" data-number="3.4">
<h2 data-number="3.4"><span class="header-section-number">3.4</span>
Diseño de funciones recursivas</h2>
<ul>
<li><p>El diseño de funciones recursivas se basa en:</p>
<ol>
<li><p>Identificación de casos base</p></li>
<li><p>Descomposición (reducción) del problema</p></li>
<li><p>Pensamiento optimista</p></li>
</ol></li>
</ul>
</section>
<section id="identificación-de-casos-base"
class="title-slide slide level3" data-number="3.4.1">
<h3 data-number="3.4.1"><span class="header-section-number">3.4.1</span>
Identificación de casos base</h3>
<ul>
<li><p>Debemos identificar los ejemplares para los cuales hay una
solución directa que no necesita recursividad.</p></li>
<li><p>Esos ejemplares representarán los <em>casos base</em> de la
función recursiva, y por eso los denominamos <em>ejemplares
básicos</em>.</p></li>
<li><p>Por ejemplo:</p>
<ul>
<li><p>Supongamos que queremos diseñar una función (llamada <span
class="math inline">fact</span>, por ejemplo) que calcule el factorial
de un número.</p>
<p>Es decir: <span class="math inline">fact(n)</span> debe devolver el
factorial de <span class="math inline">n</span>.</p></li>
<li><p>Sabemos que <span class="math inline">0! = 1</span>, por lo que
nuestra función podría devolver directamente <span
class="math inline">1</span> cuando se le pida calcular el factorial de
<span class="math inline">0</span>.</p></li>
<li><p>Por tanto, el caso base del factorial es el cálculo del factorial
de 0: <span class="math display">fact(0) = 1</span></p></li>
</ul></li>
</ul>
</section>

<section id="descomposición-reducción-del-problema"
class="title-slide slide level3" data-number="3.4.2">
<h3 data-number="3.4.2"><span class="header-section-number">3.4.2</span>
Descomposición (reducción) del problema</h3>
<ul>
<li><p>Reducimos el problema de forma que así tendremos un ejemplar
<em>más pequeño</em> del problema.</p></li>
<li><p>Un ejemplar más pequeño es aquel que está <strong>más cerca del
caso base</strong>.</p></li>
<li><p>De esta forma, cada ejemplar se irá acercando más y más al caso
base hasta que finalmente se alcanzará dicho caso base y eso detendrá la
recursión.</p></li>
<li><p>Es importante comprobar que eso se cumple, es decir, que la
reducción que le realizamos al problema produce ejemplares que están más
cerca del caso base, porque de lo contrario se produciría una
<em>recursión infinita</em>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.4.2.0.1">

<ul>
<li><p>En el ejemplo del factorial:</p>
<ul>
<li><p>El caso base es <span class="math inline">fact(0)</span>, es
decir, el caso en el que queremos calcular el factorial de 0, que ya
vimos que es directamente 1 (sin necesidad de llamadas
recursivas).</p></li>
<li><p>Si queremos resolver el problema de calcular, por ejemplo, el
factorial de 5, podríamos intentar reducir el problema a calcular el
factorial de 4, que es un número que está más cerca del caso base (que
es 0).</p></li>
<li><p>A su vez, para calcular el factorial de 4, reduciríamos el
problema a calcular el factorial de 3, y así sucesivamente.</p></li>
<li><p>De esta forma, podemos reducir el problema de calcular el
factorial de <span class="math inline">n</span> a calcular el factorial
de <span class="math inline">(n - 1)</span>, que es un número que está
más cerca del 0. Así, cada vez estaremos más cerca del caso base y, al
final, siempre lo acabaremos alcanzando.</p></li>
</ul></li>
</ul>
</section>

<section id="pensamiento-optimista" class="title-slide slide level3"
data-number="3.4.3">
<h3 data-number="3.4.3"><span class="header-section-number">3.4.3</span>
Pensamiento optimista</h3>
<ul>
<li><p>Consiste en suponer que la función deseada ya existe y que,
aunque no sabe resolver el ejemplar original del problema, sí que es
capaz de resolver ejemplares <em>más pequeños</em> de ese problema (este
paso se denomina <strong>hipótesis inductiva</strong> o
<strong>hipótesis de inducción</strong>).</p></li>
<li><p>Suponiendo que se cumple la <em>hipótesis inductiva</em>, y
aprovechando que ya contamos con un método para <em>reducir el ejemplar
a uno más pequeño</em>, ahora tratamos de encontrar un <em>patrón
común</em> de forma que resolver el ejemplar original implique usar el
mismo patrón en un ejemplar más pequeño.</p></li>
<li><p>Es decir:</p>
<ul>
<li><p>Al reducir el problema, obtenemos un ejemplar más pequeño del
mismo problema y, por tanto, podremos usar la función para poder
resolver ese ejemplar más pequeño (que sí sabe resolverlo, por hipótesis
inductiva).</p></li>
<li><p>A continuación, usamos dicha solución <em>parcial</em> para
tratar de obtener la solución para el ejemplar original del
problema.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.4.3.0.1">

<ul>
<li><p>En el ejemplo del factorial:</p>
<ul>
<li><p>Supongamos que queremos calcular, por ejemplo, el factorial de
6.</p></li>
<li><p>Aún no sabemos calcular el factorial de 6, pero suponemos (por
<em>hipótesis inductiva</em>) que sí sabemos calcular el factorial de
5.</p>
<p>En ese caso, ¿cómo puedo aprovechar que sé resolver el factorial de 5
para lograr calcular el factorial de 6?</p></li>
<li><p>Analizando el problema, observo que se cumple esta propiedad:
<span class="math display">6! =
6\cdot\overbrace{5\cdot4\cdot3\cdot2\cdot1}^{5!}=6\cdot 5!</span></p>
<p>Por tanto, he deducido un método para resolver el problema de
calcular el factorial de 6 a partir del factorial de 5: <em>para
calcular el factorial de 6 basta con calcular primero el factorial de 5
y luego multiplicar el resultado por 6</em>.</p>
<div class="caja">
<p>Dicho de otro modo: <em>si yo supiera</em> calcular el factorial de
5, me bastaría con multiplicarlo por 6 para obtener el factorial de
6.</p>
</div></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.4.3.0.2">

<ul>
<li><p>Generalizando para cualquier número, no sólo para el 6:</p>
<ul>
<li><p>Si queremos diseñar una función <span
class="math inline">fact(n)</span> que calcule el factorial de <span
class="math inline">n</span>, supondremos que esa función ya existe pero
que aún no sabe calcular el factorial de <span
class="math inline">n</span>, aunque <strong>sí sabe calcular el
factorial de <span class="math inline">\pmb{(n -
1)}</span></strong>.</p>
<p>Tenemos que creer en que es así y actuar como si fuera así, aunque
ahora mismo no sea verdad. <em>Ésta es nuestra <strong>hipótesis
inductiva</strong></em>.</p></li>
<li><p>Por otra parte, sabemos que: <span class="math display">n! =
n\cdot\overbrace{(n-1)\cdot(n-2)\cdot(n-3)\cdot2\cdot1}^{(n-1)!}=n\cdot(n-1)!</span></p>
<p>Por tanto, si sabemos calcular el factorial de <span
class="math inline">(n - 1)</span> llamando a <span
class="math inline">fact(n
- 1)</span>, para calcular <span class="math inline">fact(n)</span> sólo
necesito multiplicar <span class="math inline">n</span> por el resultado
de <span class="math inline">fact(n - 1)</span>.</p>
<div class="caja">
<p>Resumiendo: <strong><em>si yo supiera</em> calcular el factorial de
<span class="math inline">\pmb{(n - 1)}</span>, me bastaría con
multiplicarlo por <span class="math inline">\pmb{n}</span> para obtener
el factorial de <span class="math inline">\pmb{n}</span></strong>.</p>
</div></li>
<li><p>Así obtengo el caso recursivo de la función <em>fact</em>, que
sería: <span class="math display">fact(n) = n\cdot
fact(n-1)</span></p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.4.3.0.3">

<ul>
<li>Combinando todos los pasos, obtenemos la solución general:</li>
</ul>
<p><span class="math display">fact(n) = \begin{cases}
         1 &amp; \text{si } n = 0 \text{\quad(caso base)} \\
         n\cdot fact(n-1) &amp; \text{si } n &gt; 0 \text{\quad(caso
recursivo)}
       \end{cases}</span></p>
</section>


<section id="recursividad-lineal" class="title-slide slide level2"
data-number="3.5">
<h2 data-number="3.5"><span class="header-section-number">3.5</span>
Recursividad lineal</h2>
<ul>
<li><p>Una función tiene <strong>recursividad lineal</strong> si cada
llamada a la función recursiva genera, como mucho, otra llamada
recursiva a la misma función.</p></li>
<li><p>El factorial definido en el ejemplo anterior es un caso típico de
recursividad lineal ya que, cada vez que se llama al factorial se
genera, como mucho, otra llamada al factorial.</p></li>
<li><p>Eso se aprecia claramente observando que la definición del caso
recursivo de la función <span class="math inline">fact</span> contiene
una única llamada a la misma función <span
class="math inline">fact</span>:</p></li>
</ul>
<p><span class="math display">fact(n) = n\cdot fact(n-1)\quad \text{si }
n &gt; 0\quad \text{(caso recursivo)}</span></p>
</section>
<section id="procesos-recursivos-lineales"
class="title-slide slide level3" data-number="3.5.1">
<h3 data-number="3.5.1"><span class="header-section-number">3.5.1</span>
Procesos recursivos lineales</h3>
<ul>
<li><p>La forma más directa y sencilla de definir una función que
calcule el factorial de un número a partir de su definición recursiva
podría ser la siguiente:</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>factorial <span class="op">=</span> <span class="kw">lambda</span> n: <span class="dv">1</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> n <span class="op">*</span> factorial(n <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div></li>
<li><p>Utilizaremos el modelo de sustitución para observar el
funcionamiento de esta función al calcular <span
class="math inline">6!</span>:</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>factorial(<span class="dv">6</span>)</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> factorial(<span class="dv">5</span>))</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> factorial(<span class="dv">4</span>)))</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> factorial(<span class="dv">3</span>))))</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">*</span> factorial(<span class="dv">2</span>)))))</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">*</span> (<span class="dv">2</span> <span class="op">*</span> factorial(<span class="dv">1</span>))))))</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">*</span> (<span class="dv">2</span> <span class="op">*</span> (<span class="dv">1</span> <span class="op">*</span> factorial(<span class="dv">0</span>)))))))</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">*</span> (<span class="dv">2</span> <span class="op">*</span> (<span class="dv">1</span> <span class="op">*</span> <span class="dv">1</span>))))))</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">*</span> (<span class="dv">2</span> <span class="op">*</span> <span class="dv">1</span>)))))</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">*</span> <span class="dv">2</span>))))</span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> <span class="dv">6</span>)))</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> <span class="dv">24</span>))</span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> <span class="dv">120</span>)</span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">720</span></span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="3.5.1.0.1">

<ul>
<li><p>Podemos observar un perfil de <strong>expansión</strong> seguido
de una <strong>contracción</strong>:</p>
<ul>
<li><p>La <strong>expansión</strong> ocurre conforme el proceso
construye una secuencia de operaciones a realizar
<em>posteriormente</em> (en este caso, una secuencia de
multiplicaciones).</p></li>
<li><p>La <strong>contracción</strong> se realiza conforme se van
ejecutando realmente las multiplicaciones.</p></li>
</ul></li>
<li><p>Llamaremos <strong>proceso recursivo</strong> a este tipo de
proceso caracterizado por una secuencia de <strong>operaciones
pendientes de completar</strong>.</p></li>
<li><p>Para poder ejecutar este proceso, el intérprete necesita
<strong>memorizar</strong>, en algún lugar, un registro de las
multiplicaciones que se han dejado para más adelante.</p></li>
<li><p>En el cálculo de <span class="math inline">n!</span>, la longitud
de la secuencia de operaciones pendientes (y, por tanto, la información
que necesita almacenar el intérprete), crece <em>linealmente</em> con
<span class="math inline">n</span>, al igual que el número de pasos de
reducción.</p>
<p>A este tipo de procesos lo llamaremos <strong>proceso recursivo
<em>lineal</em></strong>.</p></li>
</ul>
</section>

<section id="procesos-iterativos-lineales"
class="title-slide slide level3" data-number="3.5.2">
<h3 data-number="3.5.2"><span class="header-section-number">3.5.2</span>
Procesos iterativos lineales</h3>
<ul>
<li><p>A continuación adoptaremos un enfoque diferente.</p></li>
<li><p>Podemos mantener un producto acumulado y un contador desde <span
class="math inline">n</span> hasta 1, de forma que el contador y el
producto cambien de un paso al siguiente según la siguiente regla:</p>
<p><span class="math display">\begin{array}{l}
    acumulador_{nuevo} = acumulador_{viejo} \cdot contador_{viejo}
\\[0.5em]
    contador_{nuevo} = contador_{viejo} - 1
  \end{array}</span></p></li>
<li><p>Su traducción a Python podría ser la siguiente, usando una
función auxiliar <code>fact_iter</code>:</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>fact_iter <span class="op">=</span> <span class="kw">lambda</span> cont, acc: acc <span class="cf">if</span> cont <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="op">\</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>                              fact_iter(cont <span class="op">-</span> <span class="dv">1</span>, cont <span class="op">*</span> acc)</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>factorial <span class="op">=</span> <span class="kw">lambda</span> n: fact_iter(n, <span class="dv">1</span>)</span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="3.5.2.0.1">

<ul>
<li><p>Al igual que antes, usaremos el modelo de sustitución para
visualizar el proceso del cálculo de <span
class="math inline">6!</span>:</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>factorial(<span class="dv">6</span>)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> fact_iter(<span class="dv">6</span>, <span class="dv">1</span>)</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> fact_iter(<span class="dv">5</span>, <span class="dv">6</span>)</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> fact_iter(<span class="dv">4</span>, <span class="dv">30</span>)</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> fact_iter(<span class="dv">3</span>, <span class="dv">120</span>)</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> fact_iter(<span class="dv">2</span>, <span class="dv">360</span>)</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> fact_iter(<span class="dv">1</span>, <span class="dv">720</span>)</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> fact_iter(<span class="dv">0</span>, <span class="dv">720</span>)</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">720</span></span></code></pre></div></li>
<li><p>Este proceso no tiene expansiones ni contracciones ya que, en
cada instante, toda la información que se necesita almacenar es el valor
actual de los parámetros <code class="sourceCode python">cont</code> y
<code class="sourceCode python">acc</code>, por lo que el tamaño de la
memoria necesaria es constante.</p></li>
<li><p>A este tipo de procesos lo llamaremos <strong>proceso
iterativo</strong>.</p></li>
<li><p>El número de pasos necesarios para calcular <span
class="math inline">n!</span> usando esta función crece
<em>linealmente</em> con <span class="math inline">n</span>.</p>
<p>A este tipo de procesos lo llamaremos <strong>proceso iterativo
<em>lineal</em></strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.5.2.0.2">

<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 37%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">Tipo de proceso</th>
<th style="text-align: left;">Número de reducciones</th>
<th style="text-align: left;">Memoria necesaria</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Recursivo</td>
<td style="text-align: left;">Proporcional a <span
class="math inline">\underline{n}</span></td>
<td style="text-align: left;">Proporcional a <span
class="math inline">\underline{n}</span></td>
</tr>
<tr>
<td style="text-align: left;">Iterativo</td>
<td style="text-align: left;">Proporcional a <span
class="math inline">\underline{n}</span></td>
<td style="text-align: left;">Constante</td>
</tr>
</tbody>
</table>
<p><br>* * *<br></p>
<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 36%" />
<col style="width: 36%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">Tipo de proceso</th>
<th style="text-align: left;">Número de reducciones</th>
<th style="text-align: left;">Memoria necesaria</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Recursivo lineal</td>
<td style="text-align: left;">Linealmente<br />
proporcional a <span class="math inline">\underline{n}</span></td>
<td style="text-align: left;">Linealmente<br />
proporcional a <span class="math inline">\underline{n}</span></td>
</tr>
<tr>
<td style="text-align: left;">Iterativo lineal</td>
<td style="text-align: left;">Linealmente<br />
proporcional a <span class="math inline">\underline{n}</span></td>
<td style="text-align: left;">Constante</td>
</tr>
</tbody>
</table>
</section>
<section class="slide level5" data-number="3.5.2.0.3">

<ul>
<li><p>En general, un <strong>proceso iterativo</strong> es aquel que
está definido por una serie de <strong>coordenadas de estado</strong>
junto con una <strong>regla</strong> fija que describe cómo actualizar
dichas coordenadas conforme cambia el proceso de un estado al
siguiente.</p></li>
<li><p>La <strong>diferencia entre los procesos recursivo e
iterativo</strong> se puede describir de esta otra manera:</p>
<ul>
<li><p>En el <strong>proceso iterativo</strong>, los parámetros dan una
descripción completa del estado del proceso en cada instante.</p>
<p>Así, si parásemos el cálculo entre dos pasos, lo único que
necesitaríamos hacer para seguir con el cálculo es darle al intérprete
el valor de los dos parámetros.</p></li>
<li><p>En el <strong>proceso recursivo</strong>, el intérprete tiene que
mantener cierta información <em>oculta</em> que no está almacenada en
ningún parámetro y que indica qué operaciones ha realizado hasta ahora y
cuáles quedan pendientes por hacer.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.5.2.0.4">

<ul>
<li><p>No debe confundirse un <strong>proceso recursivo</strong> con una
<strong>función recursiva</strong>:</p>
<ul>
<li><p>Cuando hablamos de <em>función recursiva</em> nos referimos al
hecho de que la función se llama a sí misma (directa o
indirectamente).</p></li>
<li><p>Cuando hablamos de <em>proceso recursivo</em> nos referimos a la
forma en como se desenvuelve la ejecución de la función (con una
expansión más una contracción).</p></li>
</ul></li>
<li><p>Puede parecer extraño que digamos que una función recursiva (por
ejemplo, <code class="sourceCode python">fact_iter</code>) genera un
proceso iterativo.</p>
<p>Sin embargo, el proceso es realmente iterativo porque su estado está
definido completamente por dos parámetros, y para ejecutar el proceso
sólo se necesita almacenar el valor de esos dos parámetros.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.5.2.0.5">

<ul>
<li><p>Aquí hemos visto un ejemplo donde se aprecia claramente que
<strong>una función sólo puede tener una especificación</strong> pero
<strong>puede tener varias implementaciones</strong> distintas.</p></li>
<li><p>Eso sí: todas las implementaciones de una función deben
satisfacer su especificación.</p></li>
<li><p>En este caso, las dos implementaciones son:</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>factorial <span class="op">=</span> <span class="kw">lambda</span> n: <span class="dv">1</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> n <span class="op">*</span> factorial(n <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div>
<p>y</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>fact_iter <span class="op">=</span> <span class="kw">lambda</span> cont, acc: acc <span class="cf">if</span> cont <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="op">\</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>                              fact_iter(cont <span class="op">-</span> <span class="dv">1</span>, cont <span class="op">*</span> acc)</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>factorial <span class="op">=</span> <span class="kw">lambda</span> n: fact_iter(n, <span class="dv">1</span>)</span></code></pre></div></li>
<li><p>Y aunque las dos satisfacen la misma especificación (y, por
tanto, calculan exactamente los mismos valores), lo hacen de una forma
muy diferente, generando incluso procesos de distinto tipo.</p></li>
</ul>
</section>


<section id="recursividad-múltiple" class="title-slide slide level2"
data-number="3.6">
<h2 data-number="3.6"><span class="header-section-number">3.6</span>
Recursividad múltiple</h2>
<ul>
<li><p>Una función tiene <strong>recursividad múltiple</strong> cuando
la misma llamada a la función recursiva puede generar más de una llamada
recursiva a la misma función.</p></li>
<li><p>El ejemplo clásico es la función que calcula los términos de la
<strong>sucesión de Fibonacci</strong>.</p></li>
<li><p>La sucesión comienza con los números 0 y 1, y a partir de éstos,
cada término es la suma de los dos anteriores:</p>
<p>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987,
1597, …</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.6.0.0.1">

<ul>
<li><p>Podemos definir una función recursiva que devuelva el <span
class="math inline">n</span>-ésimo término de la sucesión de
Fibonacci:</p>
<p><span class="math display">fib(n) = \begin{cases}
             0 &amp; \text{si } n = 0 \text{\quad (caso base)} \\
             1 &amp; \text{si } n = 1 \text{\quad (caso base)} \\
             fib(n - 1) + fib(n - 2) &amp; \text{si } n &gt; 1
\text{\quad (caso recursivo)}
           \end{cases}</span></p></li>
</ul>
</section>
<section class="slide level5" data-number="3.6.0.0.2">

<ul>
<li><p>La especificación de una función que devuelva el <span
class="math inline">n</span>-ésimo término de la sucesión de Fibonacci
sería:</p>
<p><span class="math display">\left\{\begin{array}{ll}
  \text{\textbf{Pre}}: &amp; n \geq 0 \\[0.5em]
&amp; \texttt{fib(\(n\):\,int)\;-&gt;\;int} \\[0.5em]
\text{\textbf{Post}}: &amp; \texttt{fib(\(n\))} = \text{el \(n\)-ésimo
término de la sucesión de Fibonacci}
\end{array}\right.</span></p></li>
<li><p>Y su implementación en Python podría ser:</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>fib <span class="op">=</span> <span class="kw">lambda</span> n: <span class="dv">0</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">1</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span> <span class="cf">else</span> fib(n <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> fib(n <span class="op">-</span> <span class="dv">2</span>)</span></code></pre></div>
<p>o bien, separando la definición en varias líneas:</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>fib <span class="op">=</span> <span class="kw">lambda</span> n: <span class="dv">0</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="op">\</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>                <span class="dv">1</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span> <span class="cf">else</span> <span class="op">\</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>                fib(n <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> fib(n <span class="op">-</span> <span class="dv">2</span>)</span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="3.6.0.0.3">

<ul>
<li><p>Si vemos el perfil de ejecución de <code
class="sourceCode python">fib(<span class="dv">5</span>)</code>, vemos
que:</p>
<ul>
<li><p>Para calcular <code
class="sourceCode python">fib(<span class="dv">5</span>)</code>, antes
debemos calcular <code
class="sourceCode python">fib(<span class="dv">4</span>)</code> y <code
class="sourceCode python">fib(<span class="dv">3</span>)</code>.</p></li>
<li><p>Para calcular <code
class="sourceCode python">fib(<span class="dv">4</span>)</code>, antes
debemos calcular <code
class="sourceCode python">fib(<span class="dv">3</span>)</code> y <code
class="sourceCode python">fib(<span class="dv">2</span>)</code>.</p></li>
<li><p>Así sucesivamente hasta poner todo en función de <code
class="sourceCode python">fib(<span class="dv">0</span>)</code> y <code
class="sourceCode python">fib(<span class="dv">1</span>)</code>, que se
pueden calcular directamente (son los casos base).</p></li>
</ul></li>
<li><p>En general, el proceso resultante tiene forma de árbol.</p></li>
<li><p>Por eso decimos que las funciones con recursividad múltiple
generan <strong>procesos recursivos en árbol</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.6.0.0.4">

<div class="centered">
<p><img data-src="images/arbol-fibonacci.svg" class="plain"
style="width:80.0%" /></p>
</div>
</section>
<section class="slide level5" data-number="3.6.0.0.5">

<ul>
<li><p>La función anterior es un buen ejemplo de recursión en árbol,
pero desde luego es un método <em>horrible</em> para calcular los
números de Fibonacci, por la cantidad de <strong>operaciones
redundantes</strong> que efectúa.</p></li>
<li><p>Para tener una idea de lo malo que es, se puede observar que
<span class="math inline">fib(n)</span> crece exponencialmente en
función de <span class="math inline">n</span>.</p></li>
<li><p>Por lo tanto, el proceso necesita una cantidad de tiempo que
crece <strong>exponencialmente</strong> con <span
class="math inline">n</span>.</p></li>
<li><p>Por otro lado, el espacio necesario sólo crece
<strong>linealmente</strong> con <span class="math inline">n</span>,
porque en un cierto momento del cálculo sólo hay que memorizar los nodos
que hay por encima.</p></li>
<li><p>En general, en un proceso recursivo en árbol <strong>el tiempo de
ejecución crece con el <em>número de nodos</em> del árbol</strong>
mientras que <strong>el espacio necesario crece con la <em>altura
máxima</em> del árbol</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.6.0.0.6">

<ul>
<li><p>Se puede construir un <strong>proceso iterativo</strong> para
calcular los números de Fibonacci.</p></li>
<li><p>La idea consiste en usar dos coordenadas de estado <em>a</em> y
<em>b</em> (con valores iniciales 0 y 1, respectivamente) y aplicar
repetidamente la siguiente transformación:</p>
<p><span class="math display">\begin{array}{l}
    a_{nuevo} = b_{viejo} \\[0.5em]
    b_{nuevo} = b_{viejo} + a_{viejo}
  \end{array}</span></p></li>
<li><p>Después de <span class="math inline">n</span> pasos, <em>a</em> y
<em>b</em> contendrán <span class="math inline">fib(n)</span> y <span
class="math inline">fib(n + 1)</span>, respectivamente.</p></li>
<li><p>En Python sería:</p>
<div class="sourceCode" id="cb41"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>fib_iter <span class="op">=</span> <span class="kw">lambda</span> cont, a, b: a <span class="cf">if</span> cont <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> fib_iter(cont <span class="op">-</span> <span class="dv">1</span>, b, a <span class="op">+</span> b)</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>fib <span class="op">=</span> <span class="kw">lambda</span> n: fib_iter(n, <span class="dv">0</span>, <span class="dv">1</span>)</span></code></pre></div></li>
<li><p>Esta función genera un proceso iterativo lineal, por lo que es
mucho más eficiente.</p></li>
</ul>
</section>

<section id="recursividad-final-y-no-final"
class="title-slide slide level2" data-number="3.7">
<h2 data-number="3.7"><span class="header-section-number">3.7</span>
Recursividad final y no final</h2>
<ul>
<li><p>Lo que diferencia al <code
class="sourceCode python">fact_iter</code> que genera un proceso
iterativo del <code class="sourceCode python">factorial</code> que
genera un proceso recursivo, es el hecho de que <code
class="sourceCode python">fact_iter</code> se llama a sí misma y
devuelve directamente el valor que le ha devuelto su llamada recursiva
sin hacer luego nada más.</p>
<p>En cambio, <code class="sourceCode python">factorial</code> tiene que
hacer una multiplicación después de llamarse a sí misma y antes de
terminar de ejecutarse:</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Versión con recursividad final:</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>fact_iter <span class="op">=</span> <span class="kw">lambda</span> cont, acc: acc <span class="cf">if</span> cont <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="op">\</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>                              fact_iter(cont <span class="op">-</span> <span class="dv">1</span>, acc <span class="op">*</span> cont)</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>fact <span class="op">=</span> <span class="kw">lambda</span> n: fact_iter(n, <span class="dv">1</span>)</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Versión con recursividad no final:</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>factorial <span class="op">=</span> <span class="kw">lambda</span> n: <span class="dv">1</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> n <span class="op">*</span> factorial(n <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="3.7.0.0.1">

<ul>
<li><p>Es decir:</p>
<ul>
<li><p><code class="sourceCode python">fact_iter(cont, acc)</code>
simplemente llama a:</p>
<p><code
class="sourceCode python">fact_iter(cont <span class="op">-</span> <span class="dv">1</span>, acc <span class="op">*</span> cont)</code></p>
<p>y luego devuelve directamente el valor que le entrega ésta llamada,
sin hacer ninguna otra operación posterior antes de terminar.</p></li>
<li><p>En cambio, <code class="sourceCode python">factorial(n)</code>
hace:</p>
<p><code
class="sourceCode python">n <span class="op">*</span> factorial(n <span class="op">-</span> <span class="dv">1</span>)</code></p>
<p>o sea, se llama a sí misma pero el resultado de la llamada recursiva
tiene que multiplicarlo luego por <code
class="sourceCode python">n</code> antes de devolver el resultado
final.</p></li>
</ul></li>
<li><p>Por tanto, <strong>lo último que hace <code
class="sourceCode python">fact_iter</code> es llamarse a sí
misma</strong>. En cambio, lo último que hace <code
class="sourceCode python">factorial</code> no es llamarse a sí misma,
porque tiene que hacer más operaciones (en este caso, la multiplicación)
antes de devolver el resultado.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.7.0.0.2">

<ul>
<li><p>Cuando lo último que hace una función recursiva es llamarse a sí
misma y devolver directamente el valor devuelto por esa llamada
recursiva, decimos que la función es <strong>recursiva final</strong> o
que tiene <strong>recursividad final</strong>.</p></li>
<li><p>En caso contrario, decimos que la función es <strong>recursiva no
final</strong> o que tiene <strong>recursividad no
final</strong>.</p></li>
<li><p><strong>Las funciones recursivas finales generan procesos
iterativos.</strong></p></li>
<li><p>La función <code>fact_iter</code> es recursiva final, y por eso
genera un proceso iterativo.</p></li>
<li><p>En cambio, la función <code>factorial</code> es recursiva no
final, y por eso genera un proceso recursivo.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.7.0.0.3">

<ul>
<li><p>En la práctica, para que un proceso iterativo consuma realmente
una cantidad constante de memoria, es necesario que el traductor
<strong>optimice la recursividad final</strong>.</p></li>
<li><p>Ese tipo de optimización se denomina <strong><em>tail-call
optimization (TCO)</em></strong>.</p></li>
<li><p>No muchos traductores optimizan la recursividad final.</p></li>
<li><p>De hecho, ni el intérprete de Python ni la máquina virtual de
Java optimizan la recursividad final.</p></li>
<li><p>Por tanto, en estos dos lenguajes, las funciones recursivas
finales consumen tanta memoria como las no finales.</p></li>
</ul>
</section>
</section>
<section>
<section id="abstracciones-funcionales" class="title-slide slide level1"
data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span>
Abstracciones funcionales</h1>

</section>
<section id="pureza" class="title-slide slide level2" data-number="4.1">
<h2 data-number="4.1"><span class="header-section-number">4.1</span>
Pureza</h2>
<ul>
<li><p>Si una expresión lambda no contiene identificadores libres, el
valor que obtendremos al aplicarla a unos argumentos dependerá
únicamente del valor que tengan esos argumentos (no dependerá de nada
más que sea «<em>exterior</em>» a la expresión lambda).</p></li>
<li><p>En cambio, si el cuerpo de una expresión lambda contiene
identificadores libres, el valor que obtendremos al aplicarla a unos
argumentos no sólo dependerá del valor de los argumentos, sino también
de los valores a los que estén ligados esos identificadores libres en el
momento de evaluar la aplicación de la expresión lambda.</p></li>
<li><p>Es el caso del ejemplo anterior, donde tenemos una expresión
lambda que contiene un identificador libre (<code
class="sourceCode python">z</code>) y, por tanto, cuando la aplicamos a
los argumentos <code
class="sourceCode python"><span class="dv">4</span></code> y <code
class="sourceCode python"><span class="dv">3</span></code> obtenemos un
valor que depende no sólo de los valores de <code
class="sourceCode python">x</code> e <code
class="sourceCode python">y</code> sino también del valor de <code
class="sourceCode python">z</code> en el entorno:</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> prueba <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y <span class="op">+</span> z</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> z <span class="op">=</span> <span class="dv">9</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> prueba(<span class="dv">4</span>, <span class="dv">3</span>)</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a><span class="dv">16</span></span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="4.1.0.0.1">

<ul>
<li><p>En este otro ejemplo, escribimos una expresión lambda que calcula
la suma de tres números a partir de otra expresión lambda que calcula la
suma de dos números:</p>
<div class="sourceCode" id="cb44"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>suma <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>suma3 <span class="op">=</span> <span class="kw">lambda</span> x, y, z: suma(x, y) <span class="op">+</span> z</span></code></pre></div>
<p>En este caso, hay un identificador (<code
class="sourceCode python">suma</code>) que no aparece en la lista de
parámetros de la expresión lambda ligada a <code
class="sourceCode python">suma3</code>.</p>
<p>En consecuencia, el valor de dicha expresión lambda dependerá de lo
que valga <code class="sourceCode python">suma</code> en el entorno
actual.</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.1.0.0.2">

<ul>
<li><p>Se dice que una expresión lambda es <strong>pura</strong> si,
siempre que la apliquemos a unos argumentos, el valor obtenido va a
depender únicamente del valor de esos argumentos o, lo que es lo mismo,
del valor de sus parámetros en la llamada.</p></li>
<li><p>Podemos decir que hay distintos <strong>grados de
pureza</strong>:</p>
<ul>
<li><p>Una expresión lambda en cuyo cuerpo no hay ningún identificador
libre es <strong>más pura</strong> que otra que contiene identificadores
libres.</p></li>
<li><p>Una expresión lambda cuyos <strong>identificadores
libres</strong> representan <strong>funciones</strong> que se usan en el
cuerpo de la expresión lambda, es <strong>más pura</strong> que otra
cuyos identificadores libres representan cualquier otro tipo de
valor.</p></li>
</ul>
<p>En el ejemplo anterior, tenemos que la expresión lambda de <code
class="sourceCode python">suma3</code>, sin ser <em>totalmente
pura</em>, a efectos prácticos se la puede considerar
<strong>pura</strong>, ya que su único identificador libre (<code
class="sourceCode python">suma</code>) se usa como una
<strong>función</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.1.0.0.3">

<ul>
<li><p>Por ejemplo, las siguientes expresiones lambda están ordenadas de
mayor a menor pureza, siendo la primera totalmente
<strong>pura</strong>:</p>
<div class="sourceCode" id="cb45"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co"># producto es una expresión lambda totalmente pura:</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>producto <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">*</span> y</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="co"># cuadrado es casi pura; a efectos prácticos se la puede</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="co"># considerar pura ya que sus identificadores libres (en este</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a><span class="co"># caso, sólo una: producto) son funciones:</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>cuadrado <span class="op">=</span> <span class="kw">lambda</span> x: producto(x, x)</span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a><span class="co"># suma es impura, porque su identificador libre (z) no es una función:</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>suma <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y <span class="op">+</span> z</span></code></pre></div></li>
<li><p><strong>La pureza de una función es un rasgo deseado y que hay
que tratar de alcanzar siempre que sea posible</strong>, ya que facilita
el desarrollo y mantenimiento de los programas, además de simplificar el
razonamiento sobre los mismos, permitiendo aplicar directamente nuestro
modelo de sustitución.</p></li>
<li><p>Es más incómodo trabajar con <code
class="sourceCode python">suma</code> porque hay que <em>recordar</em>
que depende de un valor que está <em>fuera</em> de la expresión lambda,
cosa que no resulta evidente a no ser que mires en el cuerpo de la
expresión lambda.</p></li>
</ul>
</section>

<section id="las-funciones-como-abstracciones"
class="title-slide slide level2" data-number="4.2">
<h2 data-number="4.2"><span class="header-section-number">4.2</span> Las
funciones como abstracciones</h2>
<ul>
<li><p>Recordemos la definición de la función <code
class="sourceCode python">area</code>:</p>
<div class="sourceCode" id="cb46"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>cuadrado <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> x</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>area <span class="op">=</span> <span class="kw">lambda</span> r: <span class="fl">3.1416</span> <span class="op">*</span> cuadrado(r)</span></code></pre></div></li>
<li><p>Aunque es muy sencilla, la función <code
class="sourceCode python">area</code> ejemplifica la propiedad más
potente de las funciones definidas por el programador: la
<strong>abstracción</strong>.</p></li>
<li><p>La función <code class="sourceCode python">area</code> está
definida sobre la función <code
class="sourceCode python">cuadrado</code>, pero sólo necesita saber de
ella qué resultados de salida devuelve a partir de sus argumentos de
entrada (o sea, <strong><em>qué</em></strong> calcula y no
<strong><em>cómo</em></strong> lo calcula).</p></li>
<li><p>Podemos escribir la función <code
class="sourceCode python">area</code> sin preocuparnos de cómo calcular
el cuadrado de un número, porque eso ya lo hace la función <code
class="sourceCode python">cuadrado</code>.</p></li>
<li><p><strong>Los detalles</strong> sobre cómo se calcula el cuadrado
están <strong>ocultos dentro de la definición</strong> de <code
class="sourceCode python">cuadrado</code>. Esos detalles <strong>se
ignoran en este momento</strong> al diseñar <code
class="sourceCode python">area</code>, para considerarlos más tarde si
hiciera falta.</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.0.0.1">

<ul>
<li><p>De hecho, por lo que respecta a <code
class="sourceCode python">area</code>, <code
class="sourceCode python">cuadrado</code> no representa una definición
concreta de función, sino más bien la abstracción de una función, lo que
se denomina una <strong>abstracción funcional</strong>, ya que a <code
class="sourceCode python">area</code> le sirve igual de bien cualquier
función que calcule el cuadrado de un número.</p></li>
<li><p>Por tanto, si consideramos únicamente los valores que devuelven,
las tres funciones siguientes son indistinguibles e igual de válidas
para <code class="sourceCode python">area</code>. Ambas reciben un
argumento numérico y devuelven el cuadrado de ese número:</p>
<div class="sourceCode" id="cb47"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>cuadrado <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> x</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>cuadrado <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>cuadrado <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> (x <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> x</span></code></pre></div></li>
<li><p>En otras palabras: la definición de una función debe ser capaz de
<strong>ocultar sus detalles internos de funcionamiento</strong>, ya que
para usar la función no debe ser necesario conocer esos
detalles.</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.0.0.2">

<ul>
<li><p>«<em>Abstraer</em>» es centrarse en lo importante en un
determinado momento e ignorar lo que en ese momento no resulta
importante.</p></li>
<li><p>«<em>Crear una abstracción</em>» es meter un mecanismo más o
menos complejo dentro de una caja negra y darle un nombre, de forma que
podamos referirnos a todo el conjunto simplemente usando su nombre y sin
tener que conocer su composición interna ni sus detalles internos de
funcionamiento.</p></li>
<li><p>Por tanto, para usar la abstracción nos bastará con conocer su
<em>nombre</em> y <em>lo que hace</em>, sin necesidad de saber <em>cómo
lo hace</em> ni de qué elementos está formada
<em>internamente</em>.</p></li>
<li><p><strong>La abstracción es el principal instrumento de control de
la complejidad</strong>, ya que nos permite ocultar detrás de un nombre
los detalles que componen una parte del programa, haciendo que esa parte
actúe (a ojos del programador que la utilice) como si fuera un elemento
<em>predefinido</em> del lenguaje.</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.0.0.3">

<ul>
<li><p><strong>Las funciones son</strong>, por tanto,
<strong>abstracciones</strong> porque nos permiten usarlas sin tener que
conocer los detalles internos del procesamiento que realizan.</p></li>
<li><p>Por ejemplo, si queremos usar la función <code
class="sourceCode python">cubo</code> (que calcula el cubo de un
número), nos da igual que dicha función esté implementada de cualquiera
de las siguientes maneras:</p>
<div class="sourceCode" id="cb48"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>cubo <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> x <span class="op">*</span> x</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>cubo <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">**</span> <span class="dv">3</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>cubo <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> x <span class="op">**</span> <span class="dv">2</span></span></code></pre></div></li>
<li><p>Para <strong>usar</strong> la función, nos basta con saber que
calcula el cubo de un número, sin necesidad de saber qué cálculo
concreto realiza para obtener el resultado.</p></li>
<li><p>Los detalles de implementación quedan ocultos y por eso también
decimos que <code class="sourceCode python">cubo</code> es una
abstracción.</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.0.0.4">

<ul>
<li><p>Las funciones también son abstracciones porque describen
operaciones compuestas a realizar sobre ciertos valores sin importar
cuáles sean esos valores en concreto (son
<strong><em>generalizaciones</em></strong> de casos
particulares).</p></li>
<li><p>Por ejemplo, cuando definimos:</p>
<div class="sourceCode" id="cb49"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>cubo <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> x <span class="op">*</span> x</span></code></pre></div>
<p>no estamos hablando del cubo de un número en particular, sino más
bien de un <strong>método</strong> para calcular el cubo de cualquier
número.</p></li>
<li><p>Por supuesto, nos las podemos arreglar sin definir el concepto de
<em>cubo</em>, escribiendo siempre expresiones explícitas (como <code
class="sourceCode python"><span class="dv">3</span><span class="op">*</span><span class="dv">3</span><span class="op">*</span><span class="dv">3</span></code>,
<code
class="sourceCode python">y<span class="op">*</span>y<span class="op">*</span>y</code>,
etc.) sin usar la palabra «cubo», pero eso nos obligaría siempre a
expresarnos usando las operaciones primitivas de nuestro lenguaje (como
<code>*</code>), en vez de poder usar términos de más alto nivel.</p>
<p>Es decir: <strong>nuestros programas podrían calcular el cubo de un
número, pero no tendrían la habilidad de expresar el concepto de
<em>elevar al cubo</em></strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.0.0.5">

<ul>
<li><p>Una de las habilidades que deberíamos pedir a un lenguaje potente
es la posibilidad de <strong>construir abstracciones</strong> asignando
nombres a los patrones más comunes, y luego trabajar directamente usando
dichas abstracciones.</p></li>
<li><p>Las funciones nos permiten esta habilidad, y esa es la razón de
que todos los lenguajes (salvo los más primitivos) incluyan mecanismos
para definir funciones.</p></li>
<li><p>Por ejemplo: en el caso anterior, vemos que hay un patrón
(multiplicar algo por sí mismo tres veces) que se repite con frecuencia,
y a partir de él construimos una abstracción que asigna un nombre a ese
patrón (<em>elevar al cubo</em>).</p></li>
<li><p>Esa abstracción la definimos como una función que describe la
<em>regla</em> necesaria para elevar algo al cubo.</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.0.0.6">

<ul>
<li><p>Por tanto, algunas veces, analizando ciertos <em>casos
particulares</em>, observamos que se repite el mismo patrón en todos
ellos, y de ahí extraemos un <em>caso general</em> que agrupa a todos
los posibles casos particulares que cumplen el mismo patrón.</p></li>
<li><p>A ese caso general le damos un nombre y ocultamos sus detalles
internos en una «caja negra».</p></li>
<li><p>Eso es una <strong>abstracción</strong>.</p></li>
<li><p>En resumen, creamos abstracciones:</p>
<ul>
<li><p>Cuando creamos <strong>casos generales a partir de patrones que
se repiten</strong> en varios casos particulares.</p></li>
<li><p>Cuando queremos <strong>reducir la complejidad</strong>, dándole
un nombre a un mecanismo complejo para poder referirnos a todo el
conjunto a través de su nombre sin tener que recordar continuamente qué
piezas contiene el mecanismo o cómo funciona éste por dentro.</p></li>
<li><p>Cuando queremos que nuestro programa pueda <strong>expresar un
concepto abstracto</strong>, como el de «elevar al cubo».</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.0.0.7">

<ul>
<li><p>Por ejemplo, cuando vemos que en nuestros programas es frecuente
tener que multiplicar una cosa por sí misma tres veces, deducimos que
ahí hay un patrón común que se repite en todos los casos.</p></li>
<li><p>De ahí, creamos la abstracción que describe ese patrón general y
le llamamos «<em>elevar al cubo</em>»:</p></li>
</ul>
<div class="centered">
<p><img data-src="images/de-particular-a-general.svg" class="plain"
style="width:80.0%" /></p>
</div>
</section>
<section class="slide level5" data-number="4.2.0.0.8">

<ul>
<li><p>La <strong>especificación de una <em>función</em></strong> es la
descripción de <strong>qué</strong> hace la función sin entrar a
detallar <strong>cómo</strong> lo hace.</p></li>
<li><p>La <strong>implementación de una <em>función</em></strong> es la
descripción de <strong>cómo</strong> hace lo que hace, es decir, los
detalles de su algoritmo interno.</p></li>
<li><p><strong>Para poder usar una función, un programador no debe
necesitar saber cómo está implementada</strong>.</p></li>
<li><p>Eso es lo que ocurre, por ejemplo, con las funciones predefinidas
del lenguaje (como <code
class="sourceCode python"><span class="bu">max</span></code>, <code
class="sourceCode python"><span class="bu">abs</span></code> o <code
class="sourceCode python"><span class="bu">len</span></code>): sabemos
<em>qué</em> hacen pero no necesitamos saber <em>cómo</em> lo
hacen.</p></li>
<li><p>Incluso puede que el usuario de una función no sea el mismo que
la ha escrito, sino que la puede haber recibido de otro programador como
una «<strong>caja negra</strong>», que tiene unas entradas y una salida
pero no se sabe cómo funciona por dentro.</p></li>
</ul>
</section>
<section id="especificaciones-de-funciones"
class="title-slide slide level3" data-number="4.2.1">
<h3 data-number="4.2.1"><span class="header-section-number">4.2.1</span>
Especificaciones de funciones</h3>
<ul>
<li><p>Para poder <strong>usar una abstracción funcional</strong>
<em>nos basta</em> con conocer su <em>especificación</em>, porque es la
descripción de qué hace esa función.</p></li>
<li><p>Igualmente, para poder <strong>implementar una abstracción
funcional</strong> <em>necesitamos</em> conocer su
<em>especificación</em>, ya que necesitamos saber <em>qué tiene que
hacer</em> la función antes de diseñar <em>cómo va a
hacerlo</em>.</p></li>
<li><p>La especificación de una abstracción funcional describe tres
características fundamentales de dicha función:</p>
<ul>
<li><p>El <strong>dominio</strong>: el conjunto de datos de entrada
válidos.</p></li>
<li><p>El <strong>rango</strong> o <strong>codominio</strong>: el
conjunto de posibles valores que devuelve.</p></li>
<li><p>El <strong>propósito</strong>: qué hace la función, es decir, la
relación entre su entrada y su salida.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.1.0.1">

<ul>
<li><p>Hasta ahora, al especificar <strong>programas</strong>, hemos
llamado «<strong>entrada</strong>» al dominio, y hemos agrupado el rango
y el propósito en una sola propiedad que llamamos
«<strong>salida</strong>».</p></li>
<li><p>Por ejemplo, cualquier función <code
class="sourceCode python">cuadrado</code> que usemos para implementar
<code class="sourceCode python">area</code> debe satisfacer esta
especificación:</p>
<p><span class="math display">\begin{cases}
  \text{\textbf{Entrada}}: n \in \mathbb{R} \\
  \texttt{cuadrado} \\
  \text{\textbf{Salida}}: n^2
\end{cases}</span></p></li>
<li><p>La especificación <strong>no concreta cómo</strong> se debe
llevar a cabo el propósito. Esos son <strong>detalles de
implementación</strong> que se abstraen a este nivel.</p></li>
<li><p>Este esquema es el que hemos usado hasta ahora para especificar
programas, y se podría seguir usando para especificar funciones, ya que
éstas son consideradas <em>subprogramas</em> (programas que forman parte
de otros programas más grandes).</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.1.0.2">

<ul>
<li><p>Pero para especificar funciones resulta más adecuado usar el
siguiente esquema, al que llamaremos <strong>especificación
funcional</strong>:</p>
<p><span class="math display">\left\{\begin{array}{ll}
  \text{\textbf{Pre}}: &amp; \texttt{True} \\[0.5em]
&amp; \texttt{cuadrado(\(n\):\,float)\;-&gt;\;float} \\[0.5em]
\text{\textbf{Post}}: &amp; \texttt{cuadrado(\(n\))} = n^2
\end{array}\right.</span></p></li>
<li><p>«<strong>Pre</strong>» representa la
<strong>precondición</strong>: la propiedad que debe cumplirse justo
<em>en el momento</em> de llamar a la función.</p></li>
<li><p>«<strong>Post</strong>» representa la
<strong>postcondición</strong>: la propiedad que debe cumplirse justo
<em>después</em> de que la función haya terminado de
ejecutarse.</p></li>
<li><p>Lo que hay en medio es la <strong>signatura</strong>: el nombre
de la función, el nombre y tipo de sus parámetros y el tipo del valor de
retorno.</p></li>
<li><p>La especificación se lee así: «<strong><em>Si se llama a la
función respetando su signatura y cumpliendo su precondición, la llamada
termina cumpliendo su postcondición</em></strong>».</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.1.0.3">

<ul>
<li><p>En este caso, la <strong>precondición</strong> es <code
class="sourceCode python"><span class="va">True</span></code>, que
equivale a decir que cualquier condición de entrada es buena para usar
la función.</p></li>
<li><p>Dicho de otra forma: no hace falta que se dé ninguna condición
especial para usar la función. Siempre que la llamada respete la
signatura de la función, el parámetro <span class="math inline">n</span>
puede tomar cualquier valor de tipo <code
class="sourceCode python"><span class="bu">float</span></code> y no hay
ninguna restricción adicional.</p></li>
<li><p>Por otro lado, la <strong>postcondición</strong> dice que al
llamar a la función <code class="sourceCode python">cuadrado</code> con
el argumento <span class="math inline">n</span> se debe devolver <span
class="math inline">n^2</span>.</p></li>
<li><p>Tanto la precondición como la postcondición son
<strong>predicados</strong>, es decir, expresiones lógicas que se
escriben usando el lenguaje de las matemáticas y la lógica.</p></li>
<li><p>La <strong>signatura</strong> se escribe usando la sintaxis del
lenguaje de programación que se vaya a usar para implementar la función
(Python, en este caso).</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.1.0.4">

<ul>
<li><p>Recordemos la diferencia entre:</p>
<ul>
<li><p><strong>Dominio</strong> y <strong>conjunto origen</strong> de
una función.</p></li>
<li><p><strong>Rango</strong> (o <strong>codominio</strong>) y
<strong>conjunto imagen</strong> de una función.</p></li>
</ul></li>
<li><p>¿Cómo recoge la especificación esas cuatro características de la
función?</p>
<ul>
<li><p>La <strong>signatura</strong> expresa el <strong>conjunto
origen</strong> y el <strong>conjunto imagen</strong> de la
función.</p></li>
<li><p>El <strong>dominio</strong> viene determinado por los valores del
conjunto origen que cumplen la <strong>precondición</strong>.</p></li>
<li><p>El <strong>codominio</strong> viene determinado por los valores
del conjunto imagen que cumplen la
<strong>postcondición</strong>.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.1.0.5">

<ul>
<li><p>En el caso de la función <code
class="sourceCode python">cuadrado</code> tenemos que:</p>
<ul>
<li><p>El conjunto origen es <code
class="sourceCode python"><span class="bu">float</span></code>, ya que
su parámetro <span class="math inline">n</span> está declarado de tipo
<code class="sourceCode python"><span class="bu">float</span></code> en
la signatura de la función.</p>
<p>Por tanto, los datos de entrada a la función deberán pertenecer al
tipo <code
class="sourceCode python"><span class="bu">float</span></code>.</p></li>
<li><p>El dominio coincide con el conjunto origen, ya que su
precondición es <code
class="sourceCode python"><span class="va">True</span></code>. Eso
quiere decir que cualquier dato de entrada es válido siempre que
pertenezca al dominio (en este caso, el tipo <code
class="sourceCode python"><span class="bu">float</span></code>).</p></li>
<li><p>El conjunto imagen también es <code
class="sourceCode python"><span class="bu">float</span></code>, ya que
así está declarado el tipo de retorno de la función.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.1.0.6">

<ul>
<li><p>Las pre y postcondiciones no es necesario escribirlas de una
manera <strong>formal y rigurosa</strong>, usando el lenguaje de las
Matemáticas o la Lógica.</p></li>
<li><p>Si la especificación se escribe en <em>lenguaje natural</em> y se
entiende bien, completamente y sin ambigüedades, no hay
problema.</p></li>
<li><p>El motivo de usar un lenguaje formal es que, normalmente, resulta
<strong>mucho más conciso y preciso que el lenguaje
natural</strong>.</p></li>
<li><p>El lenguaje natural suele ser:</p>
<ul>
<li><p><strong>Más prolijo</strong>: necesita más palabras para decir lo
mismo que diríamos matemáticamente usando menos caracteres.</p></li>
<li><p><strong>Más ambiguo</strong>: lo que se dice en lenguaje natural
se puede interpretar de distintas formas.</p></li>
<li><p><strong>Menos completo</strong>: quedan flecos y situaciones
especiales que no se tienen en cuenta.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.1.0.7">

<ul>
<li><p>En este otro ejemplo, más completo, se especifica una función
llamada <code class="sourceCode python">cuenta</code>:</p>
<p><span class="math display">\left\{\begin{array}{ll}
  \text{\textbf{Pre}}: &amp; car \mathrel{\char`≠}
\text{\texttt{&quot;&quot;}} \land \texttt{len(}car\texttt{)} = 1
\\[0.5em]
&amp; \texttt{cuenta(\(cadena\):\,str,\;\(car\):\,str)\;-&gt;\;int}
\\[0.5em]
\text{\textbf{Post}}: &amp; \texttt{cuenta(\(cadena\),\;\(car\))} \geq
0\ \land\\[0.1em]
&amp; \texttt{cuenta(\(cadena\),\;\(car\))} =
cadena\texttt{.count(\(car\))}
\end{array}\right.</span></p></li>
<li><p>Con esta especificación, estamos diciendo que <code
class="sourceCode python">cuenta</code> es una función que recibe una
cadena y un carácter (otra cadena con un único carácter
dentro).</p></li>
<li><p>Ahora bien: esa cadena y ese carácter no pueden ser cualesquiera,
sino que tienen que cumplir la <em>precondición</em>.</p></li>
<li><p>Eso significa, entre otras cosas, que aquí <strong>el
<em>dominio</em> y el <em>conjunto origen</em> de la función no
coinciden</strong> (no todos los valores pertenecientes al conjunto
origen sirven como datos de entrada válidos para la función).</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.1.0.8">

<ul>
<li><p>En esta especificación, <code
class="sourceCode python">count</code> se usa como un <strong>método
auxiliar</strong>.</p>
<p>Las <em>operaciones auxiliares</em> se puede usar en una
especificación siempre que estén perfectamente especificadas, aunque no
estén implementadas.</p></li>
<li><p>En este caso, se usa en la <em>postcondición</em> para decir que
la función <code class="sourceCode python">cuenta</code>, la que se está
especificando, debe devolver el mismo resultado que devuelve el método
<code class="sourceCode python">count</code> (el cual ya conocemos
perfectamente y sabemos qué hace, puesto que es un método que ya existe
en Python).</p></li>
<li><p>Es decir: la especificación anterior describe con total precisión
que la función <code class="sourceCode python">cuenta</code>
<strong>cuenta el número de veces que el carácter <span
class="math inline">\underline{\textbf{\textit{car}}}</span> aparece en
la cadena <span
class="math inline">\underline{\textbf{\textit{cadena}}}</span></strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.1.0.9">

<ul>
<li><p>En realidad, las condiciones de la especificación anterior se
podrían simplificar aprovechando las propiedades de las expresiones
lógicas, quedando así:</p>
<p><span class="math display">\left\{\begin{array}{ll}
  \text{\textbf{Pre}}: &amp; \texttt{len(\(car\))} = 1 \\[0.5em]
&amp; \texttt{cuenta(\(cadena\):\,str,\;\(car\):\,str)\;-&gt;\;int}
\\[0.5em]
\text{\textbf{Post}}: &amp; \texttt{cuenta(\(cadena\),\;\(car\))} =
cadena\texttt{.count(\(car\))}
\end{array}\right.</span></p></li>
</ul>
</section>
<section id="ejercicio-1" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejercicio</h5>
<ol start="2" class="example" type="1">
<li>¿Por qué?</li>
</ol>
</section>
<section class="slide level5" data-number="4.2.1.0.10">

<ul>
<li><p>Finalmente, podríamos escribir la misma especificación en
lenguaje natural:</p>
<p><span class="math display">\left\{\begin{array}{ll}
  \text{\textbf{Pre}}: &amp; car \text{ debe ser un único carácter}
\\[0.5em]
&amp; \texttt{cuenta(\(cadena\):\,str,\;\(car\):\,str)\;-&gt;\;int}
\\[0.5em]
\text{\textbf{Post}}: &amp; \texttt{cuenta(\(cadena\),\;\(car\))} \text{
devuelve el número de veces}\\[0.1em]
&amp; \text{que aparece el carácter } car \text{ en la cadena }
cadena.\\[0.1em]
&amp; \text{Si } cadena \text{ es vacía o } car \text{ no aparece nunca
en la}\\[0.1em]
&amp; \text{cadena } cadena \text{, debe devolver } 0.
\end{array}\right.</span></p></li>
<li><p>Probablemente resulta más fácil de leer (sobre todo para los
novatos), pero también es más largo y prolijo.</p></li>
<li><p>Es como un contrato escrito por un abogado en lenguaje
jurídico.</p></li>
</ul>
<!--

- Un ejemplo mucho más avanzado para los curiosos:

  $$\begin{cases}
    \text{\textbf{Pre}}: lista \mathrel{\char`≠} \texttt{[]} \\
    suma\ (lista: \texttt{List[}T\texttt{]}) \text{ -> } T \\
    \text{\textbf{Post}}: suma(lista) = sum(lista)
  \end{cases}$$

- $sum$ es una función auxiliar.

- `List[`$T$`]` es un tipo genérico que pertenece al módulo `typing` y que se
  puede utilizar para indicar el tipo de una lista cuyos elementos son todos
  del tipo $T$.

- Con esto estamos diciendo que `suma` es una función que recibe una lista no
  vacía de elementos de un determinado tipo y que devuelve un resultado de ese
  mismo tipo.

- Para más información, consultar:

  - [https://docs.python.org/3/library/typing.html](https://docs.python.org/3/library/typing.html)

  - [https://www.python.org/dev/peps/pep-0484/](https://www.python.org/dev/peps/pep-0484/)
-->
</section>

</section>
<section id="bibliografía"
class="title-slide slide level1 unnumbered unlisted">
<h1 class="unnumbered unlisted">Bibliografía</h1>
<div id="refs" class="references csl-bib-body hanging-indent"
data-entry-spacing="0" role="list">
<div id="ref-abelson_structure_1996" class="csl-entry" role="listitem">
Abelson, Harold, Gerald Jay Sussman, and Julie Sussman. 1996.
<em>Structure and Interpretation of Computer Programs</em>. 2nd ed.
Cambridge, Mass. : New York: MIT Press ; McGraw-Hill.
</div>
</div>
</section>
    </div>
  </div>

  <script src="./reveal.js/dist/reveal.js"></script>

  <!-- reveal.js plugins -->
  <script src="./reveal.js/plugin/notes/notes.js"></script>
  <script src="./reveal.js/plugin/search/search.js"></script>
  <script src="./reveal.js/plugin/zoom/zoom.js"></script>
  <script src="./reveal.js/plugin/reveal.js-menu/menu.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
        // Display controls in the bottom right corner
        controls: true,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: true,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'bottom-right',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: true,

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: false,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'default',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: true,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'slide',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'fade',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1280,

        height: 1080,
        // The display mode that will be used to show slides
        display: 'block',

        menu: {
          hideMissingTitles: true,
        },

        dependencies: [
          { src: './reveal.js/plugin/reveal.js-quiz/quiz/js/quiz.js', async: true, callback: function() { prepareQuizzes({preventUnanswered: true, checkAnswerText: 'Comprueba la respuesta', nextQuestionText: 'Siguiente &raquo;', backButtonText: '&laquo; Anterior', tryAgainText: 'Prueba de nuevo', preventUnansweredText: 'Selecciona una respuesta', questionCountText: 'Pregunta %current de %total', skipStartButton: true}); } }
        ],

        // reveal.js plugins
        plugins: [
          RevealMenu,
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    <script type="text/javascript">
       var title = document.getElementsByClassName('title')[0];
       title = title != null ? title.innerHTML : '';
       var author = document.getElementsByClassName('author')[0];
       author = author != null ? author.innerHTML : '';
       var date = document.getElementsByClassName('date')[0];
       date = date != null ? date.innerHTML : '';
       document.getElementById('header-left').innerHTML = '<a href="#/title-slide">' + title + '</a>';
       document.getElementById('footer-left').innerHTML = '<a href="https://pro.iesdonana.org">&copy; ' + author + ' (' + date + ')</a>';

       function updateHeader(nd) {
           var hr = document.getElementById('header-right');
           while (hr.children.length > 0) {
               hr.removeChild(hr.lastChild);
           }
           buscar(nd, 3, hr);
           buscar(nd, 2, hr);
           buscar(nd, 1, hr);
           hr.style.fontSize = Math.round(50 * Reveal.getScale()) + '%';
           hr.style.fontSize = Math.max(Number.parseInt(getComputedStyle(hr).fontSize), 12) + 'px';
           var hl = document.getElementById('header-left');
           hl.style.fontSize = hr.style.fontSize;
       }

       function buscar(nd, level, hr) {
           if (!nd.classList.contains('level' + (level - 1))) {
               for (var n = nd; n != null; n = n.previousSibling) {
                   if (n.nodeType == Node.TEXT_NODE) {
                       continue;
                   }
                   var cl = n.classList;
                   if (cl.contains('level' + level)) {
                       var h = n.querySelector('h' + level);
                   } else if (cl.contains('level' + (level - 1))) {
                       break;
                   } else {
                       continue;
                   }
                   if (h == null || Reveal.getCurrentSlide().id == 'title-slide') {
                       hr.innerHTML = '';
                   } else {
                       var el = document.createElement('a');
                       var href = '#/' + n.id;
                       el.href = href;
                       el.innerHTML = h.innerHTML;
                       var a = el.querySelector('a');
                       if (a !== null) {
                           a.href = href;
                       }
                       if (hr.innerHTML != '') {
                           hr.innerHTML = ' &mdash; ' + hr.innerHTML;
                       }
                       hr.insertBefore(el, hr.firstChild);
                   }
                   break;
               }
           }
       }

       // On Reveal.js ready event, copy header/footer <div>
       // into each `.slide-background` <div>
       Reveal.on('ready', event => {
           var header = document.getElementById('header');
           document.querySelector('.reveal').appendChild(header);
           updateHeader(Reveal.getCurrentSlide());
       });

       Reveal.on('slidechanged', event => {
           // event.previousSlide, event.currentSlide, event.indexh, event.indexv
           updateHeader(event.currentSlide);
       });
    </script>
    </body>
</html>
