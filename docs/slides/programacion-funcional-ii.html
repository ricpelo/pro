<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Ricardo Pérez López">
  <title>Programación funcional (II)</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="./reveal.js/dist/reset.css">
  <link rel="stylesheet" href="./reveal.js/dist/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #cb4b16; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #d33682; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #dc322f; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #93a1a1; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #268bd2; } /* DataType */
    code span.dv { color: #d33682; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #d33682; } /* Float */
    code span.fu { color: #268bd2; } /* Function */
    code span.im { font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #268bd2; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #a57800; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #2aa198; } /* SpecialString */
    code span.st { color: #2aa198; } /* String */
    code span.va { color: #6c71c4; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
    }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
  <link rel="stylesheet" href="./reveal.js/dist/theme/solarized.css" id="theme">
  <link rel="stylesheet" href="custom.css"/>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
   var mathElements = document.getElementsByClassName("math");
   var macros = [];
   for (var i = 0; i < mathElements.length; i++) {
    var texText = mathElements[i].firstChild;
    if (mathElements[i].tagName == "SPAN") {
     katex.render(texText.data, mathElements[i], {
      displayMode: mathElements[i].classList.contains('display'),
      throwOnError: false,
      macros: macros,
      fleqn: false
     });
  }}});
  </script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" />
  <link href="https://fonts.googleapis.com/css?family=Lato&display=swap" rel="stylesheet">
  <style type="text/css">
      #header-left {
          position: absolute;
          font-size: 25%;
          top: 0%;
          left: 0%;
          margin-left: 10px;
          margin-top: 10px;
      }
      #header-right {
          position: absolute;
          font-size: 25%;
          top: 0%;
          right: 0%;
          margin-right: 10px;
          margin-top: 10px;
      }
      #footer-left {
          position: absolute;
          font-size: 25%;
          bottom: 0%;
          left: 0%;
          margin-left: 10px;
          margin-bottom: 10px;
      }
  </style>
</head>
<body>
<div id="hidden" style="display:none;">
    <div id="header">
        <div id="header-left"></div>
        <div id="header-right"></div>
        <div id="footer-left"></div>
    </div>
</div>
<script type="text/javascript">
    document.addEventListener("DOMContentLoaded", function(event) {
        var title = document.getElementsByClassName('title')[0];
        title = title != null ? title.innerHTML : '';
        var author = document.getElementsByClassName('author')[0];
        author = author != null ? author.innerHTML : '';
        var date = document.getElementsByClassName('date')[0];
        date = date != null ? date.innerHTML : '';
        document.getElementById('header-left').innerHTML = '<a href="#/title-slide">' + title + '</a>';
        document.getElementById('footer-left').innerHTML = '<a href="https://pro.iesdonana.org">&copy; ' + author + ' (' + date + ')</a>';

        function updateHeader(nd) {
            var hr = document.getElementById('header-right');
            while (hr.children.length > 0) {
                hr.removeChild(hr.lastChild);
            }
            buscar(nd, 3, hr);
            buscar(nd, 2, hr);
            buscar(nd, 1, hr);
            hr.style.fontSize = Math.round(50 * Reveal.getScale()) + '%';
            hr.style.fontSize = Math.max(Number.parseInt(getComputedStyle(hr).fontSize), 12) + 'px';
            var hl = document.getElementById('header-left');
            hl.style.fontSize = hr.style.fontSize;
        }

        function buscar(nd, level, hr) {
            if (!nd.classList.contains('level' + (level - 1))) {
                for (var n = nd; n != null; n = n.previousSibling) {
                    if (n.nodeType == Node.TEXT_NODE) {
                        continue;
                    }
                    var cl = n.classList;
                    if (cl.contains('level' + level)) {
                        var h = n.querySelector('h' + level);
                    } else if (cl.contains('level' + (level - 1))) {
                        break;
                    } else {
                        continue;
                    }
                    if (h == null || Reveal.getCurrentSlide().id == 'title-slide') {
                        hr.innerHTML = '';
                    } else {
                        var el = document.createElement('a');
                        var href = '#/' + n.id;
                        el.href = href;
                        el.innerHTML = h.innerHTML;
                        var a = el.querySelector('a');
                        if (a !== null) {
                            a.href = href;
                        }
                        if (hr.innerHTML != '') {
                            hr.innerHTML = ' &mdash; ' + hr.innerHTML;
                        }
                        hr.insertBefore(el, hr.firstChild);
                    }
                    break;
                }
            }
        }

        // On Reveal.js ready event, copy header/footer <div>
        // into each `.slide-background` <div>
        Reveal.addEventListener('ready', function(event) {
            var header = document.getElementById('header');
            document.querySelector('.reveal').appendChild(header);
            updateHeader(Reveal.getCurrentSlide());
        });

        Reveal.addEventListener('slidechanged', function(event) {
            // event.previousSlide, event.currentSlide, event.indexh, event.indexv
            updateHeader(event.currentSlide);
        });
    });
</script>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">Programación funcional (II)</h1>
  <p class="author">Ricardo Pérez López</p>
  <p class="date">IES Doñana, curso 2020/2021</p>
</section>
<section id="TOC">
<ul>
<li><a href="#/abstracciones-lambda"><span class="toc-section-number">1</span> Abstracciones lambda</a></li>
<li><a href="#/ámbitos-léxicos"><span class="toc-section-number">2</span> Ámbitos léxicos</a></li>
<li><a href="#/evaluación"><span class="toc-section-number">3</span> Evaluación</a></li>
<li><a href="#/abstracciones-funcionales"><span class="toc-section-number">4</span> Abstracciones funcionales</a></li>
<li><a href="#/computabilidad"><span class="toc-section-number">5</span> Computabilidad</a></li>
<li><a href="#/tipos-de-datos-recursivos"><span class="toc-section-number">6</span> Tipos de datos recursivos</a></li>
<li><a href="#/funciones-de-orden-superior"><span class="toc-section-number">7</span> Funciones de orden superior</a></li>
</ul>
</section>

<section>
<section id="abstracciones-lambda" class="title-slide slide level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Abstracciones lambda</h1>

</section>
<section id="expresiones-lambda" class="title-slide slide level2" data-number="1.1">
<h2 data-number="1.1"><span class="header-section-number">1.1</span> Expresiones lambda</h2>
<ul>
<li><p>Las <strong>expresiones lambda</strong> (también llamadas <strong>abstracciones lambda</strong> o <strong>funciones anónimas</strong> en algunos lenguajes) son expresiones que capturan la idea abstracta de «<strong>función</strong>».</p></li>
<li><p>Son la forma más simple y primitiva de describir funciones en un lenguaje funcional.</p></li>
<li><p>Su sintaxis (simplificada) es:</p>
<div class="line-block"><span style="color:teal">⟨<em>expresión_lambda</em>⟩</span> ::= <strong><code>lambda</code></strong> [<span style="color:teal">⟨<em>lista_parámetros</em>⟩</span>]<strong><code>:</code></strong> <span style="color:teal">⟨<em>expresión</em>⟩</span><br />
<span style="color:teal">⟨<em>lista_parámetros</em>⟩</span> := <strong><code>identificador</code></strong> (<strong><code>,</code></strong> <strong><code>identificador</code></strong>)*</div></li>
<li><p>Por ejemplo:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span></code></pre></div></li>
</ul>
</section>

<section id="parámetros-y-cuerpos" class="title-slide slide level2" data-number="1.2">
<h2 data-number="1.2"><span class="header-section-number">1.2</span> Parámetros y cuerpos</h2>
<ul>
<li><p>Los identificadores que aparecen entre la palabra clave <code>lambda</code> y el carácter de dos puntos (<code>:</code>) son los <strong>parámetros</strong> de la expresión lambda.</p></li>
<li><p>La expresión que aparece tras los dos puntos (<code>:</code>) es el <strong>cuerpo</strong> de la expresión lambda.</p></li>
<li><p>En el ejemplo anterior:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span></code></pre></div>
<ul>
<li><p>Los parámetros son <code>x</code> e <code>y</code>.</p></li>
<li><p>El cuerpo es <code>x + y</code>.</p></li>
<li><p>Esta expresión lambda captura la idea general de sumar dos valores (que en principio pueden ser de cualquier tipo, siempre y cuando admitan el operador <code>+</code>).</p></li>
</ul></li>
</ul>
</section>

<section id="aplicación-funcional" class="title-slide slide level2" data-number="1.3">
<h2 data-number="1.3"><span class="header-section-number">1.3</span> Aplicación funcional</h2>
<ul>
<li><p>De la misma manera que decíamos que podemos aplicar una función a unos argumentos, también podemos aplicar una expresión lambda a unos argumentos.</p></li>
<li><p>Por ejemplo, la aplicación de la función <code>max</code> sobre los argumentos <code>3</code> y <code>5</code> es una expresión que se escribe como <code>max(3, 5)</code> que denota el valor <strong>cinco</strong> (o sea, que la llamada a la función devuelve <code>5</code>).</p></li>
<li><p>Igualmente, la aplicación de una expresión lambda como</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span></code></pre></div>
<p>sobre los argumentos <code>4</code> y <code>3</code> se representa así:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>)</span></code></pre></div></li>
</ul>
</section>
<section id="evaluación-de-una-aplicación-funcional" class="title-slide slide level3" data-number="1.3.1">
<h3 data-number="1.3.1"><span class="header-section-number">1.3.1</span> Evaluación de una aplicación funcional</h3>
<ul>
<li><p>En nuestro modelo de sustitución, la <strong>evaluación de la aplicación de una expresión lambda</strong> consiste en <strong>sustituir</strong>, en el cuerpo de la expresión lambda, <strong>cada parámetro por su argumento correspondiente</strong> (por orden) y devolver la expresión resultante <em>parentizada</em> (entre paréntesis).</p></li>
<li><p>A esta operación se la denomina <strong>aplicación funcional</strong> o <strong>β-reducción</strong>.</p></li>
<li><p>Siguiendo con el ejemplo anterior:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>)</span></code></pre></div>
<p>sustituimos en el cuerpo de la expresión lambda los parámetros <code>x</code> e <code>y</code> por los argumentos <code>4</code> y <code>3</code>, respectivamente, y parentizamos la expresión resultante, lo que da:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>(<span class="dv">4</span> <span class="op">+</span> <span class="dv">3</span>)</span></code></pre></div>
<p>que simplificando (según las reglas del operador <code>+</code>) da <code>7</code>.</p></li>
</ul>
</section>

<section id="llamadas-a-funciones" class="title-slide slide level3" data-number="1.3.2">
<h3 data-number="1.3.2"><span class="header-section-number">1.3.2</span> Llamadas a funciones</h3>
<ul>
<li><p>Si hacemos la siguiente definición:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>suma <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span></code></pre></div>
<p>a partir de ese momento podemos usar <code>suma</code> en lugar de su valor (la expresión lambda), por lo que podemos hacer:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>suma(<span class="dv">4</span>, <span class="dv">3</span>)</span></code></pre></div>
<p>en lugar de</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>)</span></code></pre></div></li>
<li><p>Cuando aplicamos a sus argumentos una función así definida también podemos decir que estamos <strong>invocando</strong> o <strong>llamando</strong> a la función. Por ejemplo, en <code>suma(4, 3)</code> estamos <em>llamando</em> a la función <code>suma</code>, o hay una <em>llamada</em> a la función <code>suma</code>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.3.2.0.1">

<ul>
<li><p>La evaluación de la llamada a <code>suma(4, 3)</code> implicaría realizar los siguientes tres pasos y en este orden:</p>
<ol type="1">
<li><p>Sustituir el nombre de la función <code>suma</code> por su definición.</p></li>
<li><p>Evaluar sus argumentos.</p></li>
<li><p>Aplicar la expresión lambda a sus argumentos.</p></li>
</ol></li>
<li><p>Esto implica la siguiente secuencia de reescrituras:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>suma(<span class="dv">4</span>, <span class="dv">3</span>)                    <span class="co"># evalúa suma y devuelve su definición</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>)  <span class="co"># evalúa 4 y devuelve 4</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>)  <span class="co"># evalúa 3 y devuelve 3</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>)  <span class="co"># aplica la expresión lambda sus argumentos</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">4</span> <span class="op">+</span> <span class="dv">3</span>)                     <span class="co"># evalúa 4 + 3 y devuelve 7</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">7</span></span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="1.3.2.0.2">

<ul>
<li><p>Como una expresión lambda es una función, aplicar una expresión lambda a unos argumentos es como llamar a una función pasándole dichos argumentos.</p></li>
<li><p>Por tanto, ampliamos ahora nuestra gramática de las expresiones en Python incorporando las expresiones lambda como un tipo de función:</p>
<div class="line-block"><span style="color:teal">⟨<em>llamada_función</em>⟩</span> ::= <span style="color:teal">⟨<em>función</em>⟩</span><strong><code>(</code></strong>[<span style="color:teal">⟨<em>lista_argumentos</em>⟩</span>]<strong><code>)</code></strong><br />
<span style="color:teal">⟨<em>función</em>⟩</span> ::= <strong><code>identificador</code></strong><br />
                   | <strong><code>(</code></strong><span style="color:teal">⟨<em>expresión_lambda</em>⟩</span><strong><code>)</code></strong><br />
<span style="color:teal">⟨<em>expresión_lambda</em>⟩</span> ::= <strong><code>lambda</code></strong> [<span style="color:teal">⟨<em>lista_parámetros</em>⟩</span>]<strong><code>:</code></strong> <span style="color:teal">⟨<em>expresión</em>⟩</span><br />
<span style="color:teal">⟨<em>lista_parámetros</em>⟩</span> ::= <strong><code>identificador</code></strong>(<strong><code>,</code></strong> <strong><code>identificador</code></strong>)*<br />
<span style="color:teal">⟨<em>lista_argumentos</em>⟩</span> ::= <span style="color:teal">⟨<em>expresión</em>⟩</span>(<strong><code>,</code></strong> <span style="color:teal">⟨<em>expresión</em>⟩</span>)*</div></li>
</ul>
<!--

- Lo mismo podemos hacer si definimos previamente la expresión lambda
  ligándola a un identificador:

  ```python
  suma = lambda x, y: x + y
  ```

- Así, la aplicación de la expresión lambda resulta más fácil y clara de
  escribir:

  ```python
  suma(4, 3)
  ```

- En ambos casos, el resultado es el mismo (`7`).

::: caja
**Recuerda:**

En **Python**, las subexpresiones se evalúan **de izquierda a derecha**.
:::

-->
</section>
<section id="ejemplo" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejemplo</h5>
<ul>
<li><p>Dado el siguiente código:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>suma <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span></code></pre></div>
<p>¿Cuánto vale la expresión siguiente?</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>suma(<span class="dv">4</span>, <span class="dv">3</span>) <span class="op">*</span> suma(<span class="dv">2</span>, <span class="dv">7</span>)</span></code></pre></div>
<p>Según el modelo de sustitución, reescribimos:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>suma(<span class="dv">4</span>, <span class="dv">3</span>) <span class="op">*</span> suma(<span class="dv">2</span>, <span class="dv">7</span>)                    <span class="co"># definición de suma</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>) <span class="op">*</span> suma(<span class="dv">2</span>, <span class="dv">7</span>)  <span class="co"># evaluación de 4</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>) <span class="op">*</span> suma(<span class="dv">2</span>, <span class="dv">7</span>)  <span class="co"># evaluación de 3</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>) <span class="op">*</span> suma(<span class="dv">2</span>, <span class="dv">7</span>)  <span class="co"># aplicación a 4 y 3</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">4</span> <span class="op">+</span> <span class="dv">3</span>) <span class="op">*</span> suma(<span class="dv">2</span>, <span class="dv">7</span>)                     <span class="co"># evalúa 4 + 3</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> suma(<span class="dv">2</span>, <span class="dv">7</span>)                           <span class="co"># definición de suma</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">2</span>, <span class="dv">7</span>)           <span class="co"># evaluación de 2</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">2</span>, <span class="dv">7</span>)           <span class="co"># evaluación de 7</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">2</span>, <span class="dv">7</span>)           <span class="co"># aplicación a 2 y 7</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> (<span class="dv">2</span> <span class="op">+</span> <span class="dv">7</span>)                              <span class="co"># evaluación de 2 + 7</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> <span class="dv">9</span>                                    <span class="co"># evaluación de 7 * 9</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">63</span></span></code></pre></div></li>
</ul>
</section>


<section id="variables-ligadas-y-libres" class="title-slide slide level2" data-number="1.4">
<h2 data-number="1.4"><span class="header-section-number">1.4</span> Variables ligadas y libres</h2>
<ul>
<li><p>Si un <em>identificador</em> que aparece en el <em>cuerpo</em> de una expresión lambda, también aparece en la <em>lista de parámetros</em> de esa expresión lambda, a ese identificador le llamamos <strong>variable ligada</strong> de la expresión lambda.</p></li>
<li><p>En caso contrario, le llamamos <strong>variable libre</strong> de la expresión lambda.</p></li>
<li><p>En el ejemplo anterior:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span></code></pre></div>
<p>los dos identificadores que aparecen en el cuerpo (<code>x</code> e <code>y</code>) son variables ligadas, ya que ambos aparecen también en la lista de parámetros de la expresión lambda.</p></li>
<li><p>En cambio, en la expresión lambda:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lambda</span> x, y: x <span class="op">+</span> y <span class="op">+</span> z</span></code></pre></div>
<p><code>x</code> e <code>y</code> son variables ligadas mientras que <code>z</code> es una variable libre.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.4.0.0.1">

<ul>
<li><p>En realidad, <strong>una <em>variable ligada</em> y un <em>parámetro</em> son la misma cosa</strong>.</p></li>
<li><p>Tan sólo cambia su denominación dependiendo del lugar donde aparece su identificador en la expresión lambda:</p>
<ul>
<li><p>Si aparece <strong>antes</strong> del «<code>:</code>», le llamamos «<em>parámetro</em>».</p></li>
<li><p>Si aparece <strong>después</strong> del «<code>:</code>», le llamamos «<em>variable ligada</em>».</p></li>
</ul></li>
<li><p>Por ejemplo: en la siguiente expresión lambda:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>       ┬     ┬</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>       │     └────── variable ligada</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>       └── parámetro</span></code></pre></div>
<p>el identificador <code>x</code> aparece dos veces, pero en los dos casos representa la misma cosa. Tan sólo se llama de distinta forma («<em>parámetro</em>» o «<em>variable ligada</em>») dependiendo de dónde aparece.</p></li>
</ul>
</section>
</section>
<section>
<section id="ámbitos-léxicos" class="title-slide slide level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Ámbitos léxicos</h1>

</section>
<section id="ambitos" class="title-slide slide level2" data-number="2.1">
<h2 data-number="2.1"><span class="header-section-number">2.1</span> Ambitos</h2>
<ul>
<li><p>Existen ciertos bloques sintácticos que, cuando se ejecutan, provocan la creación de nuevos marcos.</p></li>
<li><p>Cuando eso ocurre, decimos que ese bloque sintáctico define un <strong>ámbito</strong>, y ese ámbito viene definido por la porción del código fuente que ocupa ese bloque sintáctico dentro del programa, de forma que:</p>
<ul>
<li><p>Cuando la ejecución del programa <strong>entra</strong> en el ámbito, se <strong>crea</strong> un nuevo marco.</p></li>
<li><p>Cuando la ejecución se <strong>sale</strong> del ámbito, se <strong>destruye</strong> su marco.</p></li>
</ul></li>
<li><p>Cada marco va asociado con un ámbito, y cada ámbito tiene su marco.</p></li>
<li><p>Los ámbitos <strong>se anidan recursivamente</strong>, o sea, que están contenidos unos dentro de otros, así que una instrucción puede estar en varios ámbitos al mismo tiempo (anidados unos dentro de otros).</p></li>
<li><p>En un momento dado, el <strong>ámbito actual</strong> es el ámbito más interno en el que se encuentra la instrucción que se está ejecutando actualmente.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.1.0.0.1">

<ul>
<li><p>El concepto de <em>ámbito</em> es un concepto nada trivial y, a medida que vayamos incorporando nuevos elementos al lenguaje, tendremos que ir adaptándolo para tener en cuenta más condicionantes.</p></li>
<li><p>Por ahora sólo tenemos un ámbito llamado <strong>ámbito global</strong>:</p>
<ul>
<li><p>Si se está ejecutando un <em>script</em> en el intérprete por lotes (con <code>python script.py</code>), el <em>ámbito global</em> abarca todo el <em>script</em>, desde la primera instrucción hasta la última.</p></li>
<li><p>Si estamos en el intérprete interactivo (con <code>python</code> o <code>ipython3</code>), el <em>ámbito global</em> abarca toda nuestra sesión con el intérprete, hasta que finalicemos la misma.</p></li>
</ul></li>
<li><p>En el momento en que se empieza a ejecutar un <em>script</em> o se arranca una nueva sesión con el intérprete interactivo, se entra en el <em>ámbito global</em>, lo que provoca la creación de un nuevo marco llamado <strong>marco global</strong>.</p></li>
<li><p>Del ámbito global sólo se sale cuando se finaliza la ejecución del <em>script</em> o se cierra el intérprete interactivo.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.1.0.0.2">

<div class="caja">
<p><strong>Las ligaduras que se crean dentro de un ámbito se almacenan en el marco asociado a ese ámbito.</strong></p>
</div>
<ul>
<li><p>Por ejemplo, en el siguiente <em>script</em> se realizan cuatro definiciones. Todas ellas se ejecutan en el ámbito global, que es el único ámbito que existe en el <em>script</em>:</p>
<div class="centered">
<p><img data-src="images/ambito-global.png" class="plain" style="width:40.0%" /></p>
</div></li>
<li><p>Ninguna de esas instrucciones crea un nuevo ámbito, por lo que todas se ejecutan en el ámbito actual (el ámbito global) y todas las ligaduras que se crean se almacenan en el marco global.</p></li>
</ul>
</section>

<section id="ámbito-de-una-ligadura-y-de-creación-de-una-ligadura" class="title-slide slide level2" data-number="2.2">
<h2 data-number="2.2"><span class="header-section-number">2.2</span> Ámbito de una ligadura y de creación de una ligadura</h2>
<ul>
<li><p>El <strong>ámbito de una ligadura</strong> es la porción del código fuente en la que existe dicha ligadura.</p></li>
<li><p>El <strong>ámbito de creación de una ligadura</strong> es el ámbito más interno donde se crea una ligadura, y determina el <strong>marco</strong> donde se almacenará la ligadura.</p></li>
<li><p>El ámbito de una ligadura no tiene por qué coincidir exactamente con su ámbito de creación.</p></li>
<li><p>Esto es así porque una ligadura empieza a existir en el momento en el que se ejecuta la instrucción que la crea, y no antes.</p></li>
<li><p>Por tanto, si en un momento dado se está ejecutando una instrucción dentro de un ámbito, las ligaduras que existirán dentro de ese ámbito en ese momento serán sólo las que se hayan creado en ese ámbito <strong>hasta ese momento</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.2.0.0.1">

<ul>
<li><p>En consecuencia, el ámbito de una ligadura:</p>
<ul>
<li><p>Empieza en el punto donde se crea la ligadura.</p></li>
<li><p>Termina donde lo hace el ámbito de creación de la ligadura.</p></li>
</ul></li>
<li><p>En el siguiente ejemplo vemos los ámbitos de cada ligadura. Todas esas ligaduras se definen en el ámbito global, por lo que el <em>ámbito de creación</em> de todas ellas es el <strong>ámbito global</strong>.</p></li>
</ul>
<div class="centered">
<p><img data-src="images/ambitos-ligaduras.png" class="plain" style="width:50.0%" /></p>
</div>
<ul>
<li>Es importante no confundir «<strong>ámbito</strong>», «<strong>ámbito de creación de una ligadura</strong>» y «<strong>ámbito de una ligadura</strong>».</li>
</ul>
</section>
<section class="slide level5" data-number="2.2.0.0.2">

<div class="caja">
<p><strong>Ámbito:</strong></p>
<p>Porción de código de un programa que crea un marco al entrar y lo destruye al salir. Su marco almacena las ligaduras que se crean dentro de ese ámbito.</p>
</div>
<div class="caja">
<p><strong>Ámbito de creación de una ligadura:</strong></p>
<p>Ambito más interno en el que se crea una ligadura y que determina el marco donde se almacenará la ligadura.</p>
</div>
<div class="caja">
<p><strong>Ámbito de una ligadura:</strong></p>
<p>Porción de código en el que la ligadura existe, que va desde su creación hasta el final del ámbito más interno que lo contiene (su <em>ámbito de creación</em>). No es un ámbito como tal y, por tanto, no crea marcos.</p>
</div>
</section>
<section class="slide level5" data-number="2.2.0.0.3">

<ul>
<li><p>La creación de una ligadura (por ejemplo, con una sentencia de definición) no define un nuevo ámbito y, por tanto, no crea un nuevo marco.</p></li>
<li><p>Por eso, las ligaduras se almacenan en el marco del ámbito donde se crean (es el <strong>ámbito de creación de la ligadura</strong>).</p></li>
<li><p>Hasta ahora, todas las ligaduras las hemos definido en el ámbito global, por lo que se almacenan en el marco global.</p></li>
<li><p>Por eso también decimos que esas ligaduras tienen ámbito global, o que pertenecen al ámbito global, o que están definidas en el ámbito global, o que son <strong>globales</strong>.</p></li>
<li><p>Ampliaremos ahora el concepto de <em>ámbito</em> para incluir los aspectos nuevos que incorporan las expresiones lambda.</p></li>
</ul>
</section>

<section id="ámbito-de-un-identificador" class="title-slide slide level2" data-number="2.3">
<h2 data-number="2.3"><span class="header-section-number">2.3</span> Ámbito de un identificador</h2>
<ul>
<li><p>A veces, por economía del lenguaje, se suele hablar del «<strong><em>ámbito de un identificador</em></strong>», en lugar de hablar del «<em>ámbito de creación de la ligadura que liga ese identificador con un valor</em>».</p></li>
<li><p>Por ejemplo, en el siguiente <em>script</em>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="dv">25</span></span></code></pre></div>
<p>tenemos que:</p>
<ul>
<li><p>En el ámbito global, se crea una ligadura que liga al identificador <code>x</code> con el valor <code>25</code>.</p></li>
<li><p>Por tanto, se dice que el <em>ámbito de creación de esa ligadura</em> es el ámbito global.</p></li>
<li><p>Pero también se suele decir que «<em>el identificador <code>x</code> es global</em>» (o, simplemente, que «<em><code>x</code> es global</em>»), <strong>asociando al ámbito</strong> no la ligadura, sino <strong>el identificador en sí</strong>.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="2.3.0.0.1">

<ul>
<li><p>Pero hay que tener cuidado, ya que ese mismo identificador puede ligarse en ámbitos diferentes.</p></li>
<li><p>Por tanto, no tendría sentido hablar del ámbito que tiene ese identificador (ya que podría tener varios) sino, más bien, <strong>del ámbito que tiene <em>una aparición concreta</em> de ese identificador</strong>.</p></li>
<li><p>Por eso, sólo deberíamos hablar del ámbito de un identificador cuando no haya ninguna ambigüedad respecto a qué aparición concreta nos estamos refiriendo.</p></li>
<li><p>Por ejemplo, en el siguiente <em>script</em>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode numberSource python number-lines"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1"></a>x <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb18-2"><a href="#cb18-2"></a>suma <span class="op">=</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">2</span>, <span class="dv">3</span>)</span></code></pre></div>
<p>el identificador <code>x</code> que aparece en la línea 1 y el que aparece en la línea 2 pertenecen a ámbitos distintos (como veremos en breve).</p></li>
</ul>
</section>

<section id="ámbito-de-un-parámetro" class="title-slide slide level2" data-number="2.4">
<h2 data-number="2.4"><span class="header-section-number">2.4</span> Ámbito de un parámetro</h2>
<ul>
<li><p><strong>El cuerpo de la expresión lambda define un ámbito.</strong></p></li>
<li><p>Por tanto, cuando se va a evaluar una aplicación funcional, se entra en dicho ámbito y eso crea un marco.</p></li>
<li><p>Cuando se aplica una expresión lambda a unos argumentos, <strong>cada parámetro de la expresión lambda se liga a uno de esos argumentos</strong> en el orden en que aparecen en la aplicación funcional (primer parámetro con primer argumento, segundo con segundo, etcétera).</p></li>
<li><p>Esas ligaduras se crean justo al entrar en el ámbito que define el cuerpo de la expresión lambda.</p></li>
<li><p>Por tanto, <strong>se almacenan en el marco de la expresión lambda</strong> nada más entrar en el cuerpo de la expresión lambda.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.4.0.0.1">

<ul>
<li><p>En consecuencia, podemos decir que:</p>
<ul>
<li><p>El <strong>ámbito de creación de la ligadura</strong> entre un parámetro y su argumento es el <strong>cuerpo</strong> de la expresión lambda.</p></li>
<li><p>El <strong>ámbito de esa ligadura</strong> coincide con su ámbito de creación.</p></li>
</ul></li>
<li><p>Esto se resume diciendo que el <strong>ámbito de un parámetro</strong> es el <strong>cuerpo</strong> de su expresión lambda.</p></li>
<li><p>También se dice que el parámetro tiene un <strong>ámbito local</strong> al cuerpo de la expresión lambda o que es <strong>local</strong> a dicha expresión lambda.</p></li>
<li><p>Como el ámbito de una ligadura es la porción del código en el que dicha ligadura tiene validez, eso significa que <strong>sólo podemos acceder al valor de un parámetro dentro del cuerpo de su expresión lambda</strong>.</p></li>
</ul>
<div class="caja">
<p><strong>En resumen:</strong></p>
<p>El <strong>ámbito de un parámetro</strong> es el ámbito de la ligadura que se establece entre éste y su argumento correspondiente, y coincide con el <strong>cuerpo</strong> de la expresión lambda donde aparece.</p>
</div>
</section>

<section id="ámbito-de-una-variable-ligada" class="title-slide slide level2" data-number="2.5">
<h2 data-number="2.5"><span class="header-section-number">2.5</span> Ámbito de una variable ligada</h2>
<ul>
<li><p>Hemos visto que a los <strong>parámetros</strong> de una expresión lambda se les llama <strong>variables ligadas</strong> cuando aparecen dentro del cuerpo de dicha expresión lambda.</p></li>
<li><p>Por tanto, todo lo que se dijo sobre el ámbito de un parámetro se aplica exactamente igual al ámbito de una variable ligada.</p></li>
<li><p>Recordemos que el ámbito de un parámetro es el cuerpo de su expresión lambda, que es la porción de código donde podemos acceder al valor del argumento con el que está ligado.</p></li>
<li><p>Por tanto, <strong>el <em>ámbito</em> de una variable ligada también es el <em>cuerpo</em> de la expresión lambda</strong> donde aparece, y es el único lugar dentro del cual podremos acceder al valor de la variable ligada (que también será el valor del argumento con el que está ligada).</p></li>
<li><p>En consecuencia, también se dice que la variable ligada tiene un <strong>ámbito local</strong> al cuerpo de la expresión lambda o que es <strong>local</strong> a dicha expresión lambda.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.5.0.0.1">

<ul>
<li><p>Por contraste, las variables, identificadores y ligaduras que no tienen ámbito local se dice que tienen un <strong>ámbito <em>no local</em></strong> o, a veces, un <strong>ámbito <em>más global</em></strong>.</p>
<p>Si, además, ese ámbito resulta ser el <strong>ámbito global</strong>, decimos directamente que esa variable, identificador o ligadura es <strong>global</strong>.</p></li>
<li><p>Por ejemplo, las <strong>variables libres</strong> que aparecen en una expresión lambda no son locales a dicha expresión (ya que no representan parámetros de la expresión) y, por tanto, tienen un ámbito más global que el cuerpo de dicha expresión lambda.</p></li>
</ul>
<div class="caja">
<p><strong>En resumen:</strong></p>
<p>El <strong>ámbito de una variable ligada</strong> es el ámbito de la ligadura que se establece entre ésta y su argumento correspondiente, y coincide con el <strong>cuerpo</strong> de la expresión lambda donde aparece.</p>
</div>
</section>
<section id="ejemplo-1" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejemplo</h5>
<ul>
<li><p>En el siguiente <em>script</em>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode numberSource python number-lines"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1"></a><span class="co"># Aquí empieza el script (no hay más definiciones antes de esta línea):</span></span>
<span id="cb19-2"><a href="#cb19-2"></a>producto <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> x</span>
<span id="cb19-3"><a href="#cb19-3"></a>y <span class="op">=</span> producto(<span class="dv">3</span>)</span>
<span id="cb19-4"><a href="#cb19-4"></a>z <span class="op">=</span> x <span class="op">+</span> <span class="dv">1</span>       <span class="co"># da error</span></span></code></pre></div></li>
<li><p>Hay dos ámbitos: (1) el ámbito global y (2) el ámbito local definido el cuerpo de la expresión lambda (la expresión <code>x * x</code>).</p></li>
<li><p>La expresión lambda de la línea 2 tiene un parámetro (<code>x</code>) que aparece como la variable ligada <code>x</code> en el cuerpo de la expresión lambda.</p></li>
<li><p>El ámbito de la variable ligada <code>x</code> es el <strong>cuerpo</strong> de la expresión lambda.</p></li>
<li><p>Por tanto, fuera del cuerpo de la expresión lambda, no es posible acceder al valor de la variable ligada <code>x</code>, al encontrarnos <strong>fuera de su ámbito</strong> (la <code>x</code> <strong>sólo está ligada en el cuerpo</strong> de la expresión lambda).</p></li>
<li><p>Por eso, la línea 4 dará un error al intentar acceder al valor del identificador <code>x</code>, que no está ligado en el ámbito actual (el global).</p></li>
</ul>
</section>

<section id="entorno-environment" class="title-slide slide level2" data-number="2.6">
<h2 data-number="2.6"><span class="header-section-number">2.6</span> Entorno (<em>environment</em> )</h2>
<ul>
<li><p>El <strong>entorno</strong> es una extensión del concepto de <em>marco</em>.</p></li>
<li><p>Durante la ejecución del programa, se van creando y destruyendo marcos a medida que la ejecución va entrando y saliendo de ámbitos.</p></li>
<li><p>Como los ámbitos están anidados unos dentro de otros, una instrucción puede estar en varios ámbitos al mismo tiempo.</p></li>
<li><p>Eso hace que, en un momento dado, pueda haber varios marcos activos en memoria al mismo tiempo (uno por cada ámbito en el que se encuentre la instrucción que se está ejecutando actualmente).</p></li>
<li><p><strong>Según se van creando en memoria, esos marcos van enlazándose unos con otros</strong> creando una <strong>secuencia de marcos</strong> que se denomina <strong>entorno</strong> (del inglés, <em>environment</em>).</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.6.0.0.1">

<div class="caja">
<p>El entorno nos dice <strong><em>todos</em> los identificadores que son <em>accesibles</em> en un momento concreto de la ejecución del programa, y con qué valores están ligados</strong>.</p>
</div>
</section>
<section class="slide level5" data-number="2.6.0.0.2">

<ul>
<li><p>En un momento dado, el entorno contendrá más o menos marcos dependiendo de por dónde haya pasado la ejecución del programa hasta ese momento.</p></li>
<li><p>El entorno, por tanto, es un concepto <strong><em>dinámico</em></strong> que <strong>depende del momento en el que se calcule</strong>, es decir, de por dónde va la ejecución del programa (o, lo que es lo mismo, de qué instrucciones se han ejecutado hasta ahora y en qué ámbitos se ha entrado).</p></li>
<li><p>El entorno <strong>siempre contendrá</strong>, al menos, un marco: el <em>marco global</em>.</p></li>
<li><p><strong>El marco global siempre será el último de la secuencia de marcos</strong> que forman el entorno.</p></li>
</ul>
<div class="centered">
<p><img data-src="images/cadena-de-marcos.svg" class="plain" style="width:60.0%" /></p>
</div>
</section>

<section id="ámbitos-marcos-y-entornos" class="title-slide slide level2" data-number="2.7">
<h2 data-number="2.7"><span class="header-section-number">2.7</span> Ámbitos, marcos y entornos</h2>
<ul>
<li><p>Recordemos que un marco es un conjunto de ligaduras.</p></li>
<li><p>Y que un entorno es una secuencia de marcos que contienen todas las ligaduras válidas en un punto concreto de la ejecución del programa.</p></li>
<li><p>Cuando la ejecución del programa entra dentro de un ámbito, <strong>se crea un nuevo marco asociado a ese ámbito</strong>.</p></li>
<li><p>Además, <strong>el cuerpo de una expresión lambda define un nuevo ámbito</strong>.</p></li>
<li><p>Por tanto, cuando se aplica una expresión lambda a unos argumentos, <strong>se crea un nuevo marco que contiene las ligaduras que ligan a los parámetros con los valores de esos argumentos</strong>.</p></li>
<li><p>Ese nuevo marco se enlaza con el marco del ámbito que lo contiene (el marco del ámbito más interno <em>apunta</em> al del más externo), de manera que el último marco de la secuencia siempre es el marco global.</p></li>
<li><p>El marco desaparece cuando el flujo de control del programa se sale del ámbito, ya que cada marco va asociado a un ámbito.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.7.0.0.1">

<ul>
<li><p>Se va formando así una secuencia de marcos que representa el <strong>entorno</strong> del programa en un punto dado del mismo.</p></li>
<li><p>El <strong>ámbito</strong> es un concepto <em>estático</em>: es algo que existe y se reconoce simplemente leyendo el código del programa, sin tener que ejecutarlo.</p></li>
<li><p>El <strong>marco</strong> es un concepto <em>dinámico</em>: es algo que se crea y se destruye a medida que vamos entrando o saliendo de un ámbito, y contiene las ligaduras que se definen dentro de ese ámbito.</p></li>
<li><p>A partir de ahora ya no vamos a tener un único marco (el <em>marco global</em>) sino que tendremos, además, al menos uno más cada vez que se aplique una expresión lambda a unos argumentos.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.7.0.0.2">

<ul>
<li><p>Por ejemplo:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>suma <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span></code></pre></div>
<p>el cuerpo de la función <code>suma</code> define un nuevo ámbito, y cada vez que se llama a <code>suma</code> con unos argumentos concretos, la ejecución del programa entra en el cuerpo, lo que crea un nuevo marco que liga sus argumentos con sus parámetros.</p></li>
<li><p>Por tanto, en el siguiente código tenemos dos ámbitos: el ámbito global (más externo) y el ámbito del cuerpo de la expresión lambda (más interno y anidado dentro del ámbito global):</p></li>
</ul>
<div class="centered">
<p><img data-src="images/ambitos-anidados.png" class="plain" style="width:60.0%" /></p>
</div>
</section>
<section class="slide level5" data-number="2.7.0.0.3">

<ul>
<li>El concepto de <strong>entorno</strong> refleja el hecho de que los ámbitos se contienen unos a otros (están anidados unos dentro de otros).</li>
</ul>
<div class="caja">
<p><strong>Si un marco <span class="math inline">A</span> apunta a un marco <span class="math inline">B</span>, significa que el ámbito de <span class="math inline">A</span> está contenido en el ámbito de <span class="math inline">B</span>.</strong></p>
</div>
<ul>
<li><p>Además:</p>
<ul>
<li><p>El <strong>primer marco</strong> del entorno siempre es el marco del <em>ámbito más interno</em> de la instrucción actual.</p></li>
<li><p>El <strong>último marco</strong> siempre es el <em>marco global</em>.</p></li>
</ul></li>
<li><p>En realidad, el marco global apunta, a su vez, a otro marco donde se encuentran las definiciones internas predefinidas del lenguaje (como la función <code>max</code>), pero lo ignoraremos de aquí en adelante por simplicar.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.7.0.0.4">

<ul>
<li><p>Por ejemplo, si en un momento concreto de la ejecución del programa tenemos el siguiente entorno (donde <code>suma</code> es una expresión lambda):</p>
<div class="centered">
<p><img data-src="images/lambda-suma-entorno.svg" class="plain" style="width:60.0%" /></p>
</div>
<p>Podemos afirmar que:</p>
<ul>
<li><p>El ámbito de la expresión lambda está contenido en el ámbito global.</p></li>
<li><p>El marco actual es el marco de la expresión lambda.</p></li>
<li><p>El ámbito actual es el cuerpo de la expresión lambda.</p></li>
<li><p>Por tanto, el programa se encuentra actualmente ejecutando el cuerpo de la expresión lambda.</p></li>
<li><p>De hecho, está evaluando la llamada <code>suma(3, 5)</code>.</p></li>
</ul></li>
</ul>
</section>

<section id="ligaduras-sombreadas" class="title-slide slide level2" data-number="2.8">
<h2 data-number="2.8"><span class="header-section-number">2.8</span> Ligaduras <em>sombreadas</em></h2>
<ul>
<li><p>¿Qué ocurre cuando una expresión lambda contiene como parámetros nombres que ya están definidos (ligados) en el entorno, en un ámbito más global?</p></li>
<li><p>Por ejemplo:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode numberSource python number-lines"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1"></a>x <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb21-2"><a href="#cb21-2"></a>total <span class="op">=</span> (<span class="kw">lambda</span> x: x <span class="op">*</span> x)(<span class="dv">3</span>)  <span class="co"># Su valor es 9</span></span></code></pre></div></li>
<li><p>La <code>x</code> que aparece en la línea 1 es distinta a las que aparecen en la 2:</p>
<ul>
<li><p>La <code>x</code> de la línea 1 es un identificador ligado a un valor en el ámbito global (el ámbito de creación de esa ligadura es el ámbito global). Esa ligadura, por tanto, se almacena en el marco global, y por eso decimos que esa <code>x</code> (la que aparece en la línea 1) es <em>global</em>.</p></li>
<li><p>Las <code>x</code> de la línea 2 son parámetros y variables ligadas de la expresión lambda. Por tanto, el ámbito de esas <code>x</code> es <em>local</em> al cuerpo de la expresión lambda.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="2.8.0.0.1">

<ul>
<li><p>En el ejemplo, el identificador <code>x</code> que aparece en el cuerpo de la expresión lambda <strong>está ligado al parámetro <code>x</code> de la expresión lambda</strong>.</p></li>
<li><p>Por tanto, <strong>no</strong> se refiere al identificador <code>x</code> que está fuera de la expresión lambda (y que aquí está ligado al valor <code>4</code>), sino al parámetro <code>x</code> que, en la llamada de la línea 2, está ligado al valor <code>3</code> (el argumento de la llamada).</p></li>
<li><p>Eso quiere decir que, dentro del cuerpo, <code>x</code> vale <code>3</code>, no <code>4</code>.</p></li>
<li><p>Cuando un mismo identificador está ligado en dos ámbitos anidados uno dentro del otro, decimos que:</p>
<ul>
<li><p>El identificador que aparece en el ámbito más externo está <strong>sombreado</strong> (y su ligadura está <strong>sombreada</strong>).</p></li>
<li><p>El identificador que aparece en el ámbito más interno <strong>hace sombra</strong> al identificador sombreado (y su ligadura también se dice que <strong>hace sombra</strong> a la ligadura sombreada).</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="2.8.0.0.2">

<ul>
<li><p>En nuestro ejemplo, podemos decir que el parámetro <code>x</code> de la expresión lambda hace sombra al identificador <code>x</code> que aparece en el ámbito global.</p></li>
<li><p>Eso significa que no podemos acceder a ese identificador <code>x</code> global desde dentro del cuerpo de la expresión lambda como si fuera una variable libre, porque la <code>x</code> dentro del cuerpo siempre se referirá a la <code>x</code> local (el parámetro de la expresión lambda).</p></li>
<li><p>Esto es así porque la primera ligadura del identificador <code>x</code> que nos encontramos al recorrer la secuencia de marcos del entorno, buscando un valor para <code>x</code>, es la que está en el marco de la expresión lambda, que es el marco actual cuando se está ejecutando su cuerpo.</p></li>
</ul>
<div class="centered">
<figure>
<img data-src="images/lambda-entorno-con-sombra.svg" class="plain" style="width:50.0%" alt="Entorno en el cuerpo de la expresión lambda, con ligadura sombreada" /><figcaption aria-hidden="true">Entorno en el cuerpo de la expresión lambda, con ligadura sombreada</figcaption>
</figure>
</div>
</section>
<section class="slide level5" data-number="2.8.0.0.3">

<ul>
<li><p>Si necesitáramos acceder, desde el cuerpo de la expresión lambda, al valor de la <code>x</code> que está fuera de la expresión lambda, lo que podemos hacer es <strong>cambiar el nombre</strong> al parámetro <code>x</code>. Por ejemplo:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>total <span class="op">=</span> (<span class="kw">lambda</span> w: w <span class="op">*</span> x)(<span class="dv">3</span>)  <span class="co"># Su valor es 12</span></span></code></pre></div>
<p>Así, tendremos en la expresión lambda una variable ligada (el parámetro <code>w</code>) y una variable libre (el identificador <code>x</code> ligado en el ámbito global) al que ahora sí podemos acceder al no estar sombreada y encontrarse dentro del entorno.</p></li>
</ul>
<div class="centered">
<figure>
<img data-src="images/lambda-entorno-sin-sombra.svg" class="plain" style="width:60.0%" alt="Entorno en el cuerpo de la expresión lambda, sin variable sombreada" /><figcaption aria-hidden="true">Entorno en el cuerpo de la expresión lambda, sin variable sombreada</figcaption>
</figure>
</div>
</section>

<section id="renombrado-de-parámetros" class="title-slide slide level2" data-number="2.9">
<h2 data-number="2.9"><span class="header-section-number">2.9</span> Renombrado de parámetros</h2>
<ul>
<li><p>Los parámetros se pueden <em>renombrar</em> (siempre que se haga de forma adecuada) sin que se altere el significado de la expresión lambda.</p></li>
<li><p>A esta operación se la denomina <strong>α-conversión</strong>.</p></li>
<li><p>Un ejemplo de α-conversión es la que hicimos antes.</p></li>
<li><p>La α-conversión hay que hacerla correctamente para evitar efectos indeseados. Por ejemplo, en:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lambda</span> x, y: x <span class="op">+</span> y <span class="op">+</span> z</span></code></pre></div>
<p>si renombramos <code>x</code> a <code>z</code> tendríamos:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lambda</span> z, y: z <span class="op">+</span> y <span class="op">+</span> z</span></code></pre></div>
<p>lo que es claramente incorrecto. A este fenómeno indeseable se le denomina <strong>captura de variables</strong>.</p></li>
</ul>
</section>
</section>
<section>
<section id="evaluación" class="title-slide slide level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Evaluación</h1>

</section>
<section id="evaluación-de-expresiones-con-entornos" class="title-slide slide level2" data-number="3.1">
<h2 data-number="3.1"><span class="header-section-number">3.1</span> Evaluación de expresiones con entornos</h2>
<ul>
<li><p>Al evaluar una expresión, el intérprete <strong>buscará en el entorno el valor al que está ligado cada identificador</strong> que aparezca en la expresión.</p></li>
<li><p>Para saber cuánto vale cada identificador, el intérprete buscará <strong>en el primer marco del entorno</strong> una ligadura para ese identificador, y si no la encuentra, <strong>irá subiendo por la secuencia de marcos</strong> hasta encontrarla.</p>
<p><strong>Si no aparece en ningún marco</strong>, querrá decir que el identificador no está ligado, o que su ligadura está fuera del entorno, en otro ámbito inaccesible desde el ámbito actual. En cualquier caso, <strong>generará un error</strong> de tipo «<em>nombre no definido</em>».</p></li>
<li><p>Se debe tener en cuenta, también, las posibles <strong>variables sombreadas</strong> que puedan aparecer.</p>
<p>Si un identificador de un ámbito más local <em>hace sombra</em> a otro situado en un ámbito más global, al buscar una ligadura en el entorno se encontrará primero la ligadura más local, ignorando las demás.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.1.0.0.1">

<ul>
<li><p>Por ejemplo:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode numberSource python number-lines"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1"></a>x <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb25-2"><a href="#cb25-2"></a>z <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb25-3"><a href="#cb25-3"></a>suma <span class="op">=</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y <span class="op">+</span> z)(<span class="dv">8</span>, <span class="dv">12</span>)</span>
<span id="cb25-4"><a href="#cb25-4"></a>y <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb25-5"><a href="#cb25-5"></a>w <span class="op">=</span> <span class="dv">9</span></span></code></pre></div></li>
<li><p>A medida que vamos ejecutando cada línea del código, tendríamos los siguientes entornos:</p></li>
</ul>
<div class="columns">
<div class="column">
<div class="centered">
<figure>
<img data-src="images/lambda-entorno-linea1.svg" class="plain" style="width:60.0%" alt="Entorno en la línea 1" /><figcaption aria-hidden="true">Entorno en la línea 1</figcaption>
</figure>
</div>
</div><div class="column">
<div class="centered">
<figure>
<img data-src="images/lambda-entorno-linea2.svg" class="plain" style="width:60.0%" alt="Entorno en la línea 2" /><figcaption aria-hidden="true">Entorno en la línea 2</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section class="slide level5" data-number="3.1.0.0.2">

<div class="centered">
<figure>
<img data-src="images/lambda-entorno-linea3-durante.svg" class="plain" style="width:60.0%" alt="Entorno en la línea 3 en el cuerpo de la expresión lambda, después de aplicar los argumentos y durante la ejecución del cuerpo" /><figcaption aria-hidden="true">Entorno en la línea 3 en el cuerpo de la expresión lambda, después de aplicar los argumentos y <strong>durante</strong> la ejecución del cuerpo</figcaption>
</figure>
</div>
<div class="centered">
<figure>
<img data-src="images/lambda-entorno-linea3-despues.svg" class="plain" style="width:30.0%" alt="Entorno en la línea 3 en el cuerpo de la expresión lambda, después de ejecutar el cuerpo y devolver el resultado" /><figcaption aria-hidden="true">Entorno en la línea 3 en el cuerpo de la expresión lambda, <strong>después</strong> de ejecutar el cuerpo y devolver el resultado</figcaption>
</figure>
</div>
</section>
<section class="slide level5" data-number="3.1.0.0.3">

<div class="columns">
<div class="column">
<div class="centered">
<figure>
<img data-src="images/lambda-entorno-linea4.svg" class="plain" style="width:60.0%" alt="Entorno en la línea 4" /><figcaption aria-hidden="true">Entorno en la línea 4</figcaption>
</figure>
</div>
</div><div class="column">
<div class="centered">
<figure>
<img data-src="images/lambda-entorno-linea5.svg" class="plain" style="width:60.0%" alt="Entorno en la línea 5" /><figcaption aria-hidden="true">Entorno en la línea 5</figcaption>
</figure>
</div>
</div>
</div>
</section>

<section id="evaluación-de-expresiones-lambda-con-entornos" class="title-slide slide level2" data-number="3.2">
<h2 data-number="3.2"><span class="header-section-number">3.2</span> Evaluación de expresiones lambda con entornos</h2>
<ul>
<li><p>Para que una expresión lambda funcione, sus variables libres deben estar ligadas a algún valor en el entorno <strong>en el momento de <em>evaluar</em> la aplicación de la expresión lambda sobre unos argumentos</strong>.</p></li>
<li><p>Por ejemplo:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode numberSource python number-lines"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1"></a><span class="op">&gt;&gt;&gt;</span> prueba <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y <span class="op">+</span> z  <span class="co"># aquí no da error</span></span>
<span id="cb26-2"><a href="#cb26-2"></a><span class="op">&gt;&gt;&gt;</span> prueba(<span class="dv">4</span>, <span class="dv">3</span>)                     <span class="co"># aquí sí</span></span>
<span id="cb26-3"><a href="#cb26-3"></a>Traceback (most recent call last):</span>
<span id="cb26-4"><a href="#cb26-4"></a>  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></span>
<span id="cb26-5"><a href="#cb26-5"></a>  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span><span class="kw">lambda</span><span class="op">&gt;</span></span>
<span id="cb26-6"><a href="#cb26-6"></a><span class="pp">NameError</span>: name <span class="st">&#39;z&#39;</span> <span class="kw">is</span> <span class="kw">not</span> defined</span></code></pre></div>
<p>da error porque <code>z</code> no está definido (no está ligado a ningún valor en el entorno) en el momento de llamar a <code>prueba</code> en la línea 2.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.0.0.1">

<ul>
<li><p>En cambio:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode numberSource python number-lines"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1"></a><span class="op">&gt;&gt;&gt;</span> prueba <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y <span class="op">+</span> z</span>
<span id="cb27-2"><a href="#cb27-2"></a><span class="op">&gt;&gt;&gt;</span> z <span class="op">=</span> <span class="dv">9</span></span>
<span id="cb27-3"><a href="#cb27-3"></a><span class="op">&gt;&gt;&gt;</span> prueba(<span class="dv">4</span>, <span class="dv">3</span>)</span>
<span id="cb27-4"><a href="#cb27-4"></a><span class="dv">16</span></span></code></pre></div>
<p>sí funciona (y devuelve <code>16</code>) porque, en el momento de evaluar la aplicación de la expresión lambda (en la línea 3), el identificador <code>z</code> está ligado a un valor en el entorno (en este caso, <code>9</code>).</p></li>
<li><p>Observar que no es necesario que las variables libres estén ligadas en el entorno cuando <em>se crea</em> la expresión lambda, sino cuando <strong><em>se evalúa</em> el cuerpo de la expresión lambda</strong>, o sea, cuando se aplica la expresión lambda a unos argumentos.</p></li>
</ul>
</section>
<section id="ejemplo-2" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejemplo</h5>
<ul>
<li><p>En el siguiente <em>script</em>:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode numberSource python number-lines"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1"></a>w <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb28-2"><a href="#cb28-2"></a>f <span class="op">=</span> <span class="kw">lambda</span> x, y: <span class="dv">5</span> <span class="op">+</span> (<span class="kw">lambda</span> z: z <span class="op">+</span> <span class="dv">3</span>)(x <span class="op">+</span> y)</span>
<span id="cb28-3"><a href="#cb28-3"></a>r <span class="op">=</span> f(<span class="dv">2</span>, <span class="dv">4</span>)</span>
<span id="cb28-4"><a href="#cb28-4"></a>m <span class="op">=</span> (<span class="kw">lambda</span> x: x <span class="op">**</span> <span class="dv">2</span>)(<span class="dv">3</span>)</span></code></pre></div>
<p>existen cuatro ámbitos:</p>
<div class="centered">
<p><img data-src="images/cuatro-ambitos.png" class="plain" style="width:100.0%" /></p>
</div></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.0.0.2">

<ul>
<li>Su ejecución, línea a línea, produce los siguientes entornos:</li>
</ul>
<div class="columns">
<div class="column">
<div class="centered">
<figure>
<img data-src="images/cuatro-ambitos-entorno-linea1.svg" class="plain" style="width:60.0%" alt="Entorno en la línea 1" /><figcaption aria-hidden="true">Entorno en la línea 1</figcaption>
</figure>
</div>
</div><div class="column">
<div class="centered">
<figure>
<img data-src="images/cuatro-ambitos-entorno-linea2.svg" class="plain" style="width:60.0%" alt="Entorno en la línea 2" /><figcaption aria-hidden="true">Entorno en la línea 2</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section class="slide level5" data-number="3.2.0.0.3">

<div class="centered">
<figure>
<img data-src="images/cuatro-ambitos-entorno-linea3-durante-primer-lambda.svg" class="plain" style="width:60.0%" alt="Entorno en la línea 3 en el cuerpo de la primera expresión lambda, después de aplicar sus argumentos y durante la ejecución de su cuerpo" /><figcaption aria-hidden="true">Entorno en la línea 3 en el cuerpo de la primera expresión lambda, después de aplicar sus argumentos y durante la ejecución de su cuerpo</figcaption>
</figure>
</div>
</section>
<section class="slide level5" data-number="3.2.0.0.4">

<div class="centered">
<figure>
<img data-src="images/cuatro-ambitos-entorno-linea3-durante-segundo-lambda.svg" class="plain" style="width:90.0%" alt="Entorno en la línea 3 en el cuerpo de la segunda expresión lambda, después de aplicar sus argumentos y durante la ejecución de su cuerpo" /><figcaption aria-hidden="true">Entorno en la línea 3 en el cuerpo de la segunda expresión lambda, después de aplicar sus argumentos y durante la ejecución de su cuerpo</figcaption>
</figure>
</div>
</section>
<section class="slide level5" data-number="3.2.0.0.5">

<div class="centered">
<figure>
<img data-src="images/cuatro-ambitos-entorno-linea3-durante-primer-lambda.svg" class="plain" style="width:60.0%" alt="Entorno en la línea 3 en el cuerpo de la segunda expresión lambda, después de ejecutar su cuerpo y devolver su resultado" /><figcaption aria-hidden="true">Entorno en la línea 3 en el cuerpo de la segunda expresión lambda, después de ejecutar su cuerpo y devolver su resultado</figcaption>
</figure>
</div>
</section>
<section class="slide level5" data-number="3.2.0.0.6">

<div class="centered">
<figure>
<img data-src="images/cuatro-ambitos-entorno-linea3-despues-primer-lambda.svg" class="plain" style="width:40.0%" alt="Entorno en la línea 3 en el cuerpo de la primera expresión lambda, después de ejecutar su cuerpo y devolver su resultado" /><figcaption aria-hidden="true">Entorno en la línea 3 en el cuerpo de la primera expresión lambda, después de ejecutar su cuerpo y devolver su resultado</figcaption>
</figure>
</div>
</section>
<section class="slide level5" data-number="3.2.0.0.7">

<div class="centered">
<figure>
<img data-src="images/cuatro-ambitos-entorno-linea4-durante-tercer-lambda.svg" class="plain" style="width:60.0%" alt="Entorno en la línea 4 en el cuerpo de la tercera expresión lambda, después de aplicar sus argumentos y durante la ejecución de su cuerpo" /><figcaption aria-hidden="true">Entorno en la línea 4 en el cuerpo de la tercera expresión lambda, después de aplicar sus argumentos y durante la ejecución de su cuerpo</figcaption>
</figure>
</div>
</section>
<section class="slide level5" data-number="3.2.0.0.8">

<div class="centered">
<figure>
<img data-src="images/cuatro-ambitos-entorno-linea4-despues-tercer-lambda.svg" class="plain" style="width:40.0%" alt="Entorno en la línea 4 en el cuerpo de la tercera expresión lambda, después de ejecutar su cuerpo y devolver su resultado" /><figcaption aria-hidden="true">Entorno en la línea 4 en el cuerpo de la tercera expresión lambda, después de ejecutar su cuerpo y devolver su resultado</figcaption>
</figure>
</div>
</section>
<section id="visualización-en-pythontutor" class="title-slide slide level3" data-number="3.2.1">
<h3 data-number="3.2.1"><span class="header-section-number">3.2.1</span> Visualización en <em>Pythontutor</em></h3>
<ul>
<li><p><strong>Pythontutor</strong> es una herramienta online muy interesante y práctica que nos permite ejecutar un <em>script</em> paso a paso y visualizar sus efectos.</p></li>
<li><p>Muestra la pila de control, los marcos dentro de ésta, las ligaduras dentro de éstos y los datos almacenados en el montículo.</p></li>
<li><p>Entrando en <a href="http://pythontutor.com/visualize.html">http://pythontutor.com/visualize.html</a> se abre un área de texto donde se puede teclear (o copiar y pegar) el código fuente del <em>script</em> a ejecutar.</p></li>
<li><p>Pulsando en «<em>Visualize Execution</em>» se pone en marcha, pudiendo ejecutar todo el <em>script</em> de una vez o hacerlo paso a paso.</p></li>
<li><p>Conviene elegir las siguientes opciones:</p>
<ul>
<li><p><em>Hide exited frames (default)</em></p></li>
<li><p><em>Render all objects on the heap (Python/Java)</em></p></li>
<li><p><em>Draw pointers as arrows (default)</em></p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.1.0.1">

<p><a href="http://pythontutor.com/visualize.html#code=w%20%3D%202%0Af%20%3D%20lambda%20x,%20y%3A%205%20%2B%20%28lambda%20z%3A%20z%20%2B%203%29%28x%20%2B%20y%29%0Ar%20%3D%20f%282,%204%29%0Am%20%3D%20%28lambda%20x%3A%20x%20**%202%29%283%29%0A&amp;cumulative=false&amp;curInstr=0&amp;heapPrimitives=true&amp;mode=display&amp;origin=opt-frontend.js&amp;py=3&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false" target="_blank">Visualizar el <em>script</em> anterior en Pythontutor</a></p>
</section>
<section id="ejercicio" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejercicio</h5>
<ol class="example" type="1">
<li><p>En el <em>script</em> anterior:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode numberSource python number-lines"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1"></a>w <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb29-2"><a href="#cb29-2"></a>f <span class="op">=</span> <span class="kw">lambda</span> x, y: <span class="dv">5</span> <span class="op">+</span> (<span class="kw">lambda</span> z: z <span class="op">+</span> <span class="dv">3</span>)(x <span class="op">+</span> y)</span>
<span id="cb29-3"><a href="#cb29-3"></a>r <span class="op">=</span> f(<span class="dv">2</span>, <span class="dv">4</span>)</span>
<span id="cb29-4"><a href="#cb29-4"></a>m <span class="op">=</span> (<span class="kw">lambda</span> x: x <span class="op">**</span> <span class="dv">2</span>)(<span class="dv">3</span>)</span></code></pre></div>
<p>indicar:</p>
<ol type="a">
<li><p>Los identificadores.</p></li>
<li><p>Los ámbitos.</p></li>
<li><p>Los entornos, marcos y ligaduras en cada línea de código.</p></li>
<li><p>Los ámbitos de cada ligadura.</p></li>
<li><p>Los ámbitos de creación de cada ligadura.</p></li>
<li><p>Los ámbitos de cada aparición de cada identificador.</p></li>
<li><p>Las ligaduras sombreadas y los identificadores sombreados.</p></li>
<li><p>Los identificadores y ligaduras que hacen sombra.</p></li>
</ol></li>
</ol>
</section>


<section id="estrategias-de-evaluación" class="title-slide slide level2" data-number="3.3">
<h2 data-number="3.3"><span class="header-section-number">3.3</span> Estrategias de evaluación</h2>
<ul>
<li><p>A la hora de evaluar una expresión (cualquier expresión) existen varias <strong>estrategias</strong> diferentes que se pueden adoptar.</p></li>
<li><p>Cada lenguaje implementa sus propias estrategias de evaluación que están basadas en las que vamos a ver aquí.</p></li>
<li><p>Básicamente se trata de decidir, en cada paso de reducción, qué subexpresión hay que reducir, en función de:</p>
<ul>
<li><p>El orden de evaluación:</p>
<ul>
<li><p>De fuera adentro o de dentro afuera.</p></li>
<li><p>De izquierda a derecha o de derecha a izquierda.</p></li>
</ul></li>
<li><p>La necesidad o no de evaluar dicha subexpresión.</p></li>
</ul></li>
</ul>
</section>
<section id="orden-de-evaluación" class="title-slide slide level3" data-number="3.3.1">
<h3 data-number="3.3.1"><span class="header-section-number">3.3.1</span> Orden de evaluación</h3>
<ul>
<li><p>En un lenguaje de programación funcional puro se cumple la <strong>transparencia referencial</strong>, según la cual el valor de una expresión depende sólo del valor de sus subexpresiones (también llamadas <em>redexes</em>, del inglés, <em>reducible expression</em>).</p></li>
<li><p>Pero eso también implica que <strong>no importa el orden en el que se evalúen las subexpresiones</strong>: el resultado debe ser siempre el mismo.</p></li>
<li><p>Gracias a ello podemos usar nuestro modelo de sustitución como modelo computacional.</p></li>
<li><p>Hay dos <strong>estrategias básicas de evaluación</strong>:</p>
<ul>
<li><p><strong>Orden aplicativo</strong>: reducir siempre el <em>redex</em> más <strong>interno</strong> (y más a la izquierda).</p></li>
<li><p><strong>Orden normal</strong>: reducir siempre el <em>redex</em> más <strong>externo</strong> (y más a la izquierda).</p></li>
</ul></li>
<li><p><strong>Python usa el orden aplicativo</strong>, salvo excepciones.</p></li>
</ul>
</section>
<section id="orden-aplicativo" class="title-slide slide level4" data-number="3.3.1.1">
<h4 data-number="3.3.1.1"><span class="header-section-number">3.3.1.1</span> Orden aplicativo</h4>
<ul>
<li><p>El <strong>orden aplicativo</strong> consiste en evaluar las expresiones <em>de dentro afuera</em>, es decir, empezando por el <em>redex</em> más <strong>interno</strong> y a la izquierda.</p></li>
<li><p>El <em>redex</em> más interno es el que no contiene a otros <em>redexes</em>. Si existe más de uno que cumpla esa condición, se elige el que está más a la izquierda.</p></li>
<li><p>Eso implica que los operandos y los argumentos se evalúan <strong>antes</strong> que los operadores y las aplicaciones de funciones.</p></li>
<li><p>Corresponde a lo que en muchos lenguajes de programación se denomina <strong>paso de argumentos por valor</strong> (<em>call-by-value</em>).</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.1.1.1">

<ul>
<li><p>Por ejemplo, si tenemos la siguiente función:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>cuadrado <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> x</span></code></pre></div>
<p>según el orden aplicativo, la expresión <code>cuadrado(3 + 4)</code> se reduce así:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>cuadrado(<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)               <span class="co"># definición de cuadrado</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="kw">lambda</span> x: x <span class="op">*</span> x)(<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)    <span class="co"># evalúa 3 y devuelve 3</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="kw">lambda</span> x: x <span class="op">*</span> x)(<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)    <span class="co"># evalúa 4 y devuelve 4</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="kw">lambda</span> x: x <span class="op">*</span> x)(<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)    <span class="co"># evalúa 3 + 4 y devuelve 7</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="kw">lambda</span> x: x <span class="op">*</span> x)(<span class="dv">7</span>)        <span class="co"># aplicación a 7</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">7</span> <span class="op">*</span> <span class="dv">7</span>)                     <span class="co"># evalúa (7 * 7) y devuelve 49</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">49</span></span></code></pre></div></li>
</ul>
</section>

<section id="orden-normal" class="title-slide slide level4" data-number="3.3.1.2">
<h4 data-number="3.3.1.2"><span class="header-section-number">3.3.1.2</span> Orden normal</h4>
<ul>
<li><p>El <strong>orden normal</strong> consiste en evaluar las expresiones <em>de fuera adentro</em>, es decir, empezando siempre por el <em>redex</em> más <strong>externo</strong> y a la izquierda.</p></li>
<li><p>El <em>redex</em> más externo es el que no está contenido en otros <em>redexes</em>. Si existe más de uno que cumpla esa condición, se elige el que está más a la izquierda.</p></li>
<li><p>Eso implica que los operandos y los argumentos se evalúan <strong>después</strong> de las aplicaciones de los operadores y las funciones.</p></li>
<li><p>Por tanto, los argumentos que se pasan a las funciones lo hacen <strong>sin evaluarse</strong> previamente.</p></li>
<li><p>Corresponde a lo que en muchos lenguajes de programación se denomina <strong>paso de argumentos por nombre</strong> (<em>call-by-name</em>).</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.1.2.1">

<ul>
<li><p>Por ejemplo, si tenemos la siguiente función:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>cuadrado <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> x</span></code></pre></div>
<p>según el orden normal, la expresión <code>cuadrado(3 + 4)</code> se reduce así:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>cuadrado(<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)               <span class="co"># definición de cuadrado</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="kw">lambda</span> x: x <span class="op">*</span> x)(<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)    <span class="co"># aplicación a (3 + 4)</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> ((<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>) <span class="op">*</span> (<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>))         <span class="co"># evalúa 3 y devuelve 3</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> ((<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>) <span class="op">*</span> (<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>))         <span class="co"># evalúa 4 y devuelve 4</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> ((<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>) <span class="op">*</span> (<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>))         <span class="co"># evalúa (3 + 4) y devuelve 7</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)                 <span class="co"># evalúa 3 y devuelve 3</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)                 <span class="co"># evalúa 4 y devuelve 4</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)                 <span class="co"># evalúa (3 + 4) y devuelve 7</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> <span class="dv">7</span>                       <span class="co"># evalúa 7 * 7 y devuelve 49</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">49</span></span></code></pre></div></li>
</ul>
</section>


<section id="composición-de-funciones" class="title-slide slide level3" data-number="3.3.2">
<h3 data-number="3.3.2"><span class="header-section-number">3.3.2</span> Composición de funciones</h3>
<ul>
<li><p>Podemos crear una función que use otra función. Por ejemplo, para calcular el área de un círculo usamos otra función que calcule el cuadrado de un número:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>cuadrado <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> x</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>area <span class="op">=</span> <span class="kw">lambda</span> r: <span class="fl">3.1416</span> <span class="op">*</span> cuadrado(r)</span></code></pre></div></li>
<li><p>La expresión <code>area(11 + 1)</code> se evaluaría así según el <em>orden aplicativo</em>:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode numberSource python number-lines"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1"></a>area(<span class="dv">11</span> <span class="op">+</span> <span class="dv">1</span>)                                <span class="co"># definición de area</span></span>
<span id="cb35-2"><a href="#cb35-2"></a><span class="op">=</span> (<span class="kw">lambda</span> r: <span class="fl">3.1416</span> <span class="op">*</span> cuadrado(r))(<span class="dv">11</span> <span class="op">+</span> <span class="dv">1</span>)  <span class="co"># evalúa 11 y devuelve 11</span></span>
<span id="cb35-3"><a href="#cb35-3"></a><span class="op">=</span> (<span class="kw">lambda</span> r: <span class="fl">3.1416</span> <span class="op">*</span> cuadrado(r))(<span class="dv">11</span> <span class="op">+</span> <span class="dv">1</span>)  <span class="co"># evalúa 1 y devuelve 1</span></span>
<span id="cb35-4"><a href="#cb35-4"></a><span class="op">=</span> (<span class="kw">lambda</span> r: <span class="fl">3.1416</span> <span class="op">*</span> cuadrado(r))(<span class="dv">11</span> <span class="op">+</span> <span class="dv">1</span>)  <span class="co"># evalúa 11 + 1 y devuelve 12</span></span>
<span id="cb35-5"><a href="#cb35-5"></a><span class="op">=</span> (<span class="kw">lambda</span> r: <span class="fl">3.1416</span> <span class="op">*</span> cuadrado(r))(<span class="dv">12</span>)      <span class="co"># aplicación a 12</span></span>
<span id="cb35-6"><a href="#cb35-6"></a><span class="op">=</span> (<span class="fl">3.1416</span> <span class="op">*</span> cuadrado(<span class="dv">12</span>))                   <span class="co"># evalúa 3.1416 y devuelve 3.1416</span></span>
<span id="cb35-7"><a href="#cb35-7"></a><span class="op">=</span> (<span class="fl">3.1416</span> <span class="op">*</span> cuadrado(<span class="dv">12</span>))                   <span class="co"># definición de cuadrado</span></span>
<span id="cb35-8"><a href="#cb35-8"></a><span class="op">=</span> (<span class="fl">3.1416</span> <span class="op">*</span> (<span class="kw">lambda</span> x: x <span class="op">*</span> x)(<span class="dv">12</span>))          <span class="co"># aplicación a 12</span></span>
<span id="cb35-9"><a href="#cb35-9"></a><span class="op">=</span> (<span class="fl">3.1416</span> <span class="op">*</span> (<span class="dv">12</span> <span class="op">*</span> <span class="dv">12</span>))                      <span class="co"># evalúa (12 * 12) y devuelve 144</span></span>
<span id="cb35-10"><a href="#cb35-10"></a><span class="op">=</span> (<span class="fl">3.1416</span> <span class="op">*</span> <span class="dv">144</span>)                            <span class="co"># evalúa (3.1416 * 11) y...</span></span>
<span id="cb35-11"><a href="#cb35-11"></a><span class="op">=</span> <span class="fl">452.3904</span>                                  <span class="co"># ... devuelve 452.3904</span></span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.2.0.1">

<ul>
<li><p>En detalle:</p>
<ul>
<li><p><strong>Línea 1</strong>: Se evalúa <code>area</code>, que devuelve su definición (una expresión lambda).</p></li>
<li><p><strong>Líneas 2–4</strong>: Lo siguiente a evaluar es la aplicación de <code>area</code> sobre su argumento, por lo que primero evaluamos éste (es el <em>redex</em> más interno).</p></li>
<li><p><strong>Línea 5</strong>: Ahora se aplica la expresión lambda a su argumento <code>12</code>.</p></li>
<li><p><strong>Línea 6</strong>: El <em>redex</em> más interno y a la izquierda es el <code>3.1416</code>, que ya está evaluado.</p></li>
<li><p><strong>Línea 7</strong>: El <em>redex</em> más interno que queda por evaluar es la aplicación de <code>cuadrado</code> sobre <code>12</code>. Primero se evalúa <code>cuadrado</code>, sustituyéndose por su definición…</p></li>
<li><p><strong>Línea 8</strong>: … y ahora se aplica la expresión lambda a su argumento <code>12</code>.</p></li>
<li><p>Lo que queda es todo aritmética.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.2.0.2">

<ul>
<li><p>La expresión <code>area(11 + 1)</code> se evaluaría así según el <em>orden normal</em>:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode numberSource python number-lines"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1"></a>area(<span class="dv">11</span> <span class="op">+</span> <span class="dv">1</span>)                                <span class="co"># definición de area</span></span>
<span id="cb36-2"><a href="#cb36-2"></a><span class="op">=</span> (<span class="kw">lambda</span> r: <span class="fl">3.1416</span> <span class="op">*</span> cuadrado(r))(<span class="dv">11</span> <span class="op">+</span> <span class="dv">1</span>)  <span class="co"># aplicación a (11 + 1)</span></span>
<span id="cb36-3"><a href="#cb36-3"></a><span class="op">=</span> (<span class="fl">3.1416</span> <span class="op">*</span> cuadrado(<span class="dv">11</span> <span class="op">+</span> <span class="dv">1</span>))               <span class="co"># evalúa 3.1416 y devuelve 3.1416</span></span>
<span id="cb36-4"><a href="#cb36-4"></a><span class="op">=</span> (<span class="fl">3.1416</span> <span class="op">*</span> cuadrado(<span class="dv">11</span> <span class="op">+</span> <span class="dv">1</span>))               <span class="co"># definición de cuadrado</span></span>
<span id="cb36-5"><a href="#cb36-5"></a><span class="op">=</span> (<span class="fl">3.1416</span> <span class="op">*</span> (<span class="kw">lambda</span> x: x <span class="op">*</span> x)(<span class="dv">11</span> <span class="op">+</span> <span class="dv">1</span>))      <span class="co"># aplicación a (11 + 1)</span></span>
<span id="cb36-6"><a href="#cb36-6"></a><span class="op">=</span> (<span class="fl">3.1416</span> <span class="op">*</span> ((<span class="dv">11</span> <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> (<span class="dv">11</span> <span class="op">+</span> <span class="dv">1</span>)))          <span class="co"># evalúa (11 + 1) y devuelve 12</span></span>
<span id="cb36-7"><a href="#cb36-7"></a><span class="op">=</span> (<span class="fl">3.1416</span> <span class="op">*</span> (<span class="dv">12</span> <span class="op">*</span> (<span class="dv">11</span> <span class="op">+</span> <span class="dv">1</span>)))                <span class="co"># evalúa (11 + 1) y devuelve 12</span></span>
<span id="cb36-8"><a href="#cb36-8"></a><span class="op">=</span> (<span class="fl">3.1416</span> <span class="op">*</span> (<span class="dv">12</span> <span class="op">*</span> <span class="dv">12</span>))                      <span class="co"># evalúa (12 * 12) y devuelve 144</span></span>
<span id="cb36-9"><a href="#cb36-9"></a><span class="op">=</span> (<span class="fl">3.1416</span> <span class="op">*</span> <span class="dv">144</span>)                            <span class="co"># evalúa (3.1416 * 144) y...</span></span>
<span id="cb36-10"><a href="#cb36-10"></a><span class="op">=</span> <span class="fl">452.3904</span>                                  <span class="co"># ... devuelve 452.3904</span></span></code></pre></div></li>
<li><p>En ambos casos (orden aplicativo y orden normal) se obtiene el mismo resultado.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.2.0.3">

<ul>
<li><p>En detalle:</p>
<ul>
<li><p><strong>Línea 1</strong>: Se evalúa el <em>redex</em> más externo, que es <code>area(11 + 1)</code>. Para ello, se reescribe la definición de <code>area</code>…</p></li>
<li><p><strong>Línea 2</strong>: … y se aplica la expresión lambda al argumento <code>11 + 1</code>.</p></li>
<li><p><strong>Línea 3</strong>: El <em>redex</em> más externo es el <code>*</code>, pero para evaluarlo hay que evaluar primero todos sus argumentos, por lo que primero se evalúa el izquierdo, que es <code>3.1416</code>.</p></li>
<li><p><strong>Línea 4</strong>: Ahora hay que evaluar el derecho (<code>cuadrado(11 + 1)</code>), por lo que se reescribe la definición de <code>cuadrado</code>…</p></li>
<li><p><strong>Línea 5</strong>: … y se aplica la expresión lambda al argumento <code>11 + 1</code>.</p></li>
<li><p>Lo que queda es todo aritmética.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.2.0.4">

<ul>
<li><p>A veces no resulta fácil determinar si un <em>redex</em> es más interno o externo que otro, sobre todo cuando se mezclan funciones y operadores en una misma expresión.</p></li>
<li><p>En ese caso, puede resultar útil reescribir los operadores como funciones, cuando sea posible.</p></li>
<li><p>Por ejemplo, la siguiente expresión:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="bu">abs</span>(<span class="op">-</span><span class="dv">12</span>) <span class="op">+</span> <span class="bu">max</span>(<span class="dv">13</span>, <span class="dv">28</span>)</span></code></pre></div>
<p>se puede reescribir como:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> operator <span class="im">import</span> add</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>add(<span class="bu">abs</span>(<span class="op">-</span><span class="dv">12</span>), <span class="bu">max</span>(<span class="dv">13</span>, <span class="dv">28</span>))</span></code></pre></div>
<p>lo que muestra claramente que la suma es más externa que el valor absoluto y el máximo (que están, a su vez, al mismo nivel de profundidad).</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.2.0.5">

<ul>
<li><p>Un ejemplo más complicado:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="bu">abs</span>(<span class="op">-</span><span class="dv">12</span>) <span class="op">*</span> <span class="bu">max</span>((<span class="dv">2</span> <span class="op">+</span> <span class="dv">3</span>) <span class="op">**</span> <span class="dv">5</span>), <span class="dv">37</span>)</span></code></pre></div>
<p>se reescribiría como:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> operator <span class="im">import</span> add, mul</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>mul(<span class="bu">abs</span>(<span class="op">-</span><span class="dv">12</span>), <span class="bu">max</span>(<span class="bu">pow</span>(add(<span class="dv">2</span>, <span class="dv">3</span>), <span class="dv">5</span>), <span class="dv">37</span>))</span></code></pre></div>
<p>donde se aprecia claramente que el orden de las operaciones, de más interna a más externa, sería:</p>
<ol type="1">
<li><p>Suma (<code>+</code> o <code>add</code>).</p></li>
<li><p>Potencia (<code>**</code> o <code>pow</code>).</p></li>
<li><p>Valor absoluto (<code>abs</code>) y máximo (<code>max</code>) al mismo nivel.</p></li>
<li><p>Producto (<code>*</code> o <code>mul</code>).</p></li>
</ol></li>
</ul>
</section>

<section id="evaluación-estricta-y-no-estricta" class="title-slide slide level3" data-number="3.3.3">
<h3 data-number="3.3.3"><span class="header-section-number">3.3.3</span> Evaluación estricta y no estricta</h3>
<ul>
<li><p>Existe otra forma de ver la evaluación de una expresión:</p>
<ul>
<li><p><strong>Evaluación estricta o <em>impaciente</em></strong>: Reducir todos los <em>redexes</em> aunque no hagan falta para calcular el valor de la expresión.</p></li>
<li><p><strong>Evaluación no estricta o <em>perezosa</em></strong>: Reducir sólo los <em>redexes</em> que sean estrictamente necesarios para calcular el valor de la expresión.</p></li>
</ul></li>
</ul>
</section>
<section id="ejemplo-3" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejemplo</h5>
<ul>
<li><p>Sabemos que la expresión <code>1 / 0</code> da un error de <em>división por cero</em>:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="dv">1</span> <span class="op">/</span> <span class="dv">0</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>Traceback (most recent call last):</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="pp">ZeroDivisionError</span>: division by zero</span></code></pre></div></li>
<li><p>Supongamos que tenemos la siguiente definición:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>primero <span class="op">=</span> <span class="kw">lambda</span> x, y: x</span></code></pre></div>
<p>de forma que <code>primero</code> es una función que simplemente devuelve el primero de sus argumentos.</p></li>
<li><p>Es evidente que la función <code>primero</code> no necesita evaluar nunca su segundo argumento, ya que no lo utiliza (simplemente devuelve el primero de ellos). Por ejemplo, <code>primero(4, 3)</code> devuelve <code>4</code>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.3.0.1">

<ul>
<li><p>Sabiendo eso… ¿qué valor devolvería la siguiente expresión?</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>primero(<span class="dv">4</span>, <span class="dv">1</span> <span class="op">/</span> <span class="dv">0</span>)</span></code></pre></div></li>
<li><p>Curiosamente, el resultado dependerá de si la evaluación es estricta o perezosa:</p>
<ul>
<li><p><strong>Si es estricta</strong>, el intérprete evaluará todos los argumentos de la expresión lambda aunque no se utilicen luego en su cuerpo. Por tanto, al evaluar <code>1 / 0</code> devolverá un error.</p>
<p>Es lo que ocurre cuando se evalúa siguiendo el <strong>orden aplicativo</strong>.</p></li>
<li><p>En cambio, <strong>si es perezosa</strong>, el intérprete evaluará únicamente aquellos argumentos que se usen en el cuerpo de la expresión lambda, y en este caso sólo se usa el primero, así que dejará sin evaluar el segundo, no dará error y devolverá directamente <code>4</code>.</p>
<p>Es lo que ocurre cuando se evalúa siguiendo el <strong>orden normal</strong>:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>primero(<span class="dv">4</span>, <span class="dv">1</span> <span class="op">/</span> <span class="dv">0</span>) <span class="op">=</span> (<span class="kw">lambda</span> x, y: x)(<span class="dv">4</span>, <span class="dv">1</span> <span class="op">/</span> <span class="dv">0</span>) <span class="op">=</span> (<span class="dv">4</span>) <span class="op">=</span> <span class="dv">4</span></span></code></pre></div></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.3.0.2">

<ul>
<li><p>Hay un resultado teórico que avala lo que acabamos de observar:</p>
<div class="caja">
<p><strong>Teorema:</strong></p>
<p>Si una expresión tiene forma normal, el <strong>orden normal</strong> de evaluación conduce seguro a la misma.</p>
</div></li>
<li><p>En cambio, el orden aplicativo es posible que no encuentre la forma normal de la expresión.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.3.0.3">

<ul>
<li><p>En <strong>Python</strong> la evaluación es <strong>estricta</strong>, salvo algunas excepciones:</p>
<ul>
<li><p>El operador ternario:</p>
<div class="line-block"><span style="color:teal">⟨<em>expr_condicional</em>⟩</span> ::= <span style="color:teal">⟨<em>valor_si_cierto</em>⟩</span> <strong><code>if</code></strong> <span style="color:teal">⟨<em>condición</em>⟩</span> <strong><code>else</code></strong> <span style="color:teal">⟨<em>valor_si_falso</em>⟩</span></div>
<p>evalúa perezosamente <span style="color:teal">⟨<em>valor_si_cierto</em>⟩</span> y <span style="color:teal">⟨<em>valor_si_falso</em>⟩</span> dependiendo del valor de la <span style="color:teal">⟨<em>condición</em>⟩</span>.</p></li>
<li><p>Los operadores lógicos <code>and</code> y <code>or</code> también son perezosos (se dice que evalúan <strong>en cortocircuito</strong>):</p>
<ul>
<li><p><code>True or</code>  <span class="math inline">\underline{x}</span></p>
<p>siempre es igual a <code>True</code>.</p></li>
<li><p><code>False and</code>  <span class="math inline">\underline{x}</span></p>
<p>siempre es igual a <code>False</code>.</p></li>
</ul>
<p>En ambos casos no es necesario evaluar <span class="math inline">\underline{x}</span>.</p></li>
</ul></li>
<li><p>En Java también existe un operador ternario (<code>?</code> <code>:</code>) y unos operadores lógicos (<code>||</code> y <code>&amp;&amp;</code>) que se evalúan de igual forma que en Python.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.3.0.4">

<ul>
<li><p>La mayoría de los lenguajes de programación usan evaluación estricta y paso de argumentos por valor (siguen el orden aplicativo).</p></li>
<li><p><strong>Haskell</strong>, por ejemplo, es un lenguaje funcional puro que usa evaluación perezosa y sigue el orden normal.</p></li>
<li><p>La evaluación perezosa en Haskell permite resultados muy interesantes, como la posibilidad de manipular estructuras de datos infinitas.</p></li>
</ul>
</section>

</section>
<section>
<section id="abstracciones-funcionales" class="title-slide slide level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Abstracciones funcionales</h1>

</section>
<section id="pureza" class="title-slide slide level2" data-number="4.1">
<h2 data-number="4.1"><span class="header-section-number">4.1</span> Pureza</h2>
<ul>
<li><p>Si el cuerpo de una expresión lambda no contiene variables libres, el valor que obtendremos al aplicarla a unos argumentos dependerá únicamente del valor que tengan esos argumentos (no dependerá de nada más que sea «<em>exterior</em>» a la expresión lambda).</p></li>
<li><p>En cambio, si el cuerpo de una expresión lambda sí contiene variables libres, el valor que obtendremos al aplicarla a unos argumentos no sólo dependerá del valor de esos argumentos, sino también de los valores a los que estén ligadas las variables libres en el momento de evaluar la aplicación de la expresión lambda.</p></li>
<li><p>Es el caso del ejemplo anterior, donde tenemos una expresión lambda que contiene una variable libre (<code>z</code>) y, por tanto, cuando la aplicamos a los argumentos <code>4</code> y <code>3</code> obtenemos un valor que depende, no sólo de los valores de <code>x</code> e <code>y</code>, sino también del valor de <code>z</code>:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> prueba <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y <span class="op">+</span> z</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> z <span class="op">=</span> <span class="dv">9</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> prueba(<span class="dv">4</span>, <span class="dv">3</span>)</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="dv">16</span></span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="4.1.0.0.1">

<ul>
<li><p>En este otro ejemplo, escribimos una expresión lambda que calcula la suma de tres números a partir de otra expresión lambda que calcula la suma de dos números:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>suma <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>suma3 <span class="op">=</span> <span class="kw">lambda</span> x, y, z: suma(x, y) <span class="op">+</span> z</span></code></pre></div>
<p>En este caso, hay un identificador (<code>suma</code>) que no aparece en la lista de parámetros de la expresión lambda <code>suma3</code>, por lo que es una variable libre en el cuerpo de la expresión lambda de <code>suma3</code>.</p>
<p>En consecuencia, el valor de dicha expresión lambda dependerá de lo que valga <code>suma</code> en el entorno actual.</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.1.0.0.2">

<ul>
<li><p>Se dice que una expresión lambda es <strong>pura</strong> si, siempre que la apliquemos a unos argumentos, el valor obtenido va a depender únicamente del valor de esos argumentos, es decir, de sus parámetros o variables ligadas.</p></li>
<li><p>Podemos decir que hay distintos <strong>grados de pureza</strong>:</p>
<ul>
<li><p>Una expresión lambda que contiene <strong>sólo variables ligadas</strong> es <strong>más pura</strong> que otra que también contiene variables libres.</p></li>
<li><p>Una expresión lambda cuyas <strong>variables libres</strong> representan <strong>funciones</strong> que se usan en el cuerpo de la expresión lambda, es <strong>más pura</strong> que otra cuyas variables libres representan cualquier otro tipo de valor.</p></li>
</ul>
<p>En el ejemplo anterior, tenemos que la expresión lambda de <code>suma3</code>, sin ser <em>totalmente pura</em>, a efectos prácticos se la puede considerar <strong>pura</strong>, ya que su única variable libre (<code>suma</code>) se usa como una <strong>función</strong>, y las funciones tienden a no cambiar durante la ejecución del programa, al contrario que los demás tipos de valores.</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.1.0.0.3">

<ul>
<li><p>Por ejemplo, las siguientes expresiones lambda están ordenadas de mayor a menor pureza, siendo la primera totalmente <strong>pura</strong>:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="co"># producto es una expresión lambda totalmente pura:</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>producto <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">*</span> y</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="co"># cuadrado es casi pura; a efectos prácticos se la puede</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a><span class="co"># considerar pura ya que sus variables libres (en este</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a><span class="co"># caso, sólo una: producto) son funciones:</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>cuadrado <span class="op">=</span> <span class="kw">lambda</span> x: producto(x, x)</span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a><span class="co"># suma es impura, porque su variable libre (z) no es una función:</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>suma <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y <span class="op">+</span> z</span></code></pre></div></li>
<li><p><strong>La pureza de una función es un rasgo deseado y que hay que tratar de alcanzar siempre que sea posible</strong>, ya que facilita el desarrollo y mantenimiento de los programas, además de simplificar el razonamiento sobre los mismos, permitiendo aplicar directamente nuestro modelo de sustitución.</p></li>
<li><p>Es más incómodo trabajar con <code>suma</code> porque hay que <em>recordar</em> que depende de un valor que está <em>fuera</em> de la expresión lambda, cosa que no resulta evidente a no ser que mires en el cuerpo de la expresión lambda.</p></li>
</ul>
</section>

<section id="las-funciones-como-abstracciones" class="title-slide slide level2" data-number="4.2">
<h2 data-number="4.2"><span class="header-section-number">4.2</span> Las funciones como abstracciones</h2>
<ul>
<li><p>Recordemos la definición de la función <code>area</code>:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>cuadrado <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> x</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>area <span class="op">=</span> <span class="kw">lambda</span> r: <span class="fl">3.1416</span> <span class="op">*</span> cuadrado(r)</span></code></pre></div></li>
<li><p>Aunque es muy sencilla, la función <code>area</code> ejemplifica la propiedad más potente de las funciones definidas por el programador: la <strong>abstracción</strong>.</p></li>
<li><p>La función <code>area</code> está definida sobre la función <code>cuadrado</code>, pero sólo necesita saber de ella qué resultados de salida devuelve a partir de sus argumentos de entrada.</p></li>
<li><p>Podemos escribir <code>area</code> sin preocuparnos de cómo calcular el cuadrado de un número, porque eso ya lo hace la función <code>cuadrado</code>.</p></li>
<li><p><strong>Los detalles</strong> sobre cómo se calcula el cuadrado están <strong>ocultos dentro de la definición</strong> de <code>cuadrado</code>. Esos detalles <strong>se ignoran en este momento</strong> al diseñar <code>area</code>, para considerarlos más tarde si hiciera falta.</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.0.0.1">

<ul>
<li><p>De hecho, por lo que respecta a <code>area</code>, <code>cuadrado</code> no representa una definición concreta de función, sino más bien la abstracción de una función, lo que se denomina una <strong>abstracción funcional</strong>, ya que a <code>area</code> le sirve igual de bien cualquier función que calcule el cuadrado de un número.</p></li>
<li><p>Por tanto, si consideramos únicamente los valores que devuelven, las tres funciones siguientes son indistinguibles e igual de válidas para <code>area</code>. Ambas reciben un argumento numérico y devuelven el cuadrado de ese número:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>cuadrado <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> x</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>cuadrado <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>cuadrado <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> (x <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> x</span></code></pre></div></li>
<li><p>En otras palabras: la definición de una función debe ser capaz de <strong>ocultar sus detalles internos de funcionamiento</strong>, ya que para usar la función no debe ser necesario conocer esos detalles.</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.0.0.2">

<ul>
<li><p>La <strong>especificación de una <em>función</em></strong> es la descripción de <strong>qué</strong> hace la función sin entrar a detallar <strong>cómo</strong> lo hace.</p></li>
<li><p>La <strong>implementación de una <em>función</em></strong> es la descripción de <strong>cómo</strong> hace lo que hace, es decir, los detalles de su algoritmo interno.</p></li>
<li><p><strong>Un programador no debe necesitar saber cómo está implementada una función para poder usarla</strong>.</p></li>
<li><p>Eso es lo que ocurre, por ejemplo, con las funciones predefinidas del lenguaje (como <code>max</code>, <code>abs</code> o <code>len</code>): sabemos <em>qué</em> hacen pero no necesitamos saber <em>cómo</em> lo hacen.</p></li>
<li><p>Incluso puede que el usuario de una función no sea el mismo que la haya escrito, sino que la puede haber recibido de otro programador como una «<strong>caja negra</strong>», que tiene unas entradas y una salida pero no se sabe cómo funciona por dentro.</p></li>
</ul>
</section>
<section id="especificaciones-de-funciones" class="title-slide slide level3" data-number="4.2.1">
<h3 data-number="4.2.1"><span class="header-section-number">4.2.1</span> Especificaciones de funciones</h3>
<ul>
<li><p>Para poder <strong>usar una abstracción funcional</strong> <em>nos basta</em> con conocer su <em>especificación</em>, porque es la descripción de qué hace esa función.</p></li>
<li><p>Igualmente, para poder <strong>implementar una abstracción funcional</strong> <em>necesitamos</em> conocer su <em>especificación</em>, ya que necesitamos saber <em>qué tiene que hacer</em> la función antes de diseñar <em>cómo va a hacerlo</em>.</p></li>
<li><p>La especificación de una abstracción funcional está formada por tres propiedades fundamentales:</p>
<ul>
<li><p>El <strong>dominio</strong>: el conjunto de argumentos válidos.</p></li>
<li><p>El <strong>rango</strong>: el conjunto de posibles valores que devuelve.</p></li>
<li><p>El <strong>propósito</strong>: qué hace la función, es decir, la relación entre su entrada y su salida.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.1.0.1">

<ul>
<li><p>Hasta ahora, al especificar <strong>programas</strong>, hemos llamado «<strong>entrada</strong>» al dominio y hemos agrupado el rango y el propósito en una sola propiedad que hemos llamado «<strong>salida</strong>».</p></li>
<li><p>Por ejemplo, cualquier función <code>cuadrado</code> que usemos para implementar <code>area</code> debe satisfacer esta especificación:</p>
<p><span class="math display">\begin{cases}
  \text{\textbf{Entrada}}: n \in \mathbb{R} \\
  \texttt{cuadrado} \\
  \text{\textbf{Salida}}: n^2
\end{cases}</span></p></li>
<li><p>La especificación <strong>no concreta cómo</strong> se debe llevar a cabo el propósito. Esos son <strong>detalles de implementación</strong> que se abstraen a este nivel.</p></li>
<li><p>Este esquema es el que hemos usado hasta ahora para especificar programas, y se podría seguir usando para especificar funciones, ya que éstas son consideradas <em>subprogramas</em>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.1.0.2">

<ul>
<li><p>Pero para especificar una función, en cambio, resulta más adecuado usar el siguiente esquema, al que llamaremos <strong>especificación funcional</strong>:</p>
<p><span class="math display">\begin{cases}
  \text{\textbf{Pre}}: True \\
  \texttt{cuadrado(}n: \texttt{float) -&gt; float} \\
  \text{\textbf{Post}}: \texttt{cuadrado(}n\texttt{)} = n^2
\end{cases}</span></p></li>
<li><p>«<strong>Pre</strong>» representa la <strong>precondición</strong>: la propiedad que debe cumplirse justo <em>en el momento</em> de llamar a la función.</p></li>
<li><p>«<strong>Post</strong>» representa la <strong>postcondición</strong>: la propiedad que debe cumplirse justo <em>después</em> de llamar a la función.</p></li>
<li><p>Lo que hay en medio es la <strong>signatura</strong>: el nombre de la función, el nombre y tipo de sus parámetros y el tipo del valor de retorno.</p></li>
<li><p>La especificación se lee así: «<em>si se llama a la función respetando su signatura y cumpliendo su precondición, la llamada termina cumpliendo su postcondición</em>».</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.1.0.3">

<ul>
<li><p>En este caso, la <strong>precondición</strong> es <span class="math inline">True</span>, que equivale a decir que cualquier condición de entrada es buena para usar la función.</p></li>
<li><p>Dicho de otra forma: no hace falta que se dé ninguna condición especial para usar la función. Siempre que la llamada respete la signatura de la función, el parámetro <span class="math inline">n</span> puede tomar cualquier valor de tipo <code>float</code> y no hay ninguna restricción adicional.</p></li>
<li><p>Por otro lado, la <strong>postcondición</strong> dice que al llamar a la función <code>cuadrado</code> con el argumento <span class="math inline">n</span> se debe devolver <span class="math inline">n^2</span>.</p></li>
<li><p>Tanto la precondición como la postcondición son <strong>predicados</strong>, es decir, expresiones lógicas que se escriben usando el lenguaje de las matemáticas y la lógica.</p></li>
<li><p>La <strong>signatura</strong> se escribe usando la sintaxis del lenguaje de programación que se vaya a usar para implementar la función (Python, en este caso).</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.1.0.4">

<ul>
<li><p>Las pre y postcondiciones no es necesario escribirlas de una manera <strong>formal y rigurosa</strong>, usando el lenguaje de las Matemáticas o la Lógica.</p></li>
<li><p>Si la especificación se escribe en <em>lenguaje natural</em> y se entiende bien, completamente y sin ambigüedades, no hay problema.</p></li>
<li><p>El motivo de usar un lenguaje formal es que, normalmente, resulta <strong>mucho más conciso y preciso que el lenguaje natural</strong>.</p></li>
<li><p>El lenguaje natural suele ser:</p>
<ul>
<li><p><strong>Más prolijo</strong>: necesita más palabras para decir lo mismo que diríamos matemáticamente usando menos caracteres.</p></li>
<li><p><strong>Más ambiguo</strong>: lo que se dice en lenguaje natural se puede interpretar de distintas formas.</p></li>
<li><p><strong>Menos completo</strong>: quedan flecos y situaciones especiales que no se tienen en cuenta.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.1.0.5">

<ul>
<li><p>Otro ejemplo más completo:</p>
<p><span class="math display">\begin{cases}
  \text{\textbf{Pre}}: car \mathrel{\char`≠} \text{\texttt{&quot;&quot;}} \land \texttt{len(}car\texttt{)} = 1 \\
  \texttt{cuenta(}cadena: \texttt{str,}\ car: \texttt{str) -&gt; int} \\
  \text{\textbf{Post}}: \texttt{cuenta(}cadena\texttt{,}\ car\texttt{)} \geq 0\ \land \\
  \hspace{2.8em}        \texttt{cuenta(}cadena\texttt{,}\ car\texttt{)} = cadena\texttt{.count(}car\texttt{)}
\end{cases}</span></p></li>
<li><p><code>count</code> es una <strong>función <em>oculta</em> o <em>auxiliar</em></strong> (en este caso, un <em>método auxiliar</em>). Las funciones auxiliares se puede usar en la especificación siempre que estén perfectamente especificadas, aunque no estén implementadas.</p></li>
<li><p>Con esto estamos diciendo que <code>cuenta</code> es una función que recibe una cadena y un carácter (otra cadena con un único carácter dentro).</p></li>
<li><p>Además, estamos diciendo que devuelve el mismo resultado que devuelve el método <code>count</code> (que casualmente ya existe en Python).</p></li>
<li><p>Es decir: cuenta el número de veces que el carácter <span class="math inline">car</span> aparece en <span class="math inline">cadena</span>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.1.0.6">

<ul>
<li><p>En realidad, las condiciones de la especificación anterior se podrían simplificar aprovechando las propiedades de las expresiones lógicas, quedando así:</p>
<p><span class="math display">\begin{cases}
  \text{\textbf{Pre}}: \texttt{len(}car\texttt{)} = 1 \\
  \texttt{cuenta(}cadena: \texttt{str,}\ car: \texttt{str) -&gt; int} \\
  \text{\textbf{Post}}: \texttt{cuenta(}cadena\texttt{,}\ car\texttt{)} = cadena\texttt{.count(}car\texttt{)}
\end{cases}</span></p></li>
</ul>
</section>
<section id="ejercicio-1" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejercicio</h5>
<ol start="2" class="example" type="1">
<li>¿Por qué?</li>
</ol>
</section>
<section class="slide level5" data-number="4.2.1.0.7">

<ul>
<li><p>Finalmente, podríamos escribir la misma especificación en lenguaje natural:</p>
<p><span class="math display">\begin{cases}
  \text{\textbf{Pre}}: car \text{ debe ser un único carácter} \\
  \texttt{cuenta(}cadena: \texttt{str,}\  car: \texttt{str) -&gt; int} \\
  \text{\textbf{Post}}: \texttt{cuenta(}cadena\texttt{,}\ car\texttt{)} \text{ devuelve el número de veces } \\
  \hspace{2.55em}          \text{ que aparece el carácter } car \text{ en la cadena } cadena. \\
  \hspace{2.55em}          \text{ Si } cadena \text{ es vacía o } car \text{ no aparece nunca en la } \\
  \hspace{2.55em}          \text{ cadena } cadena \text{, debe devolver } 0.
\end{cases}</span></p></li>
<li><p>Probablemente resulta más fácil de leer (sobre todo para los novatos), pero también es más largo y prolijo.</p></li>
<li><p>Es como un contrato escrito por un abogado en lenguaje jurídico.</p></li>
</ul>
<!--

- Un ejemplo mucho más avanzado para los curiosos:

  $$\begin{cases}
    \text{\textbf{Pre}}: lista \mathrel{\char`≠} \texttt{[]} \\
    suma\ (lista: \texttt{List[}T\texttt{]}) \text{ -> } T \\
    \text{\textbf{Post}}: suma(lista) = sum(lista)
  \end{cases}$$

- $sum$ es una función auxiliar.

- `List[`$T$`]` es un tipo genérico que pertenece al módulo `typing` y que se
  puede utilizar para indicar el tipo de una lista cuyos elementos son todos
  del tipo $T$.

- Con esto estamos diciendo que `suma` es una función que recibe una lista no
  vacía de elementos de un determinado tipo y que devuelve un resultado de ese
  mismo tipo.

- Para más información, consultar:

  - [https://docs.python.org/3/library/typing.html](https://docs.python.org/3/library/typing.html)

  - [https://www.python.org/dev/peps/pep-0484/](https://www.python.org/dev/peps/pep-0484/)
-->
</section>

</section>
<section>
<section id="computabilidad" class="title-slide slide level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Computabilidad</h1>

</section>
<section id="funciones-y-procesos" class="title-slide slide level2" data-number="5.1">
<h2 data-number="5.1"><span class="header-section-number">5.1</span> Funciones y procesos</h2>
<ul>
<li><p>Los <strong>procesos</strong> son entidades abstractas que habitan los ordenadores.</p></li>
<li><p>Conforme van evolucionando, los procesos manipulan otras entidades abstractas llamadas <strong>datos</strong>.</p></li>
<li><p>La evolución de un proceso está dirigida por un patrón de reglas llamado <strong>programa</strong>.</p></li>
<li><p>Los programadores crean programas para <strong>dirigir</strong> a los procesos.</p></li>
<li><p>Es como decir que los programadores son magos que invocan a los espíritus del ordenador (los procesos) con sus conjuros (los programas) escritos en un lenguaje mágico (el lenguaje de programación).</p></li>
</ul>
</section>
<section class="slide level5" data-number="5.1.0.0.1">

<ul>
<li><p>Una <strong>función</strong> describe la <em>evolución local</em> de un <strong>proceso</strong>, es decir, cómo se debe comportar el proceso durante la ejecución de la función.</p></li>
<li><p>En cada paso de la ejecución se calcula el <em>siguiente estado</em> del proceso basándonos en el estado actual y en las reglas definidas por la función.</p></li>
<li><p>Nos gustaría ser capaces de visualizar y de realizar afirmaciones sobre el comportamiento global del proceso cuya evolución local está definida por la función.</p></li>
<li><p>Esto, en general, es muy difícil, pero al menos vamos a describir algunos de los modelos típicos de evolución de los procesos.</p></li>
</ul>
</section>

<section id="funciones-ad-hoc" class="title-slide slide level2" data-number="5.2">
<h2 data-number="5.2"><span class="header-section-number">5.2</span> Funciones <em>ad-hoc</em></h2>
<ul>
<li><p>Supongamos que queremos diseñar una función llamada <code>permutas</code> que reciba un número entero <span class="math inline">n</span> y que calcule cuántas permutaciones distintas podemos hacer con <span class="math inline">n</span> elementos.</p></li>
<li><p>Por ejemplo: si tenemos 3 elementos (digamos, <em>A</em>, <em>B</em> y <em>C</em>), podemos formar con ellos las siguientes permutaciones:</p>
<p><span class="math display">ABC, ACB, BAC, BCA, CAB, CBA</span></p>
<p>y, por tanto, con 3 elementos podemos formar 6 permutaciones distintas. En consecuencia, <code>permutas(3)</code> debe devolver <code>6</code>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="5.2.0.0.1">

<ul>
<li><p>La implementación de esa función deberá satisfacer la siguiente especificación:</p>
<p><span class="math display">\begin{cases}
  \text{\textbf{Pre}}: n \geq 0 \\
  \texttt{permutas(}n: \texttt{int) -&gt; int} \\
  \text{\textbf{Post}}: \texttt{permutas(}n\texttt{)} = \text{el número de permutaciones que} \\
  \hspace{10.5em} \text{podemos formar con } n \text{ elementos}
\end{cases}</span></p></li>
</ul>
</section>
<section class="slide level5" data-number="5.2.0.0.2">

<ul>
<li><p>Un programador con poca idea de programación (o muy listillo) se podría plantear una implementación parecida a la siguiente:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>permutas <span class="op">=</span> <span class="kw">lambda</span> n: <span class="dv">0</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">1</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span> <span class="cf">else</span> <span class="dv">2</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">2</span> <span class="cf">else</span> ...</span></code></pre></div>
<p>que se puede escribir mejor usando la barra invertida (<code>\</code>) para poder separar una instrucción en varias líneas:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>permutas <span class="op">=</span> <span class="kw">lambda</span> n: <span class="dv">0</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="op">\</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>                     <span class="dv">1</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span> <span class="cf">else</span> <span class="op">\</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>                     <span class="dv">2</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">2</span> <span class="cf">else</span> <span class="op">\</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>                     <span class="dv">6</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">3</span> <span class="cf">else</span> <span class="op">\</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>                     <span class="dv">24</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">4</span> <span class="cf">else</span> <span class="op">\</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>                     ...                    <span class="co"># sigue y sigue</span></span></code></pre></div></li>
<li><p>Pero este algoritmo en realidad es <em>tramposo</em>, porque no calcula nada, sino que se limita a asociar el dato de entrada con el de salida, que se ha tenido que calcular previamente usando otro procedimiento.</p></li>
<li><p>Este tipo de algoritmos se denominan <strong>algoritmos <em>ad-hoc</em></strong>, y las funciones que los implementan se denominan <strong>funciones <em>ad-hoc</em></strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="5.2.0.0.3">

<ul>
<li><p>Las funciones <em>ad-hoc</em> <strong>no son convenientes</strong> porque:</p>
<ul>
<li><p>Realmente son <strong>tramposos</strong> (no calculan nada).</p></li>
<li><p><strong>No son útiles</strong>, porque al final el cálculo se tiene que hacer con otra cosa.</p></li>
<li><p>Generalmente resulta <strong>imposible</strong> que una función de este tipo abarque todos los posibles datos de entrada, ya que, en principio, puede haber <strong>infinitos</strong> y, por tanto, su código fuente también tendría que ser infinito.</p></li>
</ul></li>
</ul>
<div class="caja centered">
<p><strong>Usar algoritmos y funciones <em>ad-hoc</em> se penaliza en esta asignatura.</strong></p>
</div>
</section>

<section id="funciones-recursivas" class="title-slide slide level2" data-number="5.3">
<h2 data-number="5.3"><span class="header-section-number">5.3</span> Funciones recursivas</h2>

</section>
<section id="definición" class="title-slide slide level3" data-number="5.3.1">
<h3 data-number="5.3.1"><span class="header-section-number">5.3.1</span> Definición</h3>
<ul>
<li><p>Una <strong>función recursiva</strong> es aquella que se define en términos de sí misma.</p></li>
<li><p>Eso quiere decir que, durante la ejecución de una llamada a la función, tenemos que ejecutar otra llamada a la misma función.</p></li>
<li><p>En general, eso ocurre cuando la definición de la función contiene una o varias referencias a ella misma y, por tanto, la función se llama a sí misma dentro de su cuerpo.</p></li>
<li><p>Las definiciones recursivas son el mecanismo básico para ejecutar <strong>repeticiones de instrucciones</strong> en un lenguaje de programación funcional.</p></li>
</ul>
</section>
<section class="slide level5" data-number="5.3.1.0.1">

<ul>
<li><p>Por ejemplo: <span class="math display">f(n) = n + f(n + 1)</span></p></li>
<li><p>Esta función matemática es <em>recursiva</em> porque aparece ella misma en su propia definición.</p>
<p>Para calcular el valor de <span class="math inline">f(n)</span> tenemos que volver a utilizar la propia función <span class="math inline">f</span>.</p></li>
<li><p>Por ejemplo: <span class="math display">f(1) = 1 + f(2) = 1 + 2 + f(3) = 1 + 2 + 3 + f(4) = \ldots</span></p></li>
<li><p>Cada vez que una función se llama a sí misma decimos que se realiza una <strong>llamada recursiva</strong> o <strong>paso recursivo</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="5.3.1.0.2">

<div class="centered">
<p><img data-src="images/pintura-recursiva.jpg" class="plain" style="width:100.0%" /></p>
</div>
</section>
<section id="ejercicio-2" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejercicio</h5>
<ol start="3" class="example" type="1">
<li>Desde el principio del curso ya hemos estado trabajando con estructuras que pueden tener una definición recursiva. ¿Cuáles son?</li>
</ol>
</section>

<section id="casos-base-y-casos-recursivos" class="title-slide slide level3" data-number="5.3.2">
<h3 data-number="5.3.2"><span class="header-section-number">5.3.2</span> Casos base y casos recursivos</h3>
<ul>
<li><p>Resulta importante que una definición recursiva se detenga alguna vez y proporcione un resultado, ya que si no, no sería útil (tendríamos lo que se llama una <strong>recursión infinita</strong>).</p></li>
<li><p>Por tanto, en algún momento, la recursión debe alcanzar un punto en el que la función no se llame a sí misma y se detenga.</p></li>
<li><p>Para ello, es necesario que la función, en cada paso recursivo, se vaya acercando cada vez más a ese punto.</p></li>
</ul>
</section>
<section class="slide level5" data-number="5.3.2.0.1">

<ul>
<li><p>Ese punto en el que la función recursiva <strong>no se llama a sí misma</strong>, se denomina <strong>caso base</strong>, y puede haber más de uno.</p></li>
<li><p>Los casos base, por tanto, determinan bajo qué condiciones la función no se llamará a sí misma, o dicho de otra forma, con qué valores de sus argumentos la función devolverá directamente un valor y no provocará una nueva llamada recursiva.</p></li>
<li><p>Los demás casos, que sí provocan llamadas recursivas, se denominan <strong>casos recursivos</strong>.</p></li>
</ul>
</section>

<section id="el-factorial" class="title-slide slide level3" data-number="5.3.3">
<h3 data-number="5.3.3"><span class="header-section-number">5.3.3</span> El factorial</h3>
<ul>
<li><p>El ejemplo más típico de función recursiva es el <strong>factorial</strong>.</p></li>
<li><p>El factorial de un número natural <span class="math inline">n</span> se representa por <span class="math inline">n!</span> y se define como el producto de todos los números desde 1 hasta <span class="math inline">n</span>: <span class="math display">n! = n\cdot(n-1)\cdot(n-2)\cdot\ldots\cdot1</span></p>
<p>Por ejemplo: <span class="math display">6! = 6\cdot5\cdot4\cdot3\cdot2\cdot1 = 720</span></p></li>
<li><p>Pero para calcular <span class="math inline">6!</span> también se puede calcular <span class="math inline">5!</span> y después multiplicar el resultado por 6, ya que: <span class="math display">6! = 6\cdot\overbrace{5\cdot4\cdot3\cdot2\cdot1}^{5!}</span> <span class="math display">6! = 6\cdot5!</span></p></li>
<li><p>Por tanto, el factorial se puede definir de forma <strong>recursiva</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="5.3.3.0.1">

<ul>
<li><p>Tenemos el <strong>caso recursivo</strong>, pero necesitamos al menos un <strong>caso base</strong> para evitar que la recursión se haga <em>infinita</em>.</p></li>
<li><p>El caso base del factorial se obtiene sabiendo que el factorial de 0 es directamente 1 (no hay que llamar al factorial recursivamente): <span class="math display">0! = 1</span></p></li>
<li><p>Combinando ambos casos tendríamos:</p>
<p><span class="math display">n! = \left\{\begin{array}{ll}
         1 &amp; \text{si } n = 0 \text{\quad(caso base)} \\[4pt]
         n\cdot(n-1)! &amp; \text{si } n &gt; 0 \text{\quad(caso recursivo)}
       \end{array}\right.</span></p></li>
</ul>
</section>
<section class="slide level5" data-number="5.3.3.0.2">

<ul>
<li><p>La <strong>especificación</strong> de una función que calcule el factorial de un número sería:</p>
<p><span class="math display">\begin{cases}
  \text{\textbf{Pre}}: n \geq 0 \\
  \texttt{factorial(}n: \texttt{int) -&gt; int} \\
  \text{\textbf{Post}}: \texttt{factorial(}n\texttt{)} = n!
\end{cases}</span></p></li>
<li><p>Y su <strong>implementación</strong> en Python podría ser la siguiente:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>factorial <span class="op">=</span> <span class="kw">lambda</span> n: <span class="dv">1</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> n <span class="op">*</span> factorial(n <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div>
<p>que sería prácticamente una traducción literal de la definición recursiva de factorial que acabamos de obtener.</p></li>
</ul>
</section>

<section id="diseño-de-funciones-recursivas" class="title-slide slide level3" data-number="5.3.4">
<h3 data-number="5.3.4"><span class="header-section-number">5.3.4</span> Diseño de funciones recursivas</h3>
<ul>
<li><p>El diseño de funciones recursivas se basa en:</p>
<ul>
<li><p>Pensamiento optimista</p></li>
<li><p>Descomposición (reducción) del problema</p></li>
<li><p>Identificación de problemas no reducibles (mínimos)</p></li>
</ul></li>
</ul>
</section>
<section id="pensamiento-optimista" class="title-slide slide level4" data-number="5.3.4.1">
<h4 data-number="5.3.4.1"><span class="header-section-number">5.3.4.1</span> Pensamiento optimista</h4>
<ul>
<li><p>Consiste en suponer que la función deseada ya existe y es capaz de resolver ejemplares más pequeños del problema (este paso se denomina <strong>hipótesis inductiva</strong>).</p></li>
<li><p>Se trata de encontrar el patrón común de forma que resolver el problema principal implique el mismo patrón en un problema más pequeño.</p></li>
<li><p>Ejemplo:</p>
<ul>
<li><p>Queremos diseñar una función que calcule el factorial de un número.</p></li>
<li><p>Para ello, supongamos que ya contamos con una función que calcula el factorial de un número más pequeño. Tenemos que creer y confiar en que es así, aunque ahora mismo no sea verdad.</p>
<p>Es decir: si queremos calcular el factorial de <span class="math inline">n</span>, suponemos que tenemos ya una función <em>fact</em> que no sabe calcular el factorial de <span class="math inline">n</span>, pero sí el de <span class="math inline">(n - 1)</span>. <em>Ésta es nuestra hipótesis inductiva</em>.</p></li>
</ul></li>
</ul>
</section>

<section id="descomposición-del-problema" class="title-slide slide level4" data-number="5.3.4.2">
<h4 data-number="5.3.4.2"><span class="header-section-number">5.3.4.2</span> Descomposición del problema</h4>
<ul>
<li><p>Reducimos el problema de forma que así tendremos un ejemplar más pequeño del mismo problema y, por tanto, podremos usar la función <em>fact</em> anterior para poder resolver ese ejemplar más pequeño.</p></li>
<li><p>A continuación, usamos dicha solución <em>parcial</em> para obtener la solución al problema original.</p></li>
<li><p>Ejemplo:</p>
<ul>
<li><p>Sabemos que <span class="math inline">n! = n\cdot(n - 1)!</span></p></li>
<li><p>Sabemos que la función <span class="math inline">fact</span> sabe calcular el factorial de <span class="math inline">(n - 1)</span> (por pensamiento optimista).</p></li>
<li><p>Por tanto, lo único que tenemos que hacer para obtener el factorial de <span class="math inline">n</span> es multiplicar <span class="math inline">n</span> por el resultado de <span class="math inline">fact(n - 1)</span>.</p>
<div class="caja">
<p>Dicho de otra forma: <strong><em>si yo supiera</em> calcular el factorial de <span class="math inline">(n - 1)</span>, me bastaría con multiplicarlo por <span class="math inline">n</span> para obtener el factorial de <span class="math inline">n</span></strong>.</p>
</div></li>
</ul></li>
</ul>
</section>

<section id="identificación-de-problemas-no-reducibles" class="title-slide slide level4" data-number="5.3.4.3">
<h4 data-number="5.3.4.3"><span class="header-section-number">5.3.4.3</span> Identificación de problemas no reducibles</h4>
<ul>
<li><p>Debemos identificar los ejemplares más pequeños (los que no se pueden reducir más) para los cuales hay una solución explícita y directa que no necesita recursividad: los <em>casos base</em>.</p></li>
<li><p>Es importante comprobar que la reducción que le hemos realizado al problema en el paso anterior produce ejemplares que están más cerca del caso base.</p></li>
<li><p>Ejemplo:</p>
<ul>
<li><p>En nuestro caso, sabemos que <span class="math inline">0! = 1</span>, por lo que nuestra función podría devolver directamente <span class="math inline">1</span> cuando se le pida calcular el factorial de <span class="math inline">0</span>.</p></li>
<li><p>Además, en la reducción obtenida en el paso anterior, pasamos de calcular el factorial de <span class="math inline">n</span> a calcular el factorial de uno menos, con lo cual, cada vez estaremos más cerca del caso base, que es el factorial de 0. Al final siempre acabaremos alcanzando el caso base.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="5.3.4.3.1">

<ul>
<li>Combinando todos los pasos, obtenemos la solución general:</li>
</ul>
<p><span class="math display">fact(n) = \left\{\begin{array}{ll}
         1 &amp; \text{si } n = 0 \text{\quad(caso base)} \\[4pt]
         n\cdot fact(n-1) &amp; \text{si } n &gt; 0 \text{\quad(caso recursivo)}
       \end{array}\right.</span></p>
</section>


<section id="recursividad-lineal" class="title-slide slide level3" data-number="5.3.5">
<h3 data-number="5.3.5"><span class="header-section-number">5.3.5</span> Recursividad lineal</h3>
<ul>
<li><p>Una función tiene <strong>recursividad lineal</strong> si cada llamada a la función recursiva genera, como mucho, otra llamada recursiva a la misma función.</p></li>
<li><p>El factorial definido en el ejemplo anterior es un caso típico de recursividad lineal.</p></li>
</ul>
</section>
<section id="procesos-lineales-recursivos" class="title-slide slide level4" data-number="5.3.5.1">
<h4 data-number="5.3.5.1"><span class="header-section-number">5.3.5.1</span> Procesos lineales recursivos</h4>
<ul>
<li><p>La forma más directa y sencilla de definir una función que calcule el factorial de un número a partir de su definición recursiva podría ser la siguiente:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>factorial <span class="op">=</span> <span class="kw">lambda</span> n: <span class="dv">1</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> n <span class="op">*</span> factorial(n <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div></li>
<li><p>Utilizaremos el modelo de sustitución para observar el funcionamiento de esta función al calcular <span class="math inline">6!</span>:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>factorial(<span class="dv">6</span>)</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> factorial(<span class="dv">5</span>))</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> factorial(<span class="dv">4</span>)))</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> factorial(<span class="dv">3</span>))))</span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">*</span> factorial(<span class="dv">2</span>)))))</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">*</span> (<span class="dv">2</span> <span class="op">*</span> factorial(<span class="dv">1</span>))))))</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">*</span> (<span class="dv">2</span> <span class="op">*</span> (<span class="dv">1</span> <span class="op">*</span> factorial(<span class="dv">0</span>)))))))</span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">*</span> (<span class="dv">2</span> <span class="op">*</span> (<span class="dv">1</span> <span class="op">*</span> <span class="dv">1</span>))))))</span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">*</span> (<span class="dv">2</span> <span class="op">*</span> <span class="dv">1</span>)))))</span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">*</span> <span class="dv">2</span>))))</span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> <span class="dv">6</span>)))</span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> <span class="dv">24</span>))</span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> <span class="dv">120</span>)</span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">720</span></span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="5.3.5.1.1">

<ul>
<li><p>Podemos observar un perfil de <strong>expansión</strong> seguido de una <strong>contracción</strong>:</p>
<ul>
<li><p>La <strong>expansión</strong> ocurre conforme el proceso construye una secuencia de operaciones a realizar <em>posteriormente</em> (en este caso, una secuencia de multiplicaciones).</p></li>
<li><p>La <strong>contracción</strong> se realiza conforme se van ejecutando realmente las multiplicaciones.</p></li>
</ul></li>
<li><p>Llamaremos <strong>proceso recursivo</strong> a este tipo de proceso caracterizado por una secuencia de <strong>operaciones pendientes de completar</strong>.</p></li>
<li><p>Para poder ejecutar este proceso, el intérprete necesita <strong>memorizar</strong>, en algún lugar, un registro de las multiplicaciones que se han dejado para más adelante.</p></li>
<li><p>En el cálculo de <span class="math inline">n!</span>, la longitud de la secuencia de operaciones pendientes (y, por tanto, la información que necesita almacenar el intérprete), crece <em>linealmente</em> con <span class="math inline">n</span>, al igual que el número de pasos de reducción.</p>
<ul>
<li>A este tipo de procesos lo llamaremos <strong>proceso recursivo <em>lineal</em></strong>.</li>
</ul></li>
</ul>
</section>

<section id="procesos-lineales-iterativos" class="title-slide slide level4" data-number="5.3.5.2">
<h4 data-number="5.3.5.2"><span class="header-section-number">5.3.5.2</span> Procesos lineales iterativos</h4>
<ul>
<li><p>A continuación adoptaremos un enfoque diferente.</p></li>
<li><p>Podemos mantener un producto acumulado y un contador desde <span class="math inline">n</span> hasta 1, de forma que el contador y el producto cambien de un paso al siguiente según la siguiente regla:</p>
<p><span class="math display">\begin{array}{l}
    acumulado_{nuevo} = acumulado_{viejo} \cdot contador_{viejo} \\[4pt]
    contador_{nuevo} = contador_{viejo} - 1
  \end{array}</span></p></li>
<li><p>Su traducción a Python podría ser la siguiente, usando una función auxiliar <code>fact_iter</code>:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>fact_iter <span class="op">=</span> <span class="kw">lambda</span> cont, acc: acc <span class="cf">if</span> cont <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="op">\</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>                              fact_iter(cont <span class="op">-</span> <span class="dv">1</span>, cont <span class="op">*</span> acc)</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>factorial <span class="op">=</span> <span class="kw">lambda</span> n: fact_iter(n, <span class="dv">1</span>)</span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="5.3.5.2.1">

<ul>
<li><p>Al igual que antes, usaremos el modelo de sustitución para visualizar el proceso del cálculo de <span class="math inline">6!</span>:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>factorial(<span class="dv">6</span>)</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> fact_iter(<span class="dv">6</span>, <span class="dv">1</span>)</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> fact_iter(<span class="dv">5</span>, <span class="dv">6</span>)</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> fact_iter(<span class="dv">4</span>, <span class="dv">30</span>)</span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> fact_iter(<span class="dv">3</span>, <span class="dv">120</span>)</span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> fact_iter(<span class="dv">2</span>, <span class="dv">360</span>)</span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> fact_iter(<span class="dv">1</span>, <span class="dv">720</span>)</span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> fact_iter(<span class="dv">0</span>, <span class="dv">720</span>)</span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">720</span></span></code></pre></div></li>
<li><p>Este proceso no tiene expansiones ni contracciones ya que, en cada instante, toda la información que se necesita almacenar es el valor actual de los parámetros <code>cont</code> y <code>acc</code>, por lo que el tamaño de la memoria necesaria es constante.</p></li>
<li><p>A este tipo de procesos lo llamaremos <strong>proceso iterativo</strong>.</p></li>
<li><p>El número de pasos necesarios para calcular <span class="math inline">n!</span> usando esta función crece <em>linealmente</em> con <span class="math inline">n</span>.</p>
<ul>
<li>A este tipo de procesos lo llamaremos <strong>proceso iterativo <em>lineal</em></strong>.</li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="5.3.5.2.2">

<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 37%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Tipo de proceso</th>
<th style="text-align: left;">Número de reducciones</th>
<th style="text-align: left;">Memoria necesaria</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Recursivo</td>
<td style="text-align: left;">Proporcional a <span class="math inline">\underline{n}</span></td>
<td style="text-align: left;">Proporcional a <span class="math inline">\underline{n}</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Iterativo</td>
<td style="text-align: left;">Proporcional a <span class="math inline">\underline{n}</span></td>
<td style="text-align: left;">Constante</td>
</tr>
</tbody>
</table>
<p><br>* * *<br></p>
<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 36%" />
<col style="width: 36%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Tipo de proceso</th>
<th style="text-align: left;">Número de reducciones</th>
<th style="text-align: left;">Memoria necesaria</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Recursivo lineal</td>
<td style="text-align: left;">Linealmente<br />
proporcional a <span class="math inline">\underline{n}</span></td>
<td style="text-align: left;">Linealmente<br />
proporcional a <span class="math inline">\underline{n}</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Iterativo lineal</td>
<td style="text-align: left;">Linealmente<br />
proporcional a <span class="math inline">\underline{n}</span></td>
<td style="text-align: left;">Constante</td>
</tr>
</tbody>
</table>
</section>
<section class="slide level5" data-number="5.3.5.2.3">

<ul>
<li><p>En general, un <strong>proceso iterativo</strong> es aquel que está definido por una serie de <strong>coordenadas de estado</strong> junto con una <strong>regla</strong> fija que describe cómo actualizar dichas variables conforme cambia el proceso de un estado al siguiente.</p></li>
<li><p>La <strong>diferencia entre los procesos recursivo e iterativo</strong> se puede describir de esta otra manera:</p>
<ul>
<li><p>En el <strong>proceso iterativo</strong>, los parámetros dan una descripción completa del estado del proceso en cada instante.</p>
<p>Así, si parásemos el cálculo entre dos pasos, lo único que necesitaríamos hacer para seguir con el cálculo es darle al intérprete el valor de los dos parámetros.</p></li>
<li><p>En el <strong>proceso recursivo</strong>, el intérprete tiene que mantener cierta información <em>oculta</em> que no está almacenada en ningún parámetro y que indica en qué punto se encuentra el proceso dentro de la secuencia de operaciones pendientes.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="5.3.5.2.4">

<ul>
<li><p>No debe confundirse un <strong>proceso recursivo</strong> con una <strong>función recursiva</strong>:</p>
<ul>
<li><p>Cuando hablamos de <em>función recursiva</em> nos referimos al hecho sintáctico de que la definción de la función hace referencia a sí misma (directa o indirectamente).</p></li>
<li><p>Cuando hablamos de <em>proceso recursivo</em> nos referimos a la forma en como se desenvuelve la ejecución de la función.</p></li>
</ul></li>
<li><p>Puede parecer extraño que digamos que una función recursiva (por ejemplo, <code>fact_iter</code>) genera un proceso iterativo.</p>
<p>Sin embargo, el proceso es realmente iterativo porque su estado está definido completamente por dos variables ligadas, y para ejecutar el proceso sólo se necesita almacenar esas dos variables.</p></li>
</ul>
</section>
<section class="slide level5" data-number="5.3.5.2.5">

<ul>
<li><p>Aquí hemos visto un ejemplo donde se aprecia claramente que <strong>una función sólo puede tener una especificación</strong> pero <strong>puede tener varias implementaciones</strong> distintas.</p></li>
<li><p>Eso sí: todas las implementaciones de una función deben satisfacer su especificación.</p></li>
<li><p>En este caso, las dos implementaciones son:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>factorial <span class="op">=</span> <span class="kw">lambda</span> n: <span class="dv">1</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> n <span class="op">*</span> factorial(n <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div>
<p>y</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>fact_iter <span class="op">=</span> <span class="kw">lambda</span> cont, acc: acc <span class="cf">if</span> cont <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="op">\</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>                              fact_iter(cont <span class="op">-</span> <span class="dv">1</span>, cont <span class="op">*</span> acc)</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>factorial <span class="op">=</span> <span class="kw">lambda</span> n: fact_iter(n, <span class="dv">1</span>)</span></code></pre></div></li>
<li><p>Y aunque las dos satisfacen la misma especificación y, por tanto, calculan exactamente los mismos valores, lo hacen de una forma muy diferente, generando incluso procesos de distinto tipo.</p></li>
</ul>
</section>


<section id="recursividad-en-árbol" class="title-slide slide level3" data-number="5.3.6">
<h3 data-number="5.3.6"><span class="header-section-number">5.3.6</span> Recursividad en árbol</h3>
<ul>
<li><p>La <strong>recursividad en árbol</strong> se produce cuando la función tiene <strong>recursividad múltiple</strong>.</p></li>
<li><p>Una función tiene <strong>recursividad múltiple</strong> cuando una llamada a la función recursiva puede generar más de una llamada recursiva a la misma función.</p></li>
<li><p>El ejemplo clásico es la función que calcula los términos de la <strong>sucesión de Fibonacci</strong>.</p></li>
<li><p>La sucesión comienza con los números 0 y 1, y a partir de éstos, cada término es la suma de los dos anteriores:</p>
<p>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, …</p></li>
</ul>
</section>
<section class="slide level5" data-number="5.3.6.0.1">

<ul>
<li><p>Podemos definir una función recursiva que devuelva el <span class="math inline">n</span>-ésimo término de la sucesión de Fibonacci:</p>
<p><span class="math display">fib(n) = \left\{\begin{array}{ll}
             0 &amp; \text{si } n = 0 \text{\quad (caso base)} \\[4pt]
             1 &amp; \text{si } n = 1 \text{\quad (caso base)} \\[4pt]
             fib(n - 1) + fib(n - 2) &amp; \text{si } n &gt; 1 \text{\quad (caso recursivo)}
           \end{array}\right.</span></p></li>
</ul>
</section>
<section class="slide level5" data-number="5.3.6.0.2">

<ul>
<li><p>La especificación de una función que devuelva el <span class="math inline">n</span>-ésimo término de la sucesión de Fibonacci sería:</p>
<p><span class="math display">\begin{cases}
  \text{\textbf{Pre}}: n \geq \\
  \texttt{fib(}n: \texttt{int) -&gt; int} \\
  \text{\textbf{Post}}: \texttt{fib(}n\texttt{)} = \text{el } n\text{-ésimo término de la sucesión de Fibonacci}
\end{cases}</span></p></li>
<li><p>Y su implementación en Python podría ser:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>fib <span class="op">=</span> <span class="kw">lambda</span> n: <span class="dv">0</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">1</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span> <span class="cf">else</span> fib(n <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> fib(n <span class="op">-</span> <span class="dv">2</span>)</span></code></pre></div>
<p>o bien:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>fib <span class="op">=</span> <span class="kw">lambda</span> n: <span class="dv">0</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="op">\</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>                <span class="dv">1</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span> <span class="cf">else</span> <span class="op">\</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>                fib(n <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> fib(n <span class="op">-</span> <span class="dv">2</span>)</span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="5.3.6.0.3">

<ul>
<li><p>Si vemos el perfil de ejecución de <code>fib(5)</code>, vemos que:</p>
<ul>
<li><p>Para calcular <code>fib(5)</code>, antes debemos calcular <code>fib(4)</code> y <code>fib(3)</code>.</p></li>
<li><p>Para calcular <code>fib(4)</code>, antes debemos calcular <code>fib(3)</code> y <code>fib(2)</code>.</p></li>
<li><p>Así sucesivamente hasta poner todo en función de <code>fib(0)</code> y <code>fib(1)</code>, que se pueden calcular directamente (son los casos base).</p></li>
</ul></li>
<li><p>En general, el proceso resultante parece un árbol.</p></li>
</ul>
</section>
<section class="slide level5" data-number="5.3.6.0.4">

<div class="centered">
<p><img data-src="images/arbol-fibonacci.svg" class="plain" style="width:80.0%" /></p>
</div>
</section>
<section class="slide level5" data-number="5.3.6.0.5">

<ul>
<li><p>La función anterior es un buen ejemplo de recursión en árbol, pero desde luego es un método <em>horrible</em> para calcular los números de Fibonacci, por la cantidad de <strong>operaciones redundantes</strong> que efectúa.</p></li>
<li><p>Para tener una idea de lo malo que es, se puede observar que <span class="math inline">fib(n)</span> crece exponencialmente en función de <span class="math inline">n</span>.</p></li>
<li><p>Por lo tanto, el proceso necesita una cantidad de tiempo que crece <strong>exponencialmente</strong> con <span class="math inline">n</span>.</p></li>
<li><p>Por otro lado, el espacio necesario sólo crece <strong>linealmente</strong> con <span class="math inline">n</span>, porque en un cierto momento del cálculo sólo hay que memorizar los nodos que hay por encima.</p></li>
<li><p>En general, en un proceso recursivo en árbol el tiempo de ejecución crece con el número de nodos mientras que el espacio necesario crece con la altura máxima del árbol.</p></li>
</ul>
</section>
<section class="slide level5" data-number="5.3.6.0.6">

<ul>
<li><p>Se puede construir un <strong>proceso iterativo</strong> para calcular los números de Fibonacci.</p></li>
<li><p>La idea consiste en usar dos coordenadas de estado <em>a</em> y <em>b</em> (con valores iniciales 1 y 0, respectivamente) y aplicar repetidamente la siguiente transformación:</p>
<p><span class="math display">\begin{array}{l}
    a_{nuevo} = a_{viejo} + b_{viejo} \\[4pt]
    b_{nuevo} = a_{viejo}
  \end{array}</span></p></li>
<li><p>Después de <span class="math inline">n</span> pasos, <em>a</em> y <em>b</em> contendrán, respectivamente, <span class="math inline">fib(n + 1)</span> y <span class="math inline">fib(n)</span>.</p></li>
<li><p>En Python sería:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>fib_iter <span class="op">=</span> <span class="kw">lambda</span> cont, a, b: b <span class="cf">if</span> cont <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> fib_iter(cont <span class="op">-</span> <span class="dv">1</span>, a <span class="op">+</span> b, a)</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>fib <span class="op">=</span> <span class="kw">lambda</span> n: fib_iter(n, <span class="dv">1</span>, <span class="dv">0</span>)</span></code></pre></div></li>
<li><p>Esta función genera un proceso iterativo lineal, por lo que es mucho más eficiente.</p></li>
</ul>
</section>


<section id="la-pila-de-control" class="title-slide slide level2" data-number="5.4">
<h2 data-number="5.4"><span class="header-section-number">5.4</span> La pila de control</h2>
<ul>
<li><p>La <strong>pila de control</strong> es una estructura de datos que utiliza el intérprete para llevar la cuenta de las <strong>llamadas <em>activas</em></strong> en un determinado momento, incluyendo el valor de sus parámetros y el punto de retorno al que debe devolverse el control cuando finalice la ejecución de la función.</p>
<ul>
<li>Las <strong>llamadas activas</strong> son aquellas llamadas a funciones que aún no han terminado de ejecutarse.</li>
</ul></li>
<li><p>La pila de control es, básicamente, un <strong>almacén de marcos</strong>.</p></li>
<li><p>Cada vez que se hace una nueva llamada a una función, <strong>su marco</strong> correspondiente <strong>se almacena en la cima de la pila</strong> sobre los demás marcos que pudiera haber.</p></li>
<li><p>Ese marco es el primero de la secuencia de marcos que forman el entorno de la función, que estarán almacenados más abajo en la pila.</p></li>
<li><p>Los marcos se enlazan entre sí para representar los entornos que actúan en las distintas llamadas activas.</p></li>
</ul>
</section>
<section class="slide level5" data-number="5.4.0.0.1">

<ul>
<li><p>El intérprete puede, además, almacenar ahí cualquier otra información que necesite para gestionar las llamadas a funciones.</p></li>
<li><p>El marco de la función, junto con toda esa información adicional, se denomina <strong>registro de activación</strong>.</p></li>
<li><p>Por tanto, <strong>la pila de control almacena registros de activación</strong>.</p></li>
<li><p>Cada llamada activa está representada por su correspondiente registro de activación en la pila, y cada registro de activación va asociado a un marco.</p></li>
<li><p>En cuanto la llamada finaliza, su registro de activación se saca de la pila y se transfiere el control a la llamada que está inmediatamente debajo (si es que hay alguna).</p></li>
<li><p>Cuando desaparece un registro de activación, también se elimina de la memoria su marco asociado (hay una excepción a esto, que veremos en posteriores temas cuando hablemos de las <em>clausuras</em>).</p></li>
</ul>
</section>
<section id="ejemplos" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejemplos</h5>
<div class="sourceCode" id="cb62"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>uno <span class="op">=</span> <span class="kw">lambda</span> x: <span class="dv">1</span> <span class="op">+</span> dos(<span class="dv">2</span> <span class="op">*</span> x, <span class="dv">4</span>)</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>dos <span class="op">=</span> <span class="kw">lambda</span> y, z: tres(y <span class="op">+</span> z <span class="op">+</span> g)</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>tres <span class="op">=</span> <span class="kw">lambda</span> w: <span class="st">&quot;W vale &quot;</span> <span class="op">+</span> <span class="bu">str</span>(w)</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>uno(<span class="dv">3</span>)</span></code></pre></div>
<div class="centered">
<figure>
<img data-src="images/pila-control.svg" class="plain" style="width:60.0%" alt="Pila de control con la función tres activada" /><figcaption aria-hidden="true">Pila de control con la función <code>tres</code> activada</figcaption>
</figure>
</div>
</section>
<section class="slide level5" data-number="5.4.0.0.2">

<ul>
<li><p>Del análisis del diagrama del ejemplo anterior se pueden deducir las siguientes conclusiones:</p>
<ul>
<li><p>En un momento dado, dentro del ámbito global se ha llamado a la función <code>uno</code>, la cual ha llamado a la función <code>dos</code>, la cual ha llamado a la función <code>tres</code>, la cual aún no ha terminado de ejecutarse.</p></li>
<li><p>El entorno en la función <code>uno</code> empieza por el marco de <code>uno</code>, el cual apunta al marco global.</p></li>
<li><p>El entorno en la función <code>dos</code> empieza por el marco de <code>dos</code>, el cual apunta al marco global.</p></li>
<li><p>El entorno en la función <code>tres</code> empieza por el marco de <code>tres</code>, el cual apunta al marco global.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="5.4.0.0.3">

<ul>
<li><p>Si tenemos ámbitos anidados, los marcos se apuntarán entre sí en el entorno. Por ejemplo:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>uno <span class="op">=</span> <span class="kw">lambda</span> x: dos(x <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>dos <span class="op">=</span> <span class="kw">lambda</span> y: <span class="dv">1</span> <span class="op">+</span> (<span class="kw">lambda</span> z: z <span class="op">*</span> <span class="dv">2</span>)(y <span class="op">**</span> <span class="dv">3</span>)</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>uno(<span class="dv">3</span>)</span></code></pre></div></li>
</ul>
<div class="centered">
<figure>
<img data-src="images/pila-control-ambitos-anidados.svg" class="plain" style="width:90.0%" alt="Pila de control con ámbitos anidados y la función dos activada" /><figcaption aria-hidden="true">Pila de control con ámbitos anidados y la función <code>dos</code> activada</figcaption>
</figure>
</div>
</section>
<section class="slide level5" data-number="5.4.0.0.4">

<ul>
<li><p>Hemos dicho que habrá un registro de activación por cada nueva llamada que se realice a una función, y que ese registro se mantendrá en la pila hasta que la llamada finalice.</p></li>
<li><p>Por tanto, en el caso de una función recursiva, tendremos un registro de activación por cada llamada recursiva.</p></li>
</ul>
<div class="sourceCode" id="cb64"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>fact <span class="op">=</span> <span class="kw">lambda</span> n: <span class="dv">1</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> n <span class="op">*</span> fact(n <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>fact(<span class="dv">4</span>)</span></code></pre></div>
<div class="centered">
<figure>
<img data-src="images/pila-control-factorial.svg" class="plain" style="width:60.0%" alt="Pila de control de fact tras tres activaciones desde fact(4)" /><figcaption aria-hidden="true">Pila de control de <code>fact</code> tras tres activaciones desde <code>fact(4)</code></figcaption>
</figure>
</div>
</section>

<section id="un-lenguaje-turing-completo" class="title-slide slide level2" data-number="5.5">
<h2 data-number="5.5"><span class="header-section-number">5.5</span> Un lenguaje Turing-completo</h2>
<ul>
<li><p>El paradigma funcional que hemos visto hasta ahora (uno que nos permite definir funciones, componer dichas funciones y aplicar recursividad, junto con el operador ternario condicional) es un lenguaje de programación <strong>completo</strong>.</p></li>
<li><p>Decimos que es <strong>Turing completo</strong>, lo que significa que puede computar cualquier función que pueda computar una máquina de Turing.</p></li>
<li><p>Como las máquinas de Turing son los ordenadores más potentes que podemos construir (ya que describen lo que cualquier ordenador es capaz de hacer), esto significa que nuestro lenguaje puede calcular todo lo que pueda calcular cualquier ordenador.</p></li>
</ul>
</section>
</section>
<section>
<section id="tipos-de-datos-recursivos" class="title-slide slide level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Tipos de datos recursivos</h1>

</section>
<section id="cadenas" class="title-slide slide level2" data-number="6.1">
<h2 data-number="6.1"><span class="header-section-number">6.1</span> Cadenas</h2>
<ul>
<li><p>Las <strong>cadenas</strong> se pueden considerar <strong>estructuras de datos recursivas</strong>, ya que podemos decir que toda cadena <code>c</code>:</p>
<ul>
<li><p>o bien es la cadena vacía <code>''</code> (<em>caso base</em>),</p></li>
<li><p>o bien está formada por dos partes:</p>
<ul>
<li><p>El <strong>primer carácter</strong> de la cadena, al que se accede mediante <code>c[0]</code> (y que es en Python es una cadena de longitud 1).</p></li>
<li><p>El <strong>resto</strong> de la cadena (al que se accede mediante <code>c[1:]</code>), que también es una cadena (<em>caso recursivo</em>).</p></li>
</ul></li>
</ul></li>
<li><p>Eso significa que podemos acceder al segundo carácter de la cadena (suponiendo que exista) mediante <code>c[1:][0]</code>.</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>cadena <span class="op">=</span> <span class="st">&#39;hola&#39;</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>cadena[<span class="dv">0</span>]       <span class="co"># devuelve &#39;h&#39;</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>cadena[<span class="dv">1</span>:]      <span class="co"># devuelve &#39;ola&#39;</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>cadena[<span class="dv">1</span>:][<span class="dv">0</span>]   <span class="co"># devuelve &#39;o&#39;</span></span></code></pre></div></li>
</ul>
</section>

<section id="tuplas" class="title-slide slide level2" data-number="6.2">
<h2 data-number="6.2"><span class="header-section-number">6.2</span> Tuplas</h2>
<ul>
<li><p>Las <strong>tuplas</strong> son una generalización de las cadenas.</p></li>
<li><p>Una tupla es una <strong>secuencia de elementos</strong> que no tienen por qué ser caracteres, sino que cada uno de ellos pueden ser <strong>de cualquier tipo</strong> (números, cadenas, booleanos, …, incluso otras tuplas).</p></li>
<li><p>Los literales de tipo tupla se representan enumerando sus elementos separados por comas y encerrados entre paréntesis.</p></li>
<li><p>Por ejemplo:</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>tupla <span class="op">=</span> (<span class="dv">27</span>, <span class="st">&#39;hola&#39;</span>, <span class="va">True</span>, <span class="fl">73.4</span>, (<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>), <span class="dv">99</span>)</span></code></pre></div></li>
<li><p>Si sólo tiene un elemento, hay que poner una coma detrás:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>tupla <span class="op">=</span> (<span class="dv">35</span>,)</span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="6.2.0.0.1">

<ul>
<li><p>Las tuplas también pueden verse como un <strong>tipo de datos recursivo</strong>, ya que toda tupla <code>t</code>:</p>
<ul>
<li><p>o bien es la tupla vacía, representada mediante <code>()</code> (<em>caso base</em>),</p></li>
<li><p>o bien está formada por dos partes:</p>
<ul>
<li><p>El <strong>primer elemento</strong> de la tupla (al que se accede mediante <code>t[0]</code>), que hemos visto que puede ser de cualquier tipo.</p></li>
<li><p>El <strong>resto</strong> de la tupla (al que se accede mediante <code>t[1:]</code>), que también es una tupla (<em>caso recursivo</em>).</p></li>
</ul></li>
</ul></li>
<li><p>Según el ejemplo anterior:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>tupla <span class="op">=</span> (<span class="dv">27</span>, <span class="st">&#39;hola&#39;</span>, <span class="va">True</span>, <span class="fl">73.4</span>, (<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>), <span class="dv">99</span>)</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>tupla[<span class="dv">0</span>]       <span class="co"># devuelve 27</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>tupla[<span class="dv">1</span>:]      <span class="co"># devuelve (&#39;hola&#39;, True, 73.4, (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;), 99)</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>tupla[<span class="dv">1</span>:][<span class="dv">0</span>]   <span class="co"># devuelve &#39;hola&#39;</span></span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="6.2.0.0.2">

<ul>
<li><p>Junto a las operaciones <code>t[0]</code> (primer elemento de la tupla) y <code>t[1:]</code> (resto de la tupla), tenemos también la operación <code>+</code> (<strong>concatenación</strong>), al igual que ocurre con las cadenas.</p></li>
<li><p>Con la concatenación se pueden crear nuevas tuplas a partir de otras tuplas.</p></li>
<li><p>Por ejemplo:</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>) <span class="op">+</span> (<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>)  <span class="co"># devuelve (1, 2, 3, 4, 5, 6)</span></span></code></pre></div></li>
</ul>
</section>

<section id="rangos" class="title-slide slide level2" data-number="6.3">
<h2 data-number="6.3"><span class="header-section-number">6.3</span> Rangos</h2>
<ul>
<li><p>Un rango es un tipo de dato cuyos valores representan <strong>sencuencias de números enteros</strong>.</p></li>
<li><p>Los rangos se crean con la función <code>range</code>, cuya signatura es:</p>
<div class="caja">
<p><code>range(</code>[<em>start</em><code>,</code>] <em>stop</em> [<code>,</code> <em>step</em>]<code>)</code></p>
</div></li>
<li><p><em>start</em>, <em>stop</em> y <em>step</em> deben ser números enteros.</p></li>
<li><p>Cuando se omite <em>start</em>, se entiende que es <code>0</code>.</p></li>
<li><p>El valor de <em>stop</em> no se alcanza nunca.</p></li>
<li><p>Cuando <em>start</em> y <em>stop</em> son iguales, representa el <em>rango vacío</em>.</p></li>
<li><p>Cuando <em>start</em> es mayor que <em>stop</em>, el valor de <em>step</em> debería ser negativo. En caso contrario, también representaría el rango vacío.</p></li>
</ul>
</section>
<section id="ejemplos-1" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejemplos</h5>
<ul>
<li><p><code>range(10)</code> representa la secuencia <span class="math inline">0, 1, 2, \ldots, 9</span>.</p></li>
<li><p><code>range(3, 10)</code> representa la secuencia <span class="math inline">3, 4, 5, \ldots, 9</span>.</p></li>
<li><p><code>range(0, 10, 2)</code> representa la secuencia <span class="math inline">0, 2, 4, 6, 8</span>.</p></li>
<li><p><code>range(4, 0, -1)</code> representa la secuencia <span class="math inline">4, 3, 2, 1</span>.</p></li>
<li><p><code>range(3, 3)</code> representa el rango vacío.</p></li>
<li><p><code>range(4, 3)</code> también representa el rango vacío.</p></li>
</ul>
</section>
<section class="slide level5" data-number="6.3.0.0.1">

<ul>
<li><p>Los rangos también pueden verse como un <strong>tipo de datos recursivo</strong>, ya que todo rango <code>r</code>:</p>
<ul>
<li><p>o bien es el rango vacío (<em>caso base</em>),</p></li>
<li><p>o bien está formado por dos partes:</p>
<ul>
<li><p>El <strong>primer elemento</strong> del rango (al que se accede mediante <code>r[0]</code>), que hemos visto que tiene que ser un número entero.</p></li>
<li><p>El <strong>resto</strong> del rango (al que se accede mediante <code>r[1:]</code>), que también es un rango (<em>caso recursivo</em>).</p></li>
</ul></li>
</ul></li>
<li><p>Según el ejemplo anterior:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>rango <span class="op">=</span> <span class="bu">range</span>(<span class="dv">4</span>, <span class="dv">7</span>)</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>rango[<span class="dv">0</span>]       <span class="co"># devuelve 4</span></span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>rango[<span class="dv">1</span>:]      <span class="co"># devuelve range(5, 7)</span></span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>rango[<span class="dv">1</span>:][<span class="dv">0</span>]   <span class="co"># devuelve 5</span></span></code></pre></div></li>
</ul>
</section>

<section id="conversión-a-tupla" class="title-slide slide level2" data-number="6.4">
<h2 data-number="6.4"><span class="header-section-number">6.4</span> Conversión a tupla</h2>
<ul>
<li>Las cadenas y los rangos se pueden convertir fácilmente a tuplas usando la función <code>tuple</code>:</li>
</ul>
<div class="columns">
<div class="column" style="width:40%;">
<div class="sourceCode" id="cb71"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">tuple</span>(<span class="st">&#39;hola&#39;</span>)</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>(<span class="st">&#39;h&#39;</span>, <span class="st">&#39;o&#39;</span>, <span class="st">&#39;l&#39;</span>, <span class="st">&#39;a&#39;</span>)</span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">tuple</span>(<span class="st">&#39;&#39;</span>)</span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a>()</span></code></pre></div>
</div><div class="column" style="width:60%;">
<div class="sourceCode" id="cb72"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">tuple</span>(<span class="bu">range</span>(<span class="dv">10</span>))</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>)</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">tuple</span>(<span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">11</span>))</span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">10</span>)</span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">tuple</span>(<span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">30</span>, <span class="dv">5</span>))</span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a>(<span class="dv">0</span>, <span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">15</span>, <span class="dv">20</span>, <span class="dv">25</span>)</span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">tuple</span>(<span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">3</span>))</span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a>(<span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">6</span>, <span class="dv">9</span>)</span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">tuple</span>(<span class="bu">range</span>(<span class="dv">0</span>, <span class="op">-</span><span class="dv">10</span>, <span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true" tabindex="-1"></a>(<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">3</span>, <span class="op">-</span><span class="dv">4</span>, <span class="op">-</span><span class="dv">5</span>, <span class="op">-</span><span class="dv">6</span>, <span class="op">-</span><span class="dv">7</span>, <span class="op">-</span><span class="dv">8</span>, <span class="op">-</span><span class="dv">9</span>)</span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">tuple</span>(<span class="bu">range</span>(<span class="dv">0</span>))</span>
<span id="cb72-12"><a href="#cb72-12" aria-hidden="true" tabindex="-1"></a>()</span>
<span id="cb72-13"><a href="#cb72-13" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">tuple</span>(<span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">0</span>))</span>
<span id="cb72-14"><a href="#cb72-14" aria-hidden="true" tabindex="-1"></a>()</span></code></pre></div>
</div>
</div>
</section>
</section>
<section>
<section id="funciones-de-orden-superior" class="title-slide slide level1" data-number="7">
<h1 data-number="7"><span class="header-section-number">7</span> Funciones de orden superior</h1>

</section>
<section id="concepto" class="title-slide slide level2" data-number="7.1">
<h2 data-number="7.1"><span class="header-section-number">7.1</span> Concepto</h2>
<ul>
<li><p>Hemos visto que <strong>las funciones son</strong>, en realidad, <strong>abstracciones</strong> en la medida en que nos permiten usarlas sin tener que conocer los detalles internos del procesamiento que realizan.</p></li>
<li><p>Por ejemplo, si queremos usar la función <code>cubo</code>, nos da igual que dicha función esté implementada de cualquiera de las siguientes maneras:</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>cubo <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> x <span class="op">*</span> x</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>cubo <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">**</span> <span class="dv">3</span></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>cubo <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> x <span class="op">**</span> <span class="dv">2</span></span></code></pre></div></li>
<li><p>Para <strong>usar</strong> la función, nos basta con saber que calcula el cubo de un número, sin necesidad de saber qué cálculo concreto realiza para obtener el resultado. Los detalles de implementación quedan ocultos y por eso también decimos que <code>cubo</code> es una abstracción.</p></li>
</ul>
</section>
<section class="slide level5" data-number="7.1.0.0.1">

<ul>
<li><p>Las funciones también son abstracciones porque describen operaciones compuestas a realizar sobre ciertos valores sin importar cuáles sean esos valores en concreto.</p></li>
<li><p>Por ejemplo, cuando definimos:</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>cubo <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> x <span class="op">*</span> x</span></code></pre></div>
<p>no estamos hablando del cubo de un número en particular, sino más bien de un <strong>método</strong> para calcular el cubo de un número.</p></li>
<li><p>Por supuesto, nos la podemos arreglar sin definir el cubo, escribiendo siempre expresiones explícitas (como <code>3*3*3</code>, <code>y*y*y</code>, etc.) sin usar la palabra «cubo», pero eso nos obligaría siempre a expresarnos usando las operaciones primitivas de nuestro lenguaje (como <code>*</code>), en vez de poder usar términos de más alto nivel.</p>
<p>Es decir: <strong>nuestros programas podrían calcular el cubo de un número, pero no tendrían la habilidad de expresar el concepto de <em>elevar al cubo</em></strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="7.1.0.0.2">

<ul>
<li><p>Una de las habilidades que deberíamos pedir a un lenguaje potente es la posibilidad de <strong>construir abstracciones</strong> asignando un nombre a los patrones más comunes, y luego trabajar directamente usando dichas abstracciones.</p></li>
<li><p>Las funciones nos permiten esta habilidad y esa es la razón de que todos los lenguajes (salvo los más primitivos) incluyan mecanismos para definir funciones.</p></li>
<li><p>Por ejemplo: en el caso anterior, vemos que hay un patrón (multiplicar algo por sí mismo tres veces) que se repite con frecuencia, y a partir de él construimos una abstracción que asigna un nombre a ese patrón (<em>elevar al cubo</em>). Esa abstracción la definimos como una función que describe la <em>regla</em> necesaria para elevar algo al cubo.</p></li>
</ul>
</section>
<section class="slide level5" data-number="7.1.0.0.3">

<ul>
<li><p>Muchas veces observamos el mismo patrón en funciones muy diferentes.</p></li>
<li><p>Para poder abstraer, de nuevo, lo que tienen en común dichas funciones, deberíamos ser capaces de manejar funciones que acepten a otras funciones como argumentos o que devuelvan otra función como resultado.</p></li>
<li><p>A estas funciones que manejan otras funciones las llamaremos <strong>funciones de orden superior</strong>.</p></li>
<li><p>Una función de orden superior es una función que recibe funciones como argumento o devuelve funciones como resultado.</p></li>
</ul>
</section>
<section class="slide level5" data-number="7.1.0.0.4">

<ul>
<li><p>Por ejemplo, la siguiente función <strong>recibe otra función como argumento</strong> y devuelve el resultado de aplicar dicha función al número 5:</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> aplica5 <span class="op">=</span> <span class="kw">lambda</span> f: f(<span class="dv">5</span>)</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> cuadrado <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> cubo <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">**</span> <span class="dv">3</span></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> aplica5(cuadrado)</span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a><span class="dv">25</span></span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> aplica5(cubo)</span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a><span class="dv">125</span></span></code></pre></div></li>
<li><p>No hace falta crear las funciones <code>cuadrado</code> y <code>cubo</code> para pasárselas a la función <code>aplica5</code> como argumento. Se pueden pasar directamente las expresiones lambda, que también son funciones:</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> aplica5(<span class="kw">lambda</span> x: x <span class="op">**</span> <span class="dv">2</span>)</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a><span class="dv">25</span></span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> aplica5(<span class="kw">lambda</span> x: x <span class="op">**</span> <span class="dv">3</span>)</span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a><span class="dv">125</span></span></code></pre></div></li>
<li><p>Naturalmente, la función que se pasa a <code>aplica5</code> debe recibir un único argumento de tipo numérico.</p></li>
</ul>
</section>
<section class="slide level5" data-number="7.1.0.0.5">

<ul>
<li><p>También se puede <strong>devolver una función como resultado</strong>.</p></li>
<li><p>Por ejemplo, la siguiente función recibe un número (<code>k</code>) y devuelve otra función que calcula la suma de ese número con otro (<code>x</code>) que se pasa como argumento a la función devuelta:</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> suma_rara <span class="op">=</span> <span class="kw">lambda</span> k: <span class="kw">lambda</span> x: x <span class="op">+</span> k</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> suma2 <span class="op">=</span> suma_rara(<span class="dv">2</span>)</span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> suma2(<span class="dv">3</span>)</span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a><span class="dv">5</span></span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> suma7 <span class="op">=</span> suma_rara(<span class="dv">7</span>)</span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> suma7(<span class="dv">8</span>)</span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a><span class="dv">15</span></span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> suma_rara(<span class="dv">4</span>)(<span class="dv">6</span>)</span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true" tabindex="-1"></a><span class="dv">10</span></span></code></pre></div></li>
<li><p>Tanto <code>aplica5</code> como <code>suma_rara</code> son funciones de orden superior.</p></li>
</ul>
</section>
<section class="slide level5" data-number="7.1.0.0.6">

<ul>
<li><p>Ahora supongamos las dos funciones siguientes:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Suma los enteros comprendidos entre a y b:</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>suma_enteros <span class="op">=</span> <span class="kw">lambda</span> a, b: <span class="dv">0</span> <span class="cf">if</span> a <span class="op">&gt;</span> b <span class="cf">else</span> a <span class="op">+</span> suma_enteros(a <span class="op">+</span> <span class="dv">1</span>, b)</span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Suma los cubos de los enteros comprendidos entre a y b:</span></span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>suma_cubos <span class="op">=</span> <span class="kw">lambda</span> a, b: <span class="dv">0</span> <span class="cf">if</span> a <span class="op">&gt;</span> b <span class="cf">else</span> cubo(a) <span class="op">+</span> suma_enteros(a <span class="op">+</span> <span class="dv">1</span>, b)</span></code></pre></div></li>
<li><p>Estas dos funciones comparten claramente un patrón común. Se diferencian solamente en:</p>
<ul>
<li><p>El <em>nombre</em> de la función.</p></li>
<li><p>La función que se aplica a <code>a</code> para calcular cada <em>término</em> de la suma.</p></li>
</ul></li>
<li><p>Podríamos haber escrito las funciones anteriores rellenando los «casilleros» del siguiente <em>patrón general</em>:</p>
<div class="line-block"><span style="color:teal">⟨<em>nombre</em>⟩</span> = <strong><code>lambda</code></strong> a, b: 0 <strong><code>if</code></strong> a &gt; b <strong><code>else</code></strong> <span style="color:teal">⟨<em>término</em>⟩</span>(a) + <span style="color:teal">⟨<em>nombre</em>⟩</span>(a + 1, b)</div></li>
</ul>
</section>
<section class="slide level5" data-number="7.1.0.0.7">

<ul>
<li><p>La existencia de este patrón común nos demuestra que hay una abstracción esperando que la saquemos a la superficie.</p></li>
<li><p>De hecho, los matemáticos han identificado hace mucho tiempo esta abstracción llamándola <strong>sumatorio de una serie</strong>, y la expresan así: <span class="math display"> \sum _ {n=a}^b f(n)</span></p>
<p>La ventaja que tiene usar la notación anterior es que podemos trabajar directamente con el concepto de sumatorio en vez de trabajar con sumas concretas, y podemos sacar conclusiones generales sobre los sumatorios independientemente de la serie particular con la que estemos trabajando.</p></li>
<li><p>Igualmente, como programadores estamos interesados en que nuestro lenguaje tenga la suficiente potencia como para describir directamente el concepto de sumatorio, en vez de funciones particulares que calculen sumas concretas.</p></li>
</ul>
</section>
<section class="slide level5" data-number="7.1.0.0.8">

<ul>
<li><p>En programación funcional lo conseguimos creando funciones que conviertan los «casilleros» en parámetros:</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>suma <span class="op">=</span> <span class="kw">lambda</span> term, a, b: <span class="dv">0</span> <span class="cf">if</span> a <span class="op">&gt;</span> b <span class="cf">else</span> term(a) <span class="op">+</span> suma(term, a <span class="op">+</span> <span class="dv">1</span>, b)</span></code></pre></div></li>
<li><p>De esta forma, las dos funciones <code>suma_enteros</code> y <code>suma_cubos</code> anteriores se podrían definir en términos de esta <code>suma</code>:</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a>suma_enteros <span class="op">=</span> <span class="kw">lambda</span> a, b: suma(<span class="kw">lambda</span> x: x, a, b)</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>suma_cubos <span class="op">=</span> <span class="kw">lambda</span> a, b: suma(<span class="kw">lambda</span> x: x <span class="op">*</span> x <span class="op">*</span> x, a, b)</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a><span class="co"># O mejor aún:</span></span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>suma_cubos <span class="op">=</span> <span class="kw">lambda</span> a, b: suma(cubo, a, b)</span></code></pre></div></li>
<li><p>¿Se podría generalizar aún más la función <code>suma</code>?</p></li>
</ul>
</section>

<section id="map" class="title-slide slide level2" data-number="7.2">
<h2 data-number="7.2"><span class="header-section-number">7.2</span> <code>map</code></h2>
<ul>
<li>Supongamos que queremos escribir una función que, dada una tupla de números, nos devuelva otra tupla con los mismos números elevados al cubo.</li>
</ul>
</section>
<section id="ejercicio-3" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejercicio</h5>
<ol start="4" class="example" type="1">
<li>Inténtalo.</li>
</ol>
</section>
<section class="slide level5" data-number="7.2.0.0.1">

<ul>
<li><p>Una forma de hacerlo sería:</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a>elevar_cubo <span class="op">=</span> <span class="kw">lambda</span> t: () <span class="cf">if</span> t <span class="op">==</span> () <span class="cf">else</span> <span class="op">\</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>                        (cubo(t[<span class="dv">0</span>]),) <span class="op">+</span> elevar_cubo(t[<span class="dv">1</span>:])</span></code></pre></div></li>
<li><p>¿Y elevar a la cuarta potencia?</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>elevar_cuarta <span class="op">=</span> <span class="kw">lambda</span> t: () <span class="cf">if</span> t <span class="op">==</span> () <span class="cf">else</span> <span class="op">\</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>                          ((<span class="kw">lambda</span> x: x <span class="op">**</span> <span class="dv">4</span>)(t[<span class="dv">0</span>]),) <span class="op">+</span> elevar_cuarta(t[<span class="dv">1</span>:])</span></code></pre></div></li>
<li><p>Es evidente que hay un patrón subyacente que se podría abstraer creando una función de orden superior que aplique una función <code>f</code> a los elementos de una tupla y devuelva la tupla resultante.</p></li>
</ul>
</section>
<section class="slide level5" data-number="7.2.0.0.2">

<ul>
<li><p>Esa función se llama <code>map</code>, y viene definida en Python con la siguiente signatura:</p>
<div class="caja">
<p><code>map(</code><em>func</em><code>,</code> <em>iterable</em><code>)</code></p>
</div>
<p>donde:</p>
<ul>
<li><p><em>func</em> debe ser una función de un solo argumento.</p></li>
<li><p><em>iterable</em> puede ser cualquier cosa compuesta de elementos que se puedan recorrer de uno en uno, como una <strong>tupla</strong>, una <strong>cadena</strong> o un <strong>rango</strong> (cualquier <em>secuencia</em> de elementos nos vale).</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="7.2.0.0.3">

<ul>
<li><p>Podemos usarla así:</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">map</span>(cubo, (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>))</span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span><span class="bu">map</span> <span class="bu">object</span> at <span class="bn">0x7f22b25e9d68</span><span class="op">&gt;</span></span></code></pre></div></li>
<li><p>Lo que devuelve no es una tupla, sino un objeto <strong>iterador</strong> que examinaremos con más detalle más adelante.</p></li>
<li><p>Por ahora, nos basta con saber que un iterador es un flujo de datos que se pueden recorrer de uno en uno.</p></li>
<li><p>Lo que haremos aquí será transformar ese iterador en la tupla correspondiente usando la función <code>tuple</code> sobre el resultado de <code>map</code>:</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">tuple</span>(<span class="bu">map</span>(cubo, (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>)))</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>(<span class="dv">1</span>, <span class="dv">8</span>, <span class="dv">27</span>, <span class="dv">64</span>)</span></code></pre></div></li>
<li><p>Además de una tupla, también podemos usar un rango como argumento para <code>map</code>:</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">tuple</span>(<span class="bu">map</span>(cubo, <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">5</span>)))</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>(<span class="dv">1</span>, <span class="dv">8</span>, <span class="dv">27</span>, <span class="dv">64</span>)</span></code></pre></div></li>
<li><p>¿Cómo definirías la función <code>map</code> de forma que devolviera una tupla?</p></li>
</ul>
</section>
<section id="ejercicio-4" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejercicio</h5>
<ol start="5" class="example" type="1">
<li>Inténtalo.</li>
</ol>
</section>
<section class="slide level5" data-number="7.2.0.0.4">

<ul>
<li><p>Podríamos definirla así:</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="bu">map</span> <span class="op">=</span> <span class="kw">lambda</span> f, l: () <span class="cf">if</span> l <span class="op">==</span> () <span class="cf">else</span> (f(l[<span class="dv">0</span>]),) <span class="op">+</span> <span class="bu">map</span>(f, l[<span class="dv">1</span>:])</span></code></pre></div></li>
</ul>
</section>

<section id="filter" class="title-slide slide level2" data-number="7.3">
<h2 data-number="7.3"><span class="header-section-number">7.3</span> <code>filter</code></h2>
<ul>
<li><p><code>filter</code> es una <strong>función de orden superior</strong> que devuelve aquellos elementos de una tupla (o cualquier cosa <em>iterable</em>) que cumplen una determinada condición.</p></li>
<li><p>Su signatura es:</p>
<div class="caja">
<p><code>filter(</code><em>function</em><code>,</code> <em>iterable</em><code>)</code></p>
</div>
<p>donde <em>function</em> debe ser una función de un solo argumento que devuelva un <em>booleano</em>.</p></li>
<li><p>Como <code>map</code>, también devuelve un <em>iterador</em>, que se puede convertir a tupla con la función <code>tuple</code>.</p></li>
<li><p>Por ejemplo:</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">tuple</span>(<span class="bu">filter</span>(<span class="kw">lambda</span> x: x <span class="op">&gt;</span> <span class="dv">0</span>, (<span class="op">-</span><span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="op">-</span><span class="dv">2</span>, <span class="dv">8</span>, <span class="op">-</span><span class="dv">3</span>, <span class="dv">9</span>)))</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>(<span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">8</span>, <span class="dv">9</span>)</span></code></pre></div></li>
</ul>
</section>

<section id="reduce" class="title-slide slide level2" data-number="7.4">
<h2 data-number="7.4"><span class="header-section-number">7.4</span> <code>reduce</code></h2>
<ul>
<li><p><code>reduce</code> es una <strong>función de orden superior</strong> que aplica, de forma acumulativa, una función a todos los elementos de una tupla (o cualquier cosa <em>iterable</em>).</p></li>
<li><p>Las operaciones se hacen agrupándose <strong>por la izquierda</strong>.</p></li>
<li><p>Captura un <strong>patrón muy frecuente</strong> de recursión sobre secuencias de elementos.</p></li>
</ul>
</section>
<section class="slide level5" data-number="7.4.0.0.1">

<ul>
<li><p>Por ejemplo, para calcular la suma de todos los elementos de una tupla, haríamos:</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> suma <span class="op">=</span> <span class="kw">lambda</span> l: <span class="dv">0</span> <span class="cf">if</span> l <span class="op">==</span> () <span class="cf">else</span> l[<span class="dv">0</span>] <span class="op">+</span> suma(l[<span class="dv">1</span>:])</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> suma((<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>))</span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a><span class="dv">10</span></span></code></pre></div></li>
<li><p>Y para calcular el producto:</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> producto <span class="op">=</span> <span class="kw">lambda</span> l: <span class="dv">1</span> <span class="cf">if</span> l <span class="op">==</span> () <span class="cf">else</span> l[<span class="dv">0</span>] <span class="op">*</span> producto(l[<span class="dv">1</span>:])</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> producto((<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>))</span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a><span class="dv">24</span></span></code></pre></div></li>
<li><p>Como podemos observar, la estrategia de cálculo es esencialmente la misma (sólo se diferencian en la operación a realizar (<code>+</code> o <code>*</code>) y en el valor inicial o <em>elemento neutro</em> (<code>0</code> o <code>1</code>).</p></li>
</ul>
</section>
<section class="slide level5" data-number="7.4.0.0.2">

<ul>
<li><p>Si abstraemos ese patrón común podemos crear una función de orden superior que capture la idea de <strong>reducir todos los elementos de una tupla (o cualquier iterable) a un único valor</strong>.</p></li>
<li><p>Eso es lo que hace la función <code>reduce</code>.</p></li>
<li><p>Su signatura es:</p>
<div class="caja">
<p><code>reduce(</code><em>function</em><code>,</code> <em>sequence</em> [<code>,</code> <em>initial</em> ]<code>)</code></p>
</div>
<p>donde:</p>
<ul>
<li><p><em>function</em> debe ser una función que reciba dos argumentos.</p></li>
<li><p><em>sequence</em> debe ser cualquier objeto iterable.</p></li>
<li><p><em>initial</em>, si se indica, se usará como primer elemento sobre el que realizar el cálculo y servirá como valor por defecto cuando la secuencia esté vacía (si no se indica y la secuencia está vacía, generará un error).</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="7.4.0.0.3">

<ul>
<li><p>Para usarla, tenemos que <em>importarla</em> previamente del <em>módulo</em> <code>functools</code>.</p>
<ul>
<li><p>No es la primera vez que importamos un módulo. Ya lo hicimos con el módulo <code>math</code>.</p></li>
<li><p>En su momento estudiaremos con detalle qué son los módulos. Por ahora nos basta con lo que ya sabemos: que contienen definiciones que podemos incorporar a nuestros <em>scripts</em>.</p></li>
</ul></li>
<li><p>Por ejemplo, para calcular la suma y el producto de <code>(1, 2, 3, 4)</code>:</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functools <span class="im">import</span> <span class="bu">reduce</span></span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>tupla <span class="op">=</span> (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>)</span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a>suma_de_numeros <span class="op">=</span> <span class="bu">reduce</span>(<span class="kw">lambda</span> x, y: x <span class="op">+</span> y, tupla, <span class="dv">0</span>)</span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a>producto_de_numeros <span class="op">=</span> <span class="bu">reduce</span>(<span class="kw">lambda</span> x, y: x <span class="op">*</span> y, tupla, <span class="dv">1</span>)</span></code></pre></div></li>
<li><p>¿Cómo podríamos definir la función <code>reduce</code> si recibiera una tupla y no cualquier iterable?</p></li>
</ul>
</section>
<section id="ejercicio-5" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejercicio</h5>
<ol start="6" class="example" type="1">
<li>Inténtalo.</li>
</ol>
</section>
<section class="slide level5" data-number="7.4.0.0.4">

<ul>
<li><p>Una forma (con valor inicial obligatorio) podría ser así:</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="bu">reduce</span> <span class="op">=</span> <span class="kw">lambda</span> fun, tupla, ini: ini <span class="cf">if</span> tupla <span class="op">==</span> () <span class="cf">else</span> <span class="op">\</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>                                 tupla[<span class="dv">0</span>] <span class="cf">if</span> tupla[<span class="dv">1</span>:] <span class="op">==</span> () <span class="cf">else</span> <span class="op">\</span></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>                                 fun(tupla[<span class="dv">0</span>], <span class="bu">reduce</span>(fun, tupla[<span class="dv">1</span>:], ini))</span></code></pre></div></li>
</ul>
</section>

<section id="expresiones-generadoras" class="title-slide slide level2" data-number="7.5">
<h2 data-number="7.5"><span class="header-section-number">7.5</span> Expresiones generadoras</h2>
<ul>
<li><p>Dos operaciones que se realizan con frecuencia sobre una estructura iterable son:</p>
<ul>
<li><p>Realizar alguna operación sobre cada elemento (<code>map</code>)</p></li>
<li><p>Seleccionar un subconjunto de elementos que cumplan alguna condición (<code>filter</code>)</p></li>
</ul></li>
<li><p>Las <strong>expresiones generadoras</strong> son una notación copiada del lenguaje Haskell que nos permite realizar ambas operaciones de una forma muy concisa.</p></li>
<li><p>El resultado que devuelve es un iterador que (como ya sabemos) podemos convertir fácilmente en una tupla usando la función <code>tuple</code>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="7.5.0.0.1">

<ul>
<li><p>Por ejemplo:</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">tuple</span>(x <span class="op">**</span> <span class="dv">3</span> <span class="cf">for</span> x <span class="kw">in</span> (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>))</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>(<span class="dv">1</span>, <span class="dv">8</span>, <span class="dv">27</span>, <span class="dv">64</span>)</span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a><span class="co"># equivale a:</span></span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">tuple</span>(<span class="bu">map</span>(<span class="kw">lambda</span> x: x <span class="op">**</span> <span class="dv">3</span>, (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>)))</span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a>(<span class="dv">1</span>, <span class="dv">8</span>, <span class="dv">27</span>, <span class="dv">64</span>)</span></code></pre></div>
<div class="sourceCode" id="cb93"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">tuple</span>(x <span class="cf">for</span> x <span class="kw">in</span> (<span class="op">-</span><span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="op">-</span><span class="dv">2</span>, <span class="dv">8</span>, <span class="op">-</span><span class="dv">3</span>, <span class="dv">9</span>) <span class="cf">if</span> x <span class="op">&gt;</span> <span class="dv">0</span>)</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>(<span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">8</span>, <span class="dv">9</span>)</span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a><span class="co"># equivale a:</span></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">tuple</span>(<span class="bu">filter</span>(<span class="kw">lambda</span> x: x <span class="op">&gt;</span> <span class="dv">0</span>, (<span class="op">-</span><span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="op">-</span><span class="dv">2</span>, <span class="dv">8</span>, <span class="op">-</span><span class="dv">3</span>, <span class="dv">9</span>)))</span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a>(<span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">8</span>, <span class="dv">9</span>)</span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="7.5.0.0.2">

<ul>
<li><p>Su sintaxis es:</p>
<div class="line-block"><span style="color:teal">⟨<em>expr_gen</em>⟩</span> ::= <strong><code>(</code></strong><span style="color:teal">⟨<em>expresión</em>⟩</span> (<strong><code>for</code></strong> <span style="color:teal">⟨<em>identificador</em>⟩</span> <strong><code>in</code></strong> <span style="color:teal">⟨<em>secuencia</em>⟩</span> [<strong><code>if</code></strong> <span style="color:teal">⟨<em>condición</em>⟩</span>])<span class="math inline">^+</span><strong><code>)</code></strong></div></li>
<li><p>Los elementos de la salida generada serán los sucesivos valores de <span style="color:teal">⟨<em>expresión</em>⟩</span>.</p></li>
<li><p>Las cláusulas <strong><code>if</code></strong> son opcionales. Si están, la <span style="color:teal">⟨<em>expresión</em>⟩</span> sólo se evaluará y añadirá al resultado cuando se cumpla la <span style="color:teal">⟨<em>condición</em>⟩</span>.</p></li>
<li><p>Los paréntesis <code>(</code> y <code>)</code> alrededor de la expresión generadora se pueden quitar si la expresión se usa como único argumento de una función.</p></li>
<li><p>Por ejemplo:</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> sec1 <span class="op">=</span> <span class="st">&#39;abc&#39;</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> sec2 <span class="op">=</span> (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)</span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">tuple</span>((x, y) <span class="cf">for</span> x <span class="kw">in</span> sec1 <span class="cf">for</span> y <span class="kw">in</span> sec2)</span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>((<span class="st">&#39;a&#39;</span>, <span class="dv">1</span>), (<span class="st">&#39;a&#39;</span>, <span class="dv">2</span>), (<span class="st">&#39;a&#39;</span>, <span class="dv">3</span>),</span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a> (<span class="st">&#39;b&#39;</span>, <span class="dv">1</span>), (<span class="st">&#39;b&#39;</span>, <span class="dv">2</span>), (<span class="st">&#39;b&#39;</span>, <span class="dv">3</span>),</span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a> (<span class="st">&#39;c&#39;</span>, <span class="dv">1</span>), (<span class="st">&#39;c&#39;</span>, <span class="dv">2</span>), (<span class="st">&#39;c&#39;</span>, <span class="dv">3</span>))</span></code></pre></div></li>
</ul>
</section>
</section>
<section id="bibliografía" class="title-slide slide level1 unnumbered unlisted">
<h1 class="unnumbered unlisted">Bibliografía</h1>
<div id="refs" class="references csl-bib-body hanging-indent" role="doc-bibliography">
<div id="ref-abelson_structure_1996" class="csl-entry" role="doc-biblioentry">
Abelson, Harold, Gerald Jay Sussman, and Julie Sussman. 1996. <em>Structure and Interpretation of Computer Programs</em>. 2nd ed. Cambridge, Mass. : New York: MIT Press ; McGraw-Hill.
</div>
</div>
</section>
    </div>
  </div>

  <script src="./reveal.js/dist/reveal.js"></script>

  // reveal.js plugins
  <script src="./reveal.js/plugin/notes/notes.js"></script>
  <script src="./reveal.js/plugin/search/search.js"></script>
  <script src="./reveal.js/plugin/zoom/zoom.js"></script>
  <script src="./reveal.js/plugin/reveal.js-menu/menu.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
        // Display the page number of the current slide
        slideNumber: true,
        // Push each slide change to the browser history
        history: true,
        // Transition style
        transition: 'slide', // none/fade/slide/convex/concave/zoom
        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1280,
        height: 1080,

        menu: {
          hideMissingTitles: true,
        },

        dependencies: [
          { src: './reveal.js/plugin/reveal.js-quiz/quiz/js/quiz.js', async: true, callback: function() { prepareQuizzes({preventUnanswered: true, checkAnswerText: 'Comprueba la respuesta', nextQuestionText: 'Siguiente &raquo;', backButtonText: '&laquo; Anterior', tryAgainText: 'Prueba de nuevo', preventUnansweredText: 'Selecciona una respuesta', questionCountText: 'Pregunta %current de %total', skipStartButton: true}); } }
        ],

        // reveal.js plugins
        plugins: [
          RevealMenu,
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    </body>
</html>
