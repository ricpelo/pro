<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Ricardo Pérez López">
  <title>Programación funcional II</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="shortcut icon" type="image/png" href="/assets/icons/icon.png">
  <link rel="stylesheet" href="reveal.js/css/reveal.css">
  <style type="text/css">
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #cb4b16; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #d33682; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #dc322f; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #93a1a1; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #268bd2; } /* DataType */
code span.dv { color: #d33682; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #d33682; } /* Float */
code span.fu { color: #268bd2; } /* Function */
code span.im { font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #268bd2; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #a57800; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #2aa198; } /* SpecialString */
code span.st { color: #2aa198; } /* String */
code span.va { color: #6c71c4; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="reveal.js/css/theme/solarized.css" id="theme">
  <link rel="stylesheet" href="custom.css"/>
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
    var mathElements = document.getElementsByClassName("math");
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") { katex.render(texText.data, mathElements[i], { displayMode: mathElements[i].classList.contains("display"), throwOnError: false } );
    }}});</script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css" />
  <link href="https://fonts.googleapis.com/css?family=Lato&display=swap" rel="stylesheet">
  <style type="text/css">
      #header-left {
          position: absolute;
          font-size: 25%;
          top: 0%;
          left: 0%;
          margin-left: 10px;
          margin-top: 10px;
      }
      #header-right {
          position: absolute;
          font-size: 25%;
          top: 0%;
          right: 0%;
          margin-right: 10px;
          margin-top: 10px;
      }
      #footer-left {
          position: absolute;
          font-size: 25%;
          bottom: 0%;
          left: 0%;
          margin-left: 10px;
          margin-bottom: 10px;
      }
  </style>
</head>
<body>
<div id="hidden" style="display:none;">
    <div id="header">
        <div id="header-left"></div>
        <div id="header-right"></div>
        <div id="footer-left"></div>
    </div>
</div>
<script type="text/javascript">
    document.addEventListener("DOMContentLoaded", function(event) {
        var title = document.getElementsByClassName('title')[0];
        title = title != null ? title.innerHTML : '';
        var author = document.getElementsByClassName('author')[0];
        author = author != null ? author.innerHTML : '';
        var date = document.getElementsByClassName('date')[0];
        date = date != null ? date.innerHTML : '';
        var el = document.createElement('a');
        var href = '#/title-slide';
        el.href = href;
        el.innerHTML = title;
        document.getElementById('header-left').appendChild(el);
        document.getElementById('footer-left').innerHTML = '&copy; ' + author + ' (' + date + ')';

        function updateHeader(nd) {
            var hr = document.getElementById('header-right');
            while (hr.children.length > 0) {
                hr.removeChild(hr.lastChild);
            }
            buscar(nd, 3, hr);
            buscar(nd, 2, hr);
            buscar(nd, 1, hr);
            hr.style.fontSize = Math.round(50 * Reveal.getScale()) + '%';
            hr.style.fontSize = Math.max(Number.parseInt(getComputedStyle(hr).fontSize), 12) + 'px';
            var hl = document.getElementById('header-left');
            hl.style.fontSize = hr.style.fontSize;
        }

        function buscar(nd, level, hr) {
            if (!nd.classList.contains('level' + (level - 1))) {
                for (var n = nd; n != null; n = n.previousSibling) {
                    if (n.nodeType == Node.TEXT_NODE) {
                        continue;
                    }
                    var cl = n.classList;
                    if (cl.contains('level' + level)) {
                        var h = n.querySelector('h' + level);
                    } else if (cl.contains('level' + (level - 1))) {
                        break;
                    } else {
                        continue;
                    }
                    if (h == null || Reveal.getCurrentSlide().id == 'title-slide') {
                        hr.innerHTML = '';
                    } else {
                        var el = document.createElement('a');
                        var href = '#/' + n.id;
                        el.href = href;
                        el.innerHTML = h.innerHTML;
                        var a = el.querySelector('a');
                        if (a !== null) {
                            a.href = href;
                        }
                        if (hr.innerHTML != '') {
                            hr.innerHTML = ' &mdash; ' + hr.innerHTML;
                        }
                        hr.insertBefore(el, hr.firstChild);
                    }
                    break;
                }
            }
        }

        // On Reveal.js ready event, copy header/footer <div>
        // into each `.slide-background` <div>
        Reveal.addEventListener('ready', function(event) {
            var header = document.getElementById('header');
            document.querySelector('.reveal').appendChild(header);
            updateHeader(Reveal.getCurrentSlide());
        });

        Reveal.addEventListener('slidechanged', function(event) {
            // event.previousSlide, event.currentSlide, event.indexh, event.indexv
            updateHeader(event.currentSlide);
        });
    });
</script>
  <div class="reveal">
    <div class="slides">

<section>
<section id="title-slide" class="title-slide slide level1">
  <h1 class="title">Programación funcional II</h1>
  <p class="author">Ricardo Pérez López</p>
  <p class="date">IES Doñana, curso 2019/2020</p>
</section>
<section id="TOC" class="slide level2">
<ul>
<li><a href="#/abstracciones-funcionales"><span class="toc-section-number">1</span> Abstracciones funcionales</a></li>
<li><a href="#/computabilidad"><span class="toc-section-number">2</span> Computabilidad</a></li>
<li><a href="#/tipos-de-datos-recursivos"><span class="toc-section-number">3</span> Tipos de datos recursivos</a></li>
<li><a href="#/funciones-de-orden-superior"><span class="toc-section-number">4</span> Funciones de orden superior</a></li>
<li><a href="#/bibliografía">Bibliografía</a></li>
</ul>
</section>
</section>

<section><section id="abstracciones-funcionales" class="title-slide slide level1"><h1><span class="header-section-number">1</span> Abstracciones funcionales</h1></section><section id="expresiones-lambda" class="title-slide slide level2"><h2><span class="header-section-number">1.1</span> Expresiones lambda</h2><ul>
<li><p>Las <strong>expresiones lambda</strong> (también llamadas <strong>abstracciones lambda</strong> o <strong>funciones anónimas</strong> en algunos lenguajes) son expresiones que capturan la idea abstracta de «<strong>función</strong>».</p></li>
<li><p>Son la forma más simple y primitiva de describir funciones en un lenguaje funcional.</p></li>
<li><p>Su sintaxis (simplificada) es:</p>
<div class="line-block"><span style="color:teal"><em>&lt;expr_lambda&gt;</em></span> ::= <strong><code>lambda</code></strong> [<span style="color:teal"><em>&lt;lista_parámetros&gt;</em></span>]<strong><code>:</code></strong> <span style="color:teal"><em>&lt;expresión&gt;</em></span><br />
<span style="color:teal"><em>&lt;lista_parámetros&gt;</em></span> := <span style="color:teal"><em>&lt;identificador&gt;</em></span> (<strong><code>,</code></strong> <span style="color:teal"><em>&lt;identificador&gt;</em></span>)*</div></li>
<li><p>Por ejemplo:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">lambda</span> x, y: x <span class="op">+</span> y</a></code></pre></div></li>
</ul></section><section id="parámetros-y-cuerpos" class="title-slide slide level3"><h3><span class="header-section-number">1.1.1</span> Parámetros y cuerpos</h3><ul>
<li><p>Los identificadores que aparecen entre la palabra clave <code>lambda</code> y el carácter de dos puntos (<code>:</code>) son los <strong>parámetros</strong> de la expresión lambda.</p></li>
<li><p>La expresión que aparece tras los dos puntos (<code>:</code>) es el <strong>cuerpo</strong> de la expresión lambda.</p></li>
<li><p>En el ejemplo anterior:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">lambda</span> x, y: x <span class="op">+</span> y</a></code></pre></div>
<ul>
<li><p>Los parámetros son <code>x</code> e <code>y</code>.</p></li>
<li><p>El cuerpo es <code>x + y</code>.</p></li>
<li><p>Esta expresión lambda captura la idea general de sumar dos valores (que en principio pueden ser de cualquier tipo, siempre y cuando admitan el operador <code>+</code>).</p></li>
</ul></li>
</ul></section><section id="aplicación-funcional" class="title-slide slide level3"><h3><span class="header-section-number">1.1.2</span> Aplicación funcional</h3><ul>
<li><p>De la misma manera que decíamos que podemos aplicar una función a unos argumentos, también podemos aplicar una expresión lambda a unos argumentos.</p></li>
<li><p>Recordemos que <em>aplicar</em> una función a unos argumentos produce el valor que la función asocia a esos argumentos en el conjunto imagen.</p></li>
<li><p>Por ejemplo, la aplicación de la función <span class="math inline">max</span> sobre los argumentos <span class="math inline">3</span> y <span class="math inline">5</span> se escribe como <span class="math inline">max(3, 5)</span> y eso denota el valor <span class="math inline">5</span>.</p></li>
<li><p>Igualmente, la aplicación de una expresión lambda como</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">lambda</span> x, y: x <span class="op">+</span> y</a></code></pre></div>
<p>sobre los argumentos <code>4</code> y <code>3</code> se representa así:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1">(<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>)</a></code></pre></div></li>
</ul></section><section id="llamadas-a-funciones" class="slide level4">
<h4><span class="header-section-number">1.1.2.1</span> Llamadas a funciones</h4>
<ul>
<li><p>Si hacemos la siguiente definición:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb5-1" title="1">suma <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y</a></code></pre></div>
<p>a partir de ese momento podemos usar <code>suma</code> en lugar de su valor (la expresión lambda), por lo que podemos hacer:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" title="1">suma(<span class="dv">4</span>, <span class="dv">3</span>)</a></code></pre></div>
<p>en lugar de</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb7-1" title="1">(<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>)</a></code></pre></div></li>
<li><p>Cuando aplicamos a sus argumentos una función así definida también podemos decir que estamos <strong>invocando</strong> o <strong>llamando</strong> a la función. Por ejemplo, en <code>suma(4, 3)</code> estamos <em>llamando</em> a la función <code>suma</code>, o hay una <em>llamada</em> a la función <code>suma</code>.</p></li>
</ul>
</section><section id="evaluación-de-una-aplicación-funcional" class="slide level4">
<h4><span class="header-section-number">1.1.2.2</span> Evaluación de una aplicación funcional</h4>
<ul>
<li><p>En nuestro modelo de sustitución, la <strong>evaluación de la aplicación de una expresión lambda</strong> consiste en <strong>sustituir</strong>, en el cuerpo de la expresión lambda, <strong>cada parámetro por su argumento correspondiente</strong> (por orden) y devolver la expresión resultante <em>parentizada</em> (entre paréntesis).</p></li>
<li><p>A esta operación se la denomina <strong>aplicación funcional</strong> o <strong>β-reducción</strong>.</p></li>
<li><p>Siguiendo con el ejemplo anterior:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb8-1" title="1">(<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>)</a></code></pre></div>
<p>sustituimos en el cuerpo de la expresión lambda los parámetros <code>x</code> e <code>y</code> por los argumentos <code>4</code> y <code>3</code>, respectivamente, y parentizamos la expresión resultante, lo que da:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb9-1" title="1">(<span class="dv">4</span> <span class="op">+</span> <span class="dv">3</span>)</a></code></pre></div>
<p>que simplificando (según las reglas del operador <code>+</code>) da <code>7</code>.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Lo mismo podemos hacer si definimos previamente la expresión lambda ligándola a un identificador:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb10-1" title="1">suma <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y</a></code></pre></div></li>
<li><p>Así, la aplicación de la expresión lambda resulta más fácil y clara de escribir:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb11-1" title="1">suma(<span class="dv">4</span>, <span class="dv">3</span>)</a></code></pre></div></li>
<li><p>En ambos casos, el resultado es el mismo (<code>7</code>).</p>
<div class="caja">
<p><strong>Importante:</strong></p>
<p>En <strong>Python</strong>, salvo excepciones, los operandos y los argumentos de las funciones se evalúan <strong>de izquierda a derecha</strong>.</p>
</div></li>
</ul>
</section><section id="ejemplos" class="slide level4">
<h4><span class="header-section-number">1.1.2.4</span> Ejemplos</h4>
<ul>
<li><p>Dado el siguiente código:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb12-1" title="1">suma <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y</a></code></pre></div>
<p>¿Cuánto vale la expresión siguiente?</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb13-1" title="1">suma(<span class="dv">4</span>, <span class="dv">3</span>) <span class="op">*</span> suma(<span class="dv">2</span>, <span class="dv">7</span>)</a></code></pre></div>
<p>Según el modelo de sustitución, reescribimos:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb14-1" title="1">suma(<span class="dv">4</span>,<span class="dv">3</span>) <span class="op">*</span> suma(<span class="dv">2</span>, <span class="dv">7</span>)</a>
<a class="sourceLine" id="cb14-2" title="2"><span class="op">=</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>) <span class="op">*</span> suma(<span class="dv">2</span>, <span class="dv">7</span>)  <span class="co"># definición de suma</span></a>
<a class="sourceLine" id="cb14-3" title="3"><span class="op">=</span> (<span class="dv">4</span> <span class="op">+</span> <span class="dv">3</span>) <span class="op">*</span> suma(<span class="dv">2</span>, <span class="dv">7</span>)                     <span class="co"># aplicación a 4, 3</span></a>
<a class="sourceLine" id="cb14-4" title="4"><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> suma(<span class="dv">2</span>, <span class="dv">7</span>)                           <span class="co"># aritmética</span></a>
<a class="sourceLine" id="cb14-5" title="5"><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">2</span>, <span class="dv">7</span>)           <span class="co"># definición de suma</span></a>
<a class="sourceLine" id="cb14-6" title="6"><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> (<span class="dv">2</span> <span class="op">+</span> <span class="dv">7</span>)                              <span class="co"># aplicación a 2, 7</span></a>
<a class="sourceLine" id="cb14-7" title="7"><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> <span class="dv">9</span>                                    <span class="co"># aritmética</span></a>
<a class="sourceLine" id="cb14-8" title="8"><span class="op">=</span> <span class="dv">63</span></a></code></pre></div></li>
</ul>
</section><section id="variables-ligadas-y-libres" class="title-slide slide level3"><h3><span class="header-section-number">1.1.3</span> Variables ligadas y libres</h3><ul>
<li><p>Si un identificador aparece en la lista de parámetros de una expresión lambda, a ese identificador le llamamos <strong>variable ligada</strong> de la expresión lambda.</p></li>
<li><p>En caso contrario, le llamamos <strong>variable libre</strong> de la expresión lambda.</p></li>
<li><p>En el ejemplo anterior:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">lambda</span> x, y: x <span class="op">+</span> y</a></code></pre></div>
<p>los dos identificadores que aparecen en el cuerpo (<code>x</code> e <code>y</code>) son variables ligadas, ya que ambos aparecen en la lista de parámetros de la expresión lambda.</p></li>
<li><p>En cambio, en la expresión lambda:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">lambda</span> x, y: x <span class="op">+</span> y <span class="op">+</span> z</a></code></pre></div>
<p><code>x</code> e <code>y</code> son variables ligadas mientras que <code>z</code> es libre.</p></li>
</ul></section><section id="ámbitos" class="title-slide slide level3"><h3><span class="header-section-number">1.1.4</span> Ámbitos</h3><ul>
<li><p>Recordemos que el <strong>ámbito de una ligadura</strong> es la porción del programa en la que dicha ligadura tiene validez.</p></li>
<li><p>Ampliaremos ahora el concepto de <em>ámbito</em> para incluir los aspectos nuevos que incorporan las expresiones lambda.</p></li>
</ul></section><section id="ámbito-de-una-variable-ligada" class="slide level4">
<h4><span class="header-section-number">1.1.4.1</span> Ámbito de una variable ligada</h4>
<ul>
<li><p>Hemos visto que <strong>un parámetro</strong> de una expresión lambda <strong>es una variable ligada</strong> en el cuerpo de dicha expresión lambda.</p></li>
<li><p>En realidad, lo que hace la expresión lambda es <strong>ligar al parámetro con la variable ligada que está dentro del cuerpo</strong>, y esa ligadura existe únicamente en el cuerpo de la expresión lambda.</p></li>
<li><p>Por tanto, <strong>el ámbito de una variable ligada es el cuerpo de la expresión lambda</strong> que la liga con su parámetro.</p></li>
<li><p>También se dice que la variable ligada tiene un <strong>ámbito local</strong> a la expresión lambda.</p></li>
<li><p>Por contraste, los identificadores que no tienen ámbito local se dice que tienen un <strong>ámbito no local</strong> o, a veces, un <strong>ámbito más global</strong>.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Por ejemplo:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode numberSource python number-lines"><code class="sourceCode python"><a class="sourceLine" id="cb17-1" title="1"><span class="co"># Aquí empieza el script (no hay más definiciones antes de esta línea):</span></a>
<a class="sourceLine" id="cb17-2" title="2">producto <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> x</a>
<a class="sourceLine" id="cb17-3" title="3">y <span class="op">=</span> producto(<span class="dv">3</span>)</a>
<a class="sourceLine" id="cb17-4" title="4">z <span class="op">=</span> x <span class="op">+</span> <span class="dv">1</span>       <span class="co"># da error</span></a></code></pre></div></li>
<li><p>La expresión lambda de la línea 2 tiene un parámetro (<code>x</code>) ligado a la variable ligada <code>x</code> situada en el cuerpo de la expresión lambda.</p></li>
<li><p>Por tanto, el ámbito de la variable ligada <code>x</code> es el <strong>cuerpo</strong> de la expresión lambda (<code>x * x</code>).</p></li>
<li><p>Eso quiere decir que, fuera de la expresión lambda, no es posible acceder al valor de la variable ligada, al encontrarnos <strong>fuera de su ámbito</strong>.</p></li>
<li><p>Por ello, la línea 4 dará un error al intentar acceder al valor de un identificador no ligado.</p></li>
</ul>
</section><section id="ámbitos-marcos-y-entornos" class="slide level4">
<h4><span class="header-section-number">1.1.4.3</span> Ámbitos, marcos y entornos</h4>
<ul>
<li><p>Recordemos que un marco es un conjunto de ligaduras.</p></li>
<li><p>Y que un entorno es una secuencia de marcos que contienen todas las ligaduras validas en un punto concreto del programa.</p></li>
<li><p>Ahora hemos visto que <strong>cada expresión lambda define un nuevo ámbito</strong>.</p></li>
<li><p>Cuando se aplica una expresión lambda a unos argumentos, <strong>se crea un nuevo marco</strong> que contiene las ligaduras que define dicha expresión lambda con sus argumentos.</p></li>
<li><p>Ese nuevo marco se enlaza con el marco del ámbito que lo contiene (el marco más interno <em>apunta</em> al más externo), de manera que el último siempre es el marco global.</p></li>
<li><p>El marco desaparece cuando el flujo de control del programa se sale del ámbito, ya que cada marco va asociado a un ámbito.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Se va formando así una cadena de marcos que representa el <strong>entorno</strong> del programa en un punto dado del mismo.</p></li>
<li><p>A partir de ahora ya no vamos a tener un único marco (el <em>marco global</em>) sino que tendremos, además, al menos uno más cada vez que se aplique una expresión lambda a unos argumentos.</p></li>
<li><p>El <strong>ámbito</strong> es un concepto <em>estático</em>: es algo que existe y se define simplemente leyendo el código del programa, sin tener que ejecutarlo.</p></li>
<li><p>El <strong>marco</strong> es un concepto <em>dinámico</em>: es algo que se crea y se destruye a medida que vamos entrando o saliendo de un ámbito, y contiene las ligaduras propias de un punto concreto del programa.</p></li>
<li><p>Por ejemplo:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb18-1" title="1">suma <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y</a></code></pre></div>
<p>la función <code>suma</code> define un nuevo ámbito, pero cada vez que se la llama con unos argumentos concretos se crea un nuevo marco que liga sus argumentos con sus parámetros.</p></li>
</ul>
</section><section id="ligaduras-sombreadas" class="slide level4">
<h4><span class="header-section-number">1.1.4.5</span> Ligaduras <em>sombreadas</em></h4>
<ul>
<li><p>¿Qué ocurre cuando una expresión lambda contiene como parámetros nombres que ya están definidos (ligados) en el entorno (en un ámbito más global)?</p></li>
<li><p>Por ejemplo:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode numberSource python number-lines"><code class="sourceCode python"><a class="sourceLine" id="cb19-1" title="1">x <span class="op">=</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb19-2" title="2">total <span class="op">=</span> (<span class="kw">lambda</span> x: x <span class="op">*</span> x)(<span class="dv">3</span>)  <span class="co"># Su valor es 9</span></a></code></pre></div></li>
<li><p>La <code>x</code> que aparece en la línea 1 es distinta a la que aparece en la línea 2.</p></li>
<li><p>El identificador <code>x</code> que aparece en el cuerpo de la expresión lambda <strong>hace referencia al parámetro <code>x</code> de la expresión lambda</strong>, y <strong>no</strong> al identificador <code>x</code> que está fuera de la expresión lambda (y que aquí está ligado al valor <code>4</code>).</p></li>
<li><p>En este caso, decimos que <strong>el parámetro <code>x</code> <em>hace sombra</em></strong> al identificador <code>x</code> global, y decimos que ese identificador está <strong>sombreado</strong> o que su ligadura está <strong>sombreada</strong>.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Que el parámetro haga sombra al identificador de fuera significa que no podemos acceder a ese identificador externo desde el cuerpo de la expresión lambda como si fuera una variable libre.</p></li>
<li><p>Si necesitáramos acceder al valor de la <code>x</code> que está fuera de la expresión lambda, lo que podemos hacer es <strong>cambiar el nombre</strong> al parámetro <code>x</code>. Por ejemplo:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode numberSource python number-lines"><code class="sourceCode python"><a class="sourceLine" id="cb20-1" title="1">x <span class="op">=</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb20-2" title="2">total <span class="op">=</span> (<span class="kw">lambda</span> w: w <span class="op">*</span> x)(<span class="dv">3</span>)  <span class="co"># Su valor es 12</span></a></code></pre></div>
<p>Así, tendremos en la expresión lambda una variable ligada (el parámetro <code>w</code>) y una variable libre (el identificador <code>x</code> ligado en el ámbito global) al que ahora sí podemos acceder al no estar sombreada.</p></li>
</ul>
</section><section id="renombrado-de-parámetros" class="slide level4">
<h4><span class="header-section-number">1.1.4.7</span> Renombrado de parámetros</h4>
<ul>
<li><p>Los parámetros se pueden <em>renombrar</em> (siempre que se haga de forma adecuada) sin que se altere el significado de la expresión lambda.</p></li>
<li><p>A esta operación se la denomina <strong>α-conversión</strong>.</p></li>
<li><p>Un ejemplo de α-conversión es la que hicimos antes.</p></li>
<li><p>La α-conversión hay que hacerla correctamente para evitar efectos indeseados. Por ejemplo, en:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb21-1" title="1"><span class="kw">lambda</span> x, y: x <span class="op">+</span> y <span class="op">+</span> z</a></code></pre></div>
<p>si renombramos <code>x</code> a <code>z</code> tendríamos:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">lambda</span> z, y: z <span class="op">+</span> y <span class="op">+</span> z</a></code></pre></div>
<p>lo que es claramente incorrecto. A este fenómeno indeseable se le denomina <strong>captura de variables</strong>.</p></li>
</ul>
</section><section id="expresiones-lambda-y-entornos" class="slide level4">
<h4><span class="header-section-number">1.1.4.8</span> Expresiones lambda y entornos</h4>
<ul>
<li><p>Para encontrar el valor de un identificador en el entorno, buscamos <strong>en el primer marco del entorno</strong> una ligadura para ese identificador, y si no la encontramos, <strong>vamos subiendo por la cadena de marcos</strong> hasta encontrarla. Si no aparece en ningún marco, querrá decir que el identificador no está ligado (o que su ligadura está fuera del entorno, en otro ámbito).</p></li>
<li><p>Debemos tener en cuenta también, por tanto, las posibles <strong>variables sombreadas</strong> que puedan aparecer.</p>
<p>Si un identificador en un ámbito más local <em>hace sombra</em> a otro en un ámbito más global, al buscar una ligadura en la cadena de marcos (en el entorno) se encontrará primero la ligadura más local, ignorando las otras.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Por ejemplo:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode numberSource python number-lines"><code class="sourceCode python"><a class="sourceLine" id="cb23-1" title="1">x <span class="op">=</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb23-2" title="2">z <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb23-3" title="3">suma <span class="op">=</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y <span class="op">+</span> z)(<span class="dv">8</span>, <span class="dv">12</span>)</a>
<a class="sourceLine" id="cb23-4" title="4">y <span class="op">=</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb23-5" title="5">w <span class="op">=</span> <span class="dv">9</span></a></code></pre></div></li>
<li><p>En cada línea tendríamos los siguientes entornos:</p></li>
</ul>
<div class="columns">
<div class="column">
<div class="centered">
<figure>
<img data-src="images/lambda-entorno-linea1.svg" alt="Entorno en la línea 1" class="plain" style="width:50.0%" /><figcaption>Entorno en la línea 1</figcaption>
</figure>
</div>
</div><div class="column">
<div class="centered">
<figure>
<img data-src="images/lambda-entorno-linea2.svg" alt="Entorno en la línea 2" class="plain" style="width:50.0%" /><figcaption>Entorno en la línea 2</figcaption>
</figure>
</div>
</div>
</div>
</section><section class="slide level4">

<div class="centered">
<figure>
<img data-src="images/lambda-entorno-linea3.svg" alt="Entorno en la línea 3 fuera de la expresión lambda" class="plain" style="width:25.0%" /><figcaption>Entorno en la línea 3 fuera de la expresión lambda</figcaption>
</figure>
</div>
<p> </p>
<div class="centered">
<figure>
<img data-src="images/lambda-entorno-linea3-dentro-antes.svg" alt="Entorno en la línea 3 en el cuerpo de la expresión lambda, antes de aplicar los argumentos" class="plain" style="width:50.0%" /><figcaption>Entorno en la línea 3 en el cuerpo de la expresión lambda, <strong>antes</strong> de aplicar los argumentos</figcaption>
</figure>
</div>
</section><section class="slide level4">

<div class="centered">
<figure>
<img data-src="images/lambda-entorno-linea3-dentro-despues.svg" alt="Entorno en la línea 3 en el cuerpo de la expresión lambda, después de aplicar los argumentos" class="plain" style="width:50.0%" /><figcaption>Entorno en la línea 3 en el cuerpo de la expresión lambda, <strong>después</strong> de aplicar los argumentos</figcaption>
</figure>
</div>
</section><section class="slide level4">

<div class="columns">
<div class="column">
<div class="centered">
<figure>
<img data-src="images/lambda-entorno-linea4.svg" alt="Entorno en la línea 4" class="plain" style="width:40.0%" /><figcaption>Entorno en la línea 4</figcaption>
</figure>
</div>
</div><div class="column">
<div class="centered">
<figure>
<img data-src="images/lambda-entorno-linea5.svg" alt="Entorno en la línea 5" class="plain" style="width:40.0%" /><figcaption>Entorno en la línea 5</figcaption>
</figure>
</div>
</div>
</div>
</section><section id="evaluación-de-expresiones-lambda-con-entornos" class="slide level4">
<h4><span class="header-section-number">1.1.4.13</span> Evaluación de expresiones lambda con entornos</h4>
<ul>
<li><p>Para que una expresión lambda funcione, sus variables libres deben estar ligadas a algún valor en el entorno <strong>en el momento de <em>evaluar</em> una aplicación de la expresión lambda sobre unos argumentos</strong>.</p></li>
<li><p>Por ejemplo:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb24-1" title="1"><span class="op">&gt;&gt;&gt;</span> prueba <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y <span class="op">+</span> z  <span class="co"># aquí no da error</span></a>
<a class="sourceLine" id="cb24-2" title="2"><span class="op">&gt;&gt;&gt;</span> prueba(<span class="dv">4</span>, <span class="dv">3</span>)                     <span class="co"># aquí sí</span></a>
<a class="sourceLine" id="cb24-3" title="3">Traceback (most recent call last):</a>
<a class="sourceLine" id="cb24-4" title="4">  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb24-5" title="5">  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span><span class="kw">lambda</span><span class="op">&gt;</span></a>
<a class="sourceLine" id="cb24-6" title="6"><span class="pp">NameError</span>: name <span class="st">&#39;z&#39;</span> <span class="kw">is</span> <span class="kw">not</span> defined</a></code></pre></div>
<p>da error porque <code>z</code> no está definido (no está ligado a ningún valor en el entorno).</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>En cambio:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode numberSource python number-lines"><code class="sourceCode python"><a class="sourceLine" id="cb25-1" title="1"><span class="op">&gt;&gt;&gt;</span> prueba <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y <span class="op">+</span> z</a>
<a class="sourceLine" id="cb25-2" title="2"><span class="op">&gt;&gt;&gt;</span> z <span class="op">=</span> <span class="dv">9</span></a>
<a class="sourceLine" id="cb25-3" title="3"><span class="op">&gt;&gt;&gt;</span> prueba(<span class="dv">4</span>, <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb25-4" title="4"><span class="dv">16</span></a></code></pre></div>
<p>sí funciona (y devuelve <code>16</code>) porque en el momento de evaluar la expresión lambda (en la línea 3) el identificador <code>z</code> está ligado a un valor en el entorno (en este caso, <code>9</code>).</p></li>
<li><p>Observar que no es necesario que las variables libres estén ligadas en el entorno cuando <em>se crea</em> la expresión lambda, sino cuando <strong>se evalúa el cuerpo de la expresión lambda</strong>, o sea, cuando se aplica la expresión lambda a unos argumentos.</p></li>
</ul>
</section><section id="pureza" class="title-slide slide level3"><h3><span class="header-section-number">1.1.5</span> Pureza</h3><ul>
<li><p>Una expresión lambda cuyo cuerpo sólo contiene variables ligadas, es una expresión cuyo valor sólo va a depender de los argumentos que se usen cuando se aplique la expresión lambda.</p></li>
<li><p>En cambio, el valor de una expresión lambda que contenga variables libres dependerá no sólo de los valores de sus argumentos, sino también de los valores a los que estén ligadas las variables libres al evaluar la expresión lambda.</p></li>
<li><p>En el ejemplo anterior tenemos una expresión que no es pura, ya que su valor depende de una variable libre (<code>z</code>):</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb26-1" title="1"><span class="op">&gt;&gt;&gt;</span> prueba <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y <span class="op">+</span> z</a>
<a class="sourceLine" id="cb26-2" title="2"><span class="op">&gt;&gt;&gt;</span> z <span class="op">=</span> <span class="dv">9</span></a>
<a class="sourceLine" id="cb26-3" title="3"><span class="op">&gt;&gt;&gt;</span> prueba(<span class="dv">4</span>, <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb26-4" title="4"><span class="dv">16</span></a></code></pre></div></li>
</ul></section><section class="slide level4">

<ul>
<li><p>En este otro ejemplo, escribimos una expresión lambda que calcula la suma de tres números a partir de otra expresión lambda que calcula la suma de dos números:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb27-1" title="1">suma <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y</a>
<a class="sourceLine" id="cb27-2" title="2">suma3 <span class="op">=</span> <span class="kw">lambda</span> x, y, z: suma(x, y) <span class="op">+</span> z</a></code></pre></div>
<p>En este caso, hay un identificador (<code>suma</code>) que no aparece en la lista de parámetros de la expresión lambda <code>suma3</code>, por lo que es una variable libre.</p>
<p>En consecuencia, el valor de dicha expresión lambda dependerá de lo que valga <code>suma</code> en el entorno actual.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Una expresión lambda es <strong>pura</strong> cuando su valor depende, únicamente, del valor de sus parámetros.</p></li>
<li><p>También se dice que una expresión lambda que contiene sólo variables ligadas es <strong>más pura</strong> que otra cuyo valor depende, además, de variables libres.</p></li>
<li><p>En cuanto a <em>grados de pureza</em>, podemos decir que hay <strong>más pureza</strong> si una variable libre representa una <strong>función</strong> a aplicar en el cuerpo de la expresión lambda, que si representa cualquier otro tipo de valor.</p></li>
<li><p>En el ejemplo anterior, tenemos que la expresión lambda <code>suma3</code>, sin ser <em>totalmente pura</em>, a efectos prácticos se la puede considerar <strong>pura</strong>, ya que su única variable libre se usa como una <strong>función</strong>, y las funciones tienden a no cambiar durante la ejecución del programa, al contrario que los demás tipos de valores.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Por ejemplo, las siguientes expresiones lambda están ordenadas de mayor a menor pureza, siendo la primera totalmente <strong>pura</strong>:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb28-1" title="1"><span class="co"># producto es una expresión lambda totalmente pura:</span></a>
<a class="sourceLine" id="cb28-2" title="2">producto <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">*</span> y</a>
<a class="sourceLine" id="cb28-3" title="3"><span class="co"># cuadrado es casi pura; a efectos prácticos se la puede</span></a>
<a class="sourceLine" id="cb28-4" title="4"><span class="co"># considerar pura ya que sus variables libres (en este</span></a>
<a class="sourceLine" id="cb28-5" title="5"><span class="co"># caso, sólo una: producto) son funciones:</span></a>
<a class="sourceLine" id="cb28-6" title="6">cuadrado <span class="op">=</span> <span class="kw">lambda</span> x: producto(x, x)</a>
<a class="sourceLine" id="cb28-7" title="7"><span class="co"># suma es impura, porque su variable libre no es una función:</span></a>
<a class="sourceLine" id="cb28-8" title="8">suma <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y <span class="op">+</span> z</a></code></pre></div></li>
</ul>
</section><section id="estrategias-de-evaluación" class="title-slide slide level2"><h2><span class="header-section-number">1.2</span> Estrategias de evaluación</h2><ul>
<li><p>A la hora de evaluar una expresión (cualquier expresión) existen varias <strong>estrategias</strong> diferentes que se pueden adoptar.</p></li>
<li><p>Cada lenguaje implementa sus propias estrategias de evaluación que están basadas en las que vamos a ver aquí.</p></li>
<li><p>Básicamente se trata de decidir, en cada paso de reducción, qué sub-expresión hay que reducir, en función de:</p>
<ul>
<li><p>El orden (de fuera adentro o de dentro afuera).</p></li>
<li><p>La necesidad o no de evaluar dicha sub-expresión.</p></li>
</ul></li>
</ul></section><section id="orden-de-evaluación" class="title-slide slide level3"><h3><span class="header-section-number">1.2.1</span> Orden de evaluación</h3><ul>
<li><p>En un lenguaje de programación funcional puro se cumple la <strong>transparencia referencial</strong>, según la cual el valor de una expresión depende sólo del valor de sus sub-expresiones (también llamadas <em>redexes</em>).</p></li>
<li><p>Pero eso también implica que <strong>no importa el orden en el que se evalúen las sub-expresiones</strong>: el resultado debe ser siempre el mismo.</p></li>
<li><p>Gracias a ello podemos usar nuestro modelo de sustitución como modelo computacional.</p></li>
<li><p>Hay dos <strong>estrategias básicas de evaluación</strong>:</p>
<ul>
<li><p><strong>Orden aplicativo</strong>: reducir siempre el <em>redex</em> más <strong>interno</strong>.</p></li>
<li><p><strong>Orden normal</strong>: reducir siempre el <em>redex</em> más <strong>externo</strong>.</p></li>
</ul></li>
<li><p><strong>Python usa el orden aplicativo</strong>, salvo excepciones.</p></li>
</ul></section><section id="orden-aplicativo" class="slide level4">
<h4><span class="header-section-number">1.2.1.1</span> Orden aplicativo</h4>
<ul>
<li><p>El <strong>orden aplicativo</strong> consiste en evaluar las expresiones <em>de dentro afuera</em>, es decir, empezando siempre por el <em>redex</em> más <strong>interno</strong>.</p></li>
<li><p>Corresponde a lo que en muchos lenguajes de programación se denomina <strong>paso de argumentos por valor</strong>.</p></li>
<li><p>Ejemplo:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb29-1" title="1">cuadrado <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> x</a></code></pre></div>
<p>Según el orden aplicativo, la expresión <code>cuadrado(3 + 4)</code> se reduciría así:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb30-1" title="1">cuadrado(<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)</a>
<a class="sourceLine" id="cb30-2" title="2"><span class="op">=</span> cuadrado(<span class="dv">7</span>)              <span class="co"># aritmética</span></a>
<a class="sourceLine" id="cb30-3" title="3"><span class="op">=</span> (<span class="kw">lambda</span> x, y: x <span class="op">*</span> x)(<span class="dv">7</span>)  <span class="co"># definición de cuadrado</span></a>
<a class="sourceLine" id="cb30-4" title="4"><span class="op">=</span> (<span class="dv">7</span> <span class="op">*</span> <span class="dv">7</span>)                  <span class="co"># aplicación a 7</span></a>
<a class="sourceLine" id="cb30-5" title="5"><span class="op">=</span> <span class="dv">49</span>                       <span class="co"># aritmética</span></a></code></pre></div>
<p>alcanzando la forma normal en 4 pasos de reducción.</p></li>
</ul>
</section><section id="orden-normal" class="slide level4">
<h4><span class="header-section-number">1.2.1.2</span> Orden normal</h4>
<ul>
<li><p>El <strong>orden normal</strong> consiste en evaluar las expresiones <em>de fuera adentro</em>, es decir, empezando siempre por el <em>redex</em> más <strong>externo</strong>.</p></li>
<li><p>Corresponde a lo que en muchos lenguajes de programación se denomina <strong>paso de argumentos por nombre</strong>.</p></li>
<li><p>Ejemplo:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb31-1" title="1">cuadrado <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> x</a></code></pre></div>
<p>Según el orden normal, la expresión <code>cuadrado(3 + 4)</code> se reduciría así:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb32-1" title="1">cuadrado(<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)</a>
<a class="sourceLine" id="cb32-2" title="2"><span class="op">=</span> (<span class="kw">lambda</span> x, y: x <span class="op">*</span> x)(<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)  <span class="co"># definición de cuadrado</span></a>
<a class="sourceLine" id="cb32-3" title="3"><span class="op">=</span> ((<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>) <span class="op">*</span> (<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>))          <span class="co"># aplicación a (3 + 4)</span></a>
<a class="sourceLine" id="cb32-4" title="4"><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)                  <span class="co"># aritmética</span></a>
<a class="sourceLine" id="cb32-5" title="5"><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> <span class="dv">7</span>                        <span class="co"># aritmética</span></a>
<a class="sourceLine" id="cb32-6" title="6"><span class="op">=</span> <span class="dv">49</span></a></code></pre></div>
<p>alcanzando la forma normal en 5 pasos de reducción.</p></li>
</ul>
</section><section id="evaluación-estricta-y-no-estricta" class="title-slide slide level3"><h3><span class="header-section-number">1.2.2</span> Evaluación estricta y no estricta</h3><ul>
<li><p>Existe otra forma de ver la evaluación de una expresión:</p>
<ul>
<li><p><strong>Evaluación estricta</strong>: Reducir todos los <em>redexes</em> aunque no hagan falta.</p></li>
<li><p><strong>Evaluación no estricta</strong>: Reducir sólo los <em>redexes</em> que sean estrictamente necesarios para calcular el valor de la expresión.</p>
<p>A esta estrategia de evaluación se la denomina también <strong>evaluación perezosa</strong>.</p></li>
</ul></li>
</ul></section><section class="slide level4">

<ul>
<li><p>Por ejemplo:</p>
<p>Sabemos que la expresión <code>1/0</code> da un error de <em>división por cero</em>:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb33-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="dv">1</span><span class="op">/</span><span class="dv">0</span></a>
<a class="sourceLine" id="cb33-2" title="2">Traceback (most recent call last):</a>
<a class="sourceLine" id="cb33-3" title="3">File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb33-4" title="4"><span class="pp">ZeroDivisionError</span>: division by zero</a></code></pre></div></li>
<li><p>Supongamos que tenemos la siguiente definición:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb34-1" title="1">primero <span class="op">=</span> <span class="kw">lambda</span> x, y: x</a></code></pre></div>
<p>de forma que <code>primero</code> es una función que simplemente devuelve el primero de sus argumentos.</p></li>
<li><p>Es evidente que la función <code>primero</code> no necesita evaluar nunca su segundo argumento, ya que no lo utiliza (simplemente devuelve el primero de ellos). Por ejemplo, <code>primero(4, 3)</code> devuelve <code>4</code>.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Sabiendo eso… ¿qué valor devolvería la siguiente expresión?</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb35-1" title="1">primero(<span class="dv">4</span>, <span class="dv">1</span><span class="op">/</span><span class="dv">0</span>)</a></code></pre></div></li>
<li><p>Curiosamente, el resultado dependerá de si la evaluación es estricta o perezosa:</p>
<ul>
<li><p><strong>Si es estricta</strong>, el intérprete evaluará todos los argumentos de la expresión lambda aunque no se utilicen luego en su cuerpo. Por tanto, al evaluar <code>1/0</code> devolverá un error.</p>
<p>Es lo que ocurre cuando se evalúa siguiendo el <strong>orden aplicativo</strong>.</p></li>
<li><p>En cambio, <strong>si es perezosa</strong>, el intérprete evaluará únicamente aquellos argumentos que se usen en el cuerpo de la expresión lambda, y en este caso sólo se usa el primero, así que dejará sin evaluar el segundo, no dará error y devolverá directamente <code>4</code>.</p>
<p>Es lo que ocurre cuando se evalúa siguiendo el <strong>orden normal</strong>:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb36-1" title="1">primero(<span class="dv">4</span>, <span class="dv">1</span><span class="op">/</span><span class="dv">0</span>) <span class="op">=</span> (<span class="kw">lambda</span> x, y: x)(<span class="dv">4</span>, <span class="dv">1</span><span class="op">/</span><span class="dv">0</span>) <span class="op">=</span> (<span class="dv">4</span>) <span class="op">=</span> <span class="dv">4</span></a></code></pre></div></li>
</ul></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>En <strong>Python</strong> la evaluación es <strong>estricta</strong>, salvo algunas excepciones:</p>
<ul>
<li><p>El operador ternario:</p>
<div class="line-block"><span style="color:teal"><em>&lt;expr_condicional&gt;</em></span> ::= <span style="color:teal"><em>&lt;valor_si_cierto&gt;</em></span> <strong><code>if</code></strong> <span style="color:teal"><em>&lt;condición&gt;</em></span> <strong><code>else</code></strong> <span style="color:teal"><em>&lt;valor_si_falso&gt;</em></span></div>
<p>evalúa perezosamente <span style="color:teal"><em>&lt;valor_si_cierto&gt;</em></span> y <span style="color:teal"><em>&lt;valor_si_falso&gt;</em></span>.</p></li>
<li><p>Los operadores lógicos <code>and</code> y <code>or</code> también son perezosos (se dice que evalúan <strong>en cortocircuito</strong>):</p>
<ul>
<li><p><code>True or x</code> siempre es igual a <code>True</code>.</p></li>
<li><p><code>False and x</code> siempre es igual a <code>False</code>.</p></li>
</ul>
<p>En ambos casos no es necesario evaluar <code>x</code>.</p></li>
</ul></li>
<li><p>La mayoría de los lenguajes de programación se basan en la evaluación estricta y el paso de argumentos por valor (siguen el orden aplicativo).</p></li>
<li><p><strong>Haskell</strong>, por ejemplo, es un lenguaje funcional puro que se basa en la evaluación perezosa y sigue el orden normal.</p></li>
</ul>
</section><section id="composición-de-funciones" class="title-slide slide level2"><h2><span class="header-section-number">1.3</span> Composición de funciones</h2><ul>
<li><p>Podemos crear una función que use otra función. Por ejemplo, para calcular el área de un círculo usamos otra función que calcule el cuadrado de un número:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb37-1" title="1">cuadrado <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> x</a>
<a class="sourceLine" id="cb37-2" title="2">area <span class="op">=</span> <span class="kw">lambda</span> r: <span class="fl">3.1416</span> <span class="op">*</span> cuadrado(r)</a></code></pre></div></li>
<li><p>La expresión <code>area(11 + 1)</code> se evaluaría así según el <em>orden aplicativo</em>:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode numberSource python number-lines"><code class="sourceCode python"><a class="sourceLine" id="cb38-1" title="1">area(<span class="dv">11</span> <span class="op">+</span> <span class="dv">1</span>)                                     <span class="co"># aritmética</span></a>
<a class="sourceLine" id="cb38-2" title="2"><span class="op">=</span> area(<span class="dv">12</span>)                                       <span class="co"># definición de area</span></a>
<a class="sourceLine" id="cb38-3" title="3"><span class="op">=</span> (<span class="kw">lambda</span> r: <span class="fl">3.1416</span> <span class="op">*</span> cuadrado(r))(<span class="dv">12</span>)           <span class="co"># definición de cuadrado</span></a>
<a class="sourceLine" id="cb38-4" title="4"><span class="op">=</span> (<span class="kw">lambda</span> r: <span class="fl">3.1416</span> <span class="op">*</span> (<span class="kw">lambda</span> x: x <span class="op">*</span> x)(r))(<span class="dv">12</span>)  <span class="co"># aplicación</span></a>
<a class="sourceLine" id="cb38-5" title="5"><span class="op">=</span> (<span class="fl">3.1416</span> <span class="op">*</span> (<span class="kw">lambda</span> x: x <span class="op">*</span> x)(<span class="dv">12</span>))               <span class="co"># aplicación</span></a>
<a class="sourceLine" id="cb38-6" title="6"><span class="op">=</span> (<span class="fl">3.1416</span> <span class="op">*</span> (<span class="dv">12</span> <span class="op">*</span> <span class="dv">12</span>))                           <span class="co"># aritmética</span></a>
<a class="sourceLine" id="cb38-7" title="7"><span class="op">=</span> (<span class="fl">3.1416</span> <span class="op">*</span> <span class="dv">144</span>)                                 <span class="co"># aritmética</span></a>
<a class="sourceLine" id="cb38-8" title="8"><span class="op">=</span> <span class="fl">452.3904</span></a></code></pre></div></li>
</ul></section><section class="slide level4">

<ul>
<li><p>En detalle:</p>
<ul>
<li><p><strong>Línea 1</strong>: Se evalúa primero el argumento.</p></li>
<li><p><strong>Línea 3</strong>: El <em>redex</em> más interno es <code>r</code>, pero no puede reducirse más en este momento. El siguiente más interno es <code>cuadrado(r)</code>; para evaluarlo hay que reescribir <code>cuadrado</code> con su definición.</p></li>
<li><p><strong>Línea 4</strong>: El <em>redex</em> más interno es la aplicación del <code>lambda</code> derecho con el argumento <code>r</code>, pero éste aún no está evaluado ni se puede evaluar ahora mismo, así que no es posible reducir la aplicación. El siguiente más interno es el <code>*</code> sobre <code>3.1416</code>, pero el otro operando (el <code>lambda</code> derecho) aún no está evaluado ni se puede evaluar, así que el <em>redex</em> que queda es la aplicación del primer <code>lambda</code> sobre su argumento <code>12</code>.</p></li>
<li><p><strong>Línea 5</strong>: El <em>redex</em> más interno es la aplicación del <code>lambda</code> derecho con el argumento <code>12</code>, que ahora sí se puede hacer porque el argumento está evaluado.</p></li>
</ul></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>La expresión <code>area(11 + 1)</code> se evaluaría así según el <em>orden normal</em>:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode numberSource python number-lines"><code class="sourceCode python"><a class="sourceLine" id="cb39-1" title="1">area(<span class="dv">11</span> <span class="op">+</span> <span class="dv">1</span>)                                <span class="co"># definición de area</span></a>
<a class="sourceLine" id="cb39-2" title="2"><span class="op">=</span> (<span class="kw">lambda</span> r: <span class="fl">3.1416</span> <span class="op">*</span> cuadrado(r))(<span class="dv">11</span> <span class="op">+</span> <span class="dv">1</span>)  <span class="co"># aplicación</span></a>
<a class="sourceLine" id="cb39-3" title="3"><span class="op">=</span> (<span class="fl">3.1416</span> <span class="op">*</span> cuadrado(<span class="dv">11</span> <span class="op">+</span> <span class="dv">1</span>))               <span class="co"># definición de cuadrado</span></a>
<a class="sourceLine" id="cb39-4" title="4"><span class="op">=</span> (<span class="fl">3.1416</span> <span class="op">*</span> (<span class="kw">lambda</span> x: x <span class="op">*</span> x)(<span class="dv">11</span> <span class="op">+</span> <span class="dv">1</span>))      <span class="co"># aplicación</span></a>
<a class="sourceLine" id="cb39-5" title="5"><span class="op">=</span> (<span class="fl">3.1416</span> <span class="op">*</span> ((<span class="dv">11</span> <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> (<span class="dv">11</span> <span class="op">+</span> <span class="dv">1</span>)))          <span class="co"># aritmética</span></a>
<a class="sourceLine" id="cb39-6" title="6"><span class="op">=</span> (<span class="fl">3.1416</span> <span class="op">*</span> (<span class="dv">12</span> <span class="op">*</span> (<span class="dv">11</span> <span class="op">+</span> <span class="dv">1</span>)))                <span class="co"># aritmética</span></a>
<a class="sourceLine" id="cb39-7" title="7"><span class="op">=</span> (<span class="fl">3.1416</span> <span class="op">*</span> (<span class="dv">12</span> <span class="op">*</span> <span class="dv">12</span>))                      <span class="co"># aritmética</span></a>
<a class="sourceLine" id="cb39-8" title="8"><span class="op">=</span> (<span class="fl">3.1416</span> <span class="op">*</span> <span class="dv">144</span>)                            <span class="co"># aritmética</span></a>
<a class="sourceLine" id="cb39-9" title="9"><span class="op">=</span> <span class="fl">452.3904</span></a></code></pre></div></li>
<li><p>En ambos casos (orden aplicativo y orden normal) se obtiene el mismo resultado.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>En detalle:</p>
<ul>
<li><p><strong>Línea 1</strong>: Se evalúa el <em>redex</em> más externo, que es <code>area</code> (se reescribe con su definición).</p></li>
<li><p><strong>Línea 2</strong>: El <em>redex</em> más externo es la aplicación de la expresión <code>lambda</code> a su argumento <code>11 + 1</code>.</p></li>
<li><p><strong>Línea 3</strong>: El <em>redex</em> más externo es el <code>*</code>, pero para evaluarlo hay que evaluar primero todos sus argumentos, por lo que ahora hay que evaluar <code>cuadrado</code>, reescribiéndolo con su definición.</p></li>
<li><p><strong>Línea 4</strong>: Igual que en la línea 3, para poder evaluar el <code>*</code> más externo hay que evaluar primero la aplicación del <code>lambda</code> sobre su argumento <code>11 + 1</code>.</p></li>
</ul></li>
</ul>
</section></section>
<section><section id="computabilidad" class="title-slide slide level1"><h1><span class="header-section-number">2</span> Computabilidad</h1></section><section id="funciones-y-procesos" class="title-slide slide level2"><h2><span class="header-section-number">2.1</span> Funciones y procesos</h2><ul>
<li><p>Los <strong>procesos</strong> son entidades abstractas que habitan los ordenadores.</p></li>
<li><p>Conforme van evolucionando, los procesos manipulan otras entidades abstractas llamadas <strong>datos</strong>.</p></li>
<li><p>La evolución de un proceso está dirigida por un patrón de reglas llamada <strong>programa</strong>.</p></li>
<li><p>Los programadores crean programas para <strong>dirigir</strong> a los procesos.</p></li>
<li><p>Es como decir que los programadores son magos que invocan a los espíritus del ordenador con sus conjuros.</p></li>
</ul></section><section class="slide level4">

<ul>
<li><p>Una <strong>función</strong> describe la <em>evolución local</em> de un <strong>proceso</strong>.</p></li>
<li><p>En cada paso se calcula el <em>siguiente estado</em> del proceso basándonos en el estado actual y en las reglas definidas por la función.</p></li>
<li><p>Nos gustaría ser capaces de visualizar y de realizar afirmaciones sobre el comportamiento global del proceso cuya evolución local está definida por la función.</p></li>
<li><p>Esto, en general, es muy difícil, pero al menos vamos a describir algunos de los modelos típicos de evolución de los procesos.</p></li>
</ul>
</section><section id="funciones-recursivas" class="title-slide slide level2"><h2><span class="header-section-number">2.2</span> Funciones recursivas</h2></section><section id="definición" class="title-slide slide level3"><h3><span class="header-section-number">2.2.1</span> Definición</h3><ul>
<li><p>Una <strong>función recursiva</strong> es aquella que se define en términos de sí misma.</p></li>
<li><p>En general, eso quiere decir que la definición de la función contiene una o varias referencias a ella misma y que, por tanto, se llama a sí misma dentro de su cuerpo.</p></li>
<li><p>Las definiciones recursivas son el mecanismo básico para ejecutar <strong>repeticiones de instrucciones</strong> en un lenguaje de programación funcional.</p></li>
<li><p>Por ejemplo:</p>
<p><strong>GNU</strong> significa <strong>GNU No es Unix</strong>.</p>
<p>Por tanto, GNU = GNU No es Unix = GNU No es Unix No es Unix…</p>
<p>Y así hasta el infinito.</p></li>
</ul></section><section id="casos-base-y-casos-recursivos" class="title-slide slide level3"><h3><span class="header-section-number">2.2.2</span> Casos base y casos recursivos</h3><ul>
<li><p>Resulta importante que una definición recursiva se detenga alguna vez y proporcione un resultado, ya que si no, no sería útil (tendríamos lo que se llama una <strong>recursión infinita</strong>).</p></li>
<li><p>Para ello, en algún momento, la recursión debe alcanzar un punto en el que la función no se llame a sí misma.</p></li>
<li><p>La función, en cada paso recursivo, debe ir acercándose cada vez más a ese punto.</p></li>
<li><p>A ese punto o puntos en los que la función recursiva no se llama a sí misma, se les denomina <strong>casos base</strong>.</p></li>
<li><p>Es decir: la función recursiva, ante ciertos valores de sus argumentos, debe devolver directamente un valor y no llamarse de nuevo recursivamente.</p></li>
<li><p>Los demás casos, que sí provocan llamadas recursivas, se denominan <strong>casos recursivos</strong>.</p></li>
</ul></section><section id="el-factorial" class="title-slide slide level3"><h3><span class="header-section-number">2.2.3</span> El factorial</h3><ul>
<li><p>El ejemplo más típico de función recursiva es el <strong>factorial</strong>.</p></li>
<li><p>El factorial de un número natural <span class="math inline">n</span> se representa <span class="math inline">n!</span> y se define como el producto de todos los números desde 1 hasta <span class="math inline">n</span>: <span class="math display">n! = n\cdot(n-1)\cdot(n-2)\cdot\ldots\cdot1</span></p>
<p>Por ejemplo: <span class="math display">6! = 6\cdot5\cdot4\cdot3\cdot2\cdot1 = 720</span></p></li>
<li><p>Pero para calcular <span class="math inline">6!</span> también se puede calcular <span class="math inline">5!</span> y después multiplicar el resultado por 6, ya que: <span class="math display">6! = 6\cdot\overbrace{5\cdot4\cdot3\cdot2\cdot1}^{5!}</span> <span class="math display">6! = 6\cdot5!</span></p></li>
<li><p>Por tanto, el factorial se puede definir de forma <strong>recursiva</strong>.</p></li>
</ul></section><section class="slide level4">

<ul>
<li><p>Tenemos el <strong>caso recursivo</strong>, pero necesitamos un <strong>caso base</strong> para evitar que la recursión se haga <em>infinita</em>.</p></li>
<li><p>El caso base del factorial se obtiene sabiendo que el factorial de 0 es directamente 1 (no hay que llamar al factorial recursivamente): <span class="math display">0! = 1</span></p></li>
<li><p>Combinando ambos casos tendríamos:</p>
<p><span class="math display">n! = \begin{cases}
         1 &amp; \text{si } n = 0 \text{\quad(caso base)} \\
         n\cdot(n-1)! &amp; \text{si } n &gt; 0 \text{\quad(caso recursivo)}
       \end{cases}</span></p></li>
</ul>
</section><section id="recursividad-lineal" class="title-slide slide level3"><h3><span class="header-section-number">2.2.4</span> Recursividad lineal</h3><ul>
<li><p>Una función tiene <strong>recursividad lineal</strong> si cada llamada a la función recursiva genera, como mucho, otra llamada recursiva a la misma función.</p></li>
<li><p>El factorial definido en el ejemplo anterior es un caso típico de recursividad lineal.</p></li>
</ul></section><section id="procesos-lineales-recursivos" class="slide level4">
<h4><span class="header-section-number">2.2.4.1</span> Procesos lineales recursivos</h4>
<ul>
<li><p>La forma más directa y sencilla de definir una función que calcule el factorial de un número a partir de su definición recursiva podría ser la siguiente:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb40-1" title="1">factorial <span class="op">=</span> <span class="kw">lambda</span> n: <span class="dv">1</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> n <span class="op">*</span> factorial(n <span class="op">-</span> <span class="dv">1</span>)</a></code></pre></div></li>
<li><p>Utilizaremos el modelo de sustitución para observar el funcionamiento de esta función al calcular <span class="math inline">6!</span>:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb41-1" title="1">factorial(<span class="dv">6</span>)</a>
<a class="sourceLine" id="cb41-2" title="2"><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> factorial(<span class="dv">5</span>))</a>
<a class="sourceLine" id="cb41-3" title="3"><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> factorial(<span class="dv">4</span>)))</a>
<a class="sourceLine" id="cb41-4" title="4"><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> factorial(<span class="dv">3</span>))))</a>
<a class="sourceLine" id="cb41-5" title="5"><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">*</span> factorial(<span class="dv">2</span>)))))</a>
<a class="sourceLine" id="cb41-6" title="6"><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">*</span> (<span class="dv">2</span> <span class="op">*</span> factorial(<span class="dv">1</span>))))))</a>
<a class="sourceLine" id="cb41-7" title="7"><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">*</span> (<span class="dv">2</span> <span class="op">*</span> (<span class="dv">1</span> <span class="op">*</span> factorial(<span class="dv">0</span>)))))))</a>
<a class="sourceLine" id="cb41-8" title="8"><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">*</span> (<span class="dv">2</span> <span class="op">*</span> (<span class="dv">1</span> <span class="op">*</span> <span class="dv">1</span>))))))</a>
<a class="sourceLine" id="cb41-9" title="9"><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">*</span> (<span class="dv">2</span> <span class="op">*</span> <span class="dv">1</span>)))))</a>
<a class="sourceLine" id="cb41-10" title="10"><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">*</span> <span class="dv">2</span>))))</a>
<a class="sourceLine" id="cb41-11" title="11"><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> <span class="dv">6</span>)))</a>
<a class="sourceLine" id="cb41-12" title="12"><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> <span class="dv">24</span>))</a>
<a class="sourceLine" id="cb41-13" title="13"><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> <span class="dv">120</span>)</a>
<a class="sourceLine" id="cb41-14" title="14"><span class="op">=</span> <span class="dv">720</span></a></code></pre></div></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Podemos observar un perfil de <strong>expansión</strong> seguido de una <strong>contracción</strong>:</p>
<ul>
<li><p>La <strong>expansión</strong> ocurre conforme el proceso construye una cadena de operaciones a realizar <em>posteriormente</em> (en este caso, una cadena de multiplicaciones).</p></li>
<li><p>La <strong>contracción</strong> se realiza conforme se van ejecutando realmente las multiplicaciones.</p></li>
</ul></li>
<li><p>Llamaremos <strong>proceso recursivo</strong> a este tipo de proceso caracterizado por una cadena de <strong>operaciones pendientes de completar</strong>.</p></li>
<li><p>Para poder ejecutar este proceso, el intérprete necesita <strong>memorizar</strong>, en algún lugar, un registro de las multiplicaciones que se han dejado para más adelante.</p></li>
<li><p>En el cálculo de <span class="math inline">n!</span>, la longitud de la cadena de operaciones pendientes (y, por tanto, la información que necesita almacenar el intérprete), crece <em>linealmente</em> con <span class="math inline">n</span>, al igual que el número de pasos de reducción.</p>
<ul>
<li>A este tipo de procesos lo llamaremos <strong>proceso recursivo <em>lineal</em></strong>.</li>
</ul></li>
</ul>
</section><section id="procesos-lineales-iterativos" class="slide level4">
<h4><span class="header-section-number">2.2.4.3</span> Procesos lineales iterativos</h4>
<ul>
<li><p>A continuación adoptaremos un enfoque diferente.</p></li>
<li><p>Podemos mantener un producto acumulado y un contador desde <span class="math inline">n</span> hasta 1, de forma que el contador y el producto cambien de un paso al siguiente según la siguiente regla:</p>
<p><span class="math display">\begin{cases}
    acumulado \leftarrow acumulado \cdot contador \\
    contador \leftarrow contador - 1
  \end{cases}</span></p></li>
<li><p>Su traducción a Python podría ser la siguiente, usando una función auxiliar <code>fact_iter</code>:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb42-1" title="1">fact_iter <span class="op">=</span> <span class="kw">lambda</span> cont, acc: acc <span class="cf">if</span> cont <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="op">\</span></a>
<a class="sourceLine" id="cb42-2" title="2">                              fact_iter(cont <span class="op">-</span> <span class="dv">1</span>, cont <span class="op">*</span> acc)</a>
<a class="sourceLine" id="cb42-3" title="3">fact <span class="op">=</span> <span class="kw">lambda</span> n: fact_iter(n, <span class="dv">1</span>)</a></code></pre></div></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Al igual que antes, usaremos el modelo de sustitución para visualizar el proceso del cálculo de <span class="math inline">6!</span>:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb43-1" title="1">fact(<span class="dv">6</span>)</a>
<a class="sourceLine" id="cb43-2" title="2"><span class="op">=</span> fact_iter(<span class="dv">6</span>, <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb43-3" title="3"><span class="op">=</span> fact_iter(<span class="dv">5</span>, <span class="dv">6</span>)</a>
<a class="sourceLine" id="cb43-4" title="4"><span class="op">=</span> fact_iter(<span class="dv">4</span>, <span class="dv">30</span>)</a>
<a class="sourceLine" id="cb43-5" title="5"><span class="op">=</span> fact_iter(<span class="dv">3</span>, <span class="dv">120</span>)</a>
<a class="sourceLine" id="cb43-6" title="6"><span class="op">=</span> fact_iter(<span class="dv">2</span>, <span class="dv">360</span>)</a>
<a class="sourceLine" id="cb43-7" title="7"><span class="op">=</span> fact_iter(<span class="dv">1</span>, <span class="dv">720</span>)</a>
<a class="sourceLine" id="cb43-8" title="8"><span class="op">=</span> fact_iter(<span class="dv">0</span>, <span class="dv">720</span>)</a>
<a class="sourceLine" id="cb43-9" title="9"><span class="op">=</span> <span class="dv">720</span></a></code></pre></div></li>
<li><p>Este proceso no tiene expansiones ni contracciones ya que, en cada instante, toda la información que se necesita almacenar es el valor actual de los parámetros <code>cont</code> y <code>acc</code>, por lo que el tamaño de la memoria necesaria es constante.</p></li>
<li><p>A este tipo de procesos lo llamaremos <strong>proceso iterativo</strong>.</p></li>
<li><p>El número de pasos necesarios para calcular <span class="math inline">n!</span> usando esta función crece <em>linealmente</em> con <span class="math inline">n</span>.</p>
<ul>
<li>A este tipo de procesos lo llamaremos <strong>proceso iterativo <em>lineal</em></strong>.</li>
</ul></li>
</ul>
</section><section class="slide level4">

<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 30%" />
<col style="width: 35%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Tipo de proceso</th>
<th style="text-align: left;">Número de reducciones</th>
<th style="text-align: left;">Memoria necesaria</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Recursivo</td>
<td style="text-align: left;">Proporcional a <code>n</code></td>
<td style="text-align: left;">Proporcional a <code>n</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Iterativo</td>
<td style="text-align: left;">Proporcional a <code>n</code></td>
<td style="text-align: left;">Constante</td>
</tr>
</tbody>
</table>
<p><br></p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 30%" />
<col style="width: 35%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Tipo de proceso</th>
<th style="text-align: left;">Número de reducciones</th>
<th style="text-align: left;">Memoria necesaria</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Recursivo lineal</td>
<td style="text-align: left;">Linealmente<br />
proporcional a <code>n</code></td>
<td style="text-align: left;">Linealmente<br />
proporcional a <code>n</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Iterativo lineal</td>
<td style="text-align: left;">Linealmente<br />
proporcional a <code>n</code></td>
<td style="text-align: left;">Constante</td>
</tr>
</tbody>
</table>
</section><section class="slide level4">

<ul>
<li><p>En general, un <strong>proceso iterativo</strong> es aquel que está definido por una serie de <strong>variables de estado</strong> junto con una <strong>regla</strong> fija que describe cómo actualizar dichas variables conforme cambia el proceso de un estado al siguiente.</p></li>
<li><p>La <strong>diferencia entre los procesos recursivo e iterativo</strong> se puede describir de esta otra manera:</p>
<ul>
<li><p>En el <strong>proceso iterativo</strong>, las variables ligadas dan una descripción completa del estado del proceso en cada instante.</p>
<p>Así, si parásemos el cálculo entre dos pasos, lo único que necesitaríamos hacer para seguir con el cálculo es darle al intérprete el valor de los dos parámetros.</p></li>
<li><p>En el <strong>proceso recursivo</strong>, el intérprete tiene que mantener cierta información <em>oculta</em> que no está almacenada en ningún parámetro y que indica en qué punto se encuentra el proceso dentro de la cadena de operaciones pendientes.</p></li>
</ul></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>No debe confundirse un <strong>proceso recursivo</strong> con una <strong>función recursiva</strong>:</p>
<ul>
<li><p>Cuando hablamos de <em>función recursiva</em> nos referimos al hecho sintáctico de que la definción de la función hace referencia a sí misma (directa o indirectamente).</p></li>
<li><p>Cuando hablamos de <em>proceso recursivo</em> nos referimos a la forma en como se desenvuelve la ejecución de la función.</p></li>
</ul></li>
<li><p>Puede parecer extraño que digamos que una función recursiva (por ejemplo, <code>fact_iter</code>) genera un proceso iterativo.</p>
<p>Sin embargo, el proceso es realmente iterativo porque su estado está definido completamente por dos variables ligadas, y para ejecutar el proceso sólo se necesita almacenar esas dos variables.</p></li>
</ul>
</section><section id="recursividad-en-árbol" class="title-slide slide level3"><h3><span class="header-section-number">2.2.5</span> Recursividad en árbol</h3><ul>
<li><p>La <strong>recursividad en árbol</strong> se produce cuando la función tiene <strong>recursividad múltiple</strong>.</p></li>
<li><p>Una función tiene <strong>recursividad múltiple</strong> cuando una llamada a la función recursiva puede generar más de una llamada recursiva a la misma función.</p></li>
<li><p>El ejemplo clásico es la función que calcula los términos de la <strong>sucesión de Fibonacci</strong>.</p></li>
<li><p>La sucesión comienza con los números 0 y 1, y a partir de éstos, cada término es la suma de los dos anteriores:</p>
<p>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, …</p></li>
</ul></section><section class="slide level4">

<ul>
<li><p>Podemos definir una función que devuelva el <span class="math inline">n</span>-ésimo término de la sucesión de Fibonacci:</p>
<p><span class="math display">fib(n) = \begin{cases}
             0 &amp; \text{si } n = 0 \text{\quad (caso base)} \\
             1 &amp; \text{si } n = 1 \text{\quad (caso base)} \\
             fib(n - 1) + fib(n - 2) &amp; \text{si } n &gt; 1 \text{\quad (caso recursivo)}
           \end{cases}</span></p></li>
<li><p>Que traducida a Python sería:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb44-1" title="1">fib <span class="op">=</span> <span class="kw">lambda</span> n: <span class="dv">0</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">1</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span> <span class="cf">else</span> fib(n <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> fib(n <span class="op">-</span> <span class="dv">2</span>)</a></code></pre></div>
<p>o bien:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb45-1" title="1">fib <span class="op">=</span> <span class="kw">lambda</span> n: <span class="dv">0</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="op">\</span></a>
<a class="sourceLine" id="cb45-2" title="2">                <span class="dv">1</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span> <span class="cf">else</span> <span class="op">\</span></a>
<a class="sourceLine" id="cb45-3" title="3">                fib(n <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> fib(n <span class="op">-</span> <span class="dv">2</span>)</a></code></pre></div></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Si vemos el perfil de ejecución de <code>fib(5)</code>, vemos que:</p>
<ul>
<li><p>Para calcular <code>fib(5)</code>, antes debemos calcular <code>fib(4)</code> y <code>fib(3)</code>.</p></li>
<li><p>Para calcular <code>fib(4)</code>, antes debemos calcular <code>fib(3)</code> y <code>fib(2)</code>.</p></li>
<li><p>Así sucesivamente hasta poner todo en función de <code>fib(0)</code> y <code>fib(1)</code>, que se pueden calcular directamente (son los casos base).</p></li>
</ul></li>
<li><p>En general, el proceso resultante parece un árbol.</p></li>
</ul>
</section><section class="slide level4">

<div class="centered">
<p><img data-src="images/arbol-fibonacci.svg" class="plain" style="width:80.0%" /></p>
</div>
</section><section class="slide level4">

<ul>
<li><p>La función anterior es un buen ejemplo de recursión en árbol, pero desde luego es un método <em>horrible</em> para calcular los números de Fibonacci, por la cantidad de <strong>operaciones redundantes</strong> que efectúa.</p></li>
<li><p>Para tener una idea de lo malo que es, se puede observar que <span class="math inline">fib(n)</span> crece exponencialmente en función de <span class="math inline">n</span>.</p></li>
<li><p>Por lo tanto, el proceso necesita una cantidad de tiempo que crece <strong>exponencialmente</strong> con <span class="math inline">n</span>.</p></li>
<li><p>Por otro lado, el espacio necesario sólo crece <strong>linealmente</strong> con <span class="math inline">n</span>, porque en un cierto momento del cálculo sólo hay que memorizar los nodos que hay por encima.</p></li>
<li><p>En general, en un proceso recursivo en árbol el tiempo de ejecución crece con el número de nodos mientras que el espacio necesario crece con la altura máxima del árbol.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Se puede construir un <strong>proceso iterativo</strong> para calcular los números de Fibonacci.</p></li>
<li><p>La idea consiste en usar dos variables de estado <code>a</code> y <code>b</code> (con valores iniciales <code>1</code> y <code>0</code>, respectivamente) y aplicar repetidamente la siguiente transformación:</p>
<p><span class="math display">\begin{cases}
    a \leftarrow a + b \\
    b \leftarrow a
  \end{cases}</span></p></li>
<li><p>Después de <span class="math inline">n</span> pasos, <code>a</code> y <code>b</code> contendrán, respectivamente, <span class="math inline">fib(n + 1)</span> y <span class="math inline">fib(n)</span>.</p></li>
<li><p>En Python sería:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb46-1" title="1">fib_iter <span class="op">=</span> <span class="kw">lambda</span> cont, a, b: b <span class="cf">if</span> cont <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> fib_iter(cont <span class="op">-</span> <span class="dv">1</span>, a <span class="op">+</span> b, a)</a>
<a class="sourceLine" id="cb46-2" title="2">fib <span class="op">=</span> <span class="kw">lambda</span> n: fib_iter(n , <span class="dv">1</span>, <span class="dv">0</span>)</a></code></pre></div></li>
<li><p>Esta función genera un proceso iterativo lineal, por lo que es mucho más eficiente.</p></li>
</ul>
</section><section id="la-pila-de-control" class="title-slide slide level2"><h2><span class="header-section-number">2.3</span> La pila de control</h2><ul>
<li><p>La <strong>pila de control</strong> es una estructura de datos que utiliza el intérprete para llevar la cuenta de las <strong>llamadas <em>activas</em></strong> en un determinado momento, incluyendo el valor de sus parámetros y el punto de retorno al que debe devolverse el control cuando finalice la ejecución de la función.</p>
<ul>
<li>Las <strong>llamadas activas</strong> son aquellas llamadas a funciones que aún no han terminado de ejecutarse.</li>
</ul></li>
<li><p>La pila de control es, básicamente, un <strong>almacén de entornos</strong>.</p></li>
<li><p>Cada vez que se hace una nueva llamada a una función, <strong>su marco</strong> correspondiente <strong>se almacena en la cima de la pila</strong> sobre los demás marcos que pudiera haber.</p></li>
<li><p>Ese marco es el primero de la cadena de marcos que forman el entorno de la función, pero en general no es necesario almacenar toda la cadena en la pila (basta con su primer marco).</p></li>
</ul></section><section class="slide level4">

<ul>
<li><p>El intérprete puede, además, almacenar ahí cualquier otra información que necesite para gestionar las llamadas a funciones.</p></li>
<li><p>El marco de la función, junto con toda esa información adicional, se denomina <strong>registro de activación</strong>.</p></li>
<li><p>Por tanto, <strong>la pila de control almacena registros de activación</strong>.</p></li>
<li><p>Cada llamada activa está representada por su correspondiente registro de activación en la pila.</p></li>
<li><p>En cuanto la llamada finaliza, su registro de activación se saca de la pila y se transfiere el control a la llamada que está inmediatamente debajo (si es que hay alguna).</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li>Supongamos el siguiente código:</li>
</ul>
<div class="columns">
<div class="column">
<div class="sourceCode" id="cb47"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb47-1" title="1">g <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb47-2" title="2">uno <span class="op">=</span> <span class="kw">lambda</span> x: <span class="dv">1</span> <span class="op">+</span> dos(<span class="dv">2</span> <span class="op">*</span> x, <span class="dv">4</span>)</a>
<a class="sourceLine" id="cb47-3" title="3">dos <span class="op">=</span> <span class="kw">lambda</span> y, z: tres(y <span class="op">+</span> z <span class="op">+</span> g)</a>
<a class="sourceLine" id="cb47-4" title="4">tres <span class="op">=</span> <span class="kw">lambda</span> w: <span class="st">&quot;W vale &quot;</span> <span class="op">+</span> <span class="bu">str</span>(w)</a>
<a class="sourceLine" id="cb47-5" title="5">uno(<span class="dv">3</span>)</a></code></pre></div>
</div><div class="column">
<div class="centered">
<figure>
<img data-src="images/pila-control.svg" alt="Pila de control con la función tres activada" class="plain" style="width:100.0%" /><figcaption>Pila de control con la función <code>tres</code> activada</figcaption>
</figure>
</div>
</div>
</div>
</section><section class="slide level4">

<ul>
<li><p>Hemos dicho que habrá un registro de activación por cada nueva llamada que se realice a una función, y que ese registro se mantendrá en la pila hasta que la llamada finalice.</p></li>
<li><p>Por tanto, en el caso de una función recursiva, tendremos un registro de activación por cada llamada recursiva.</p></li>
</ul>
<div class="columns">
<div class="column">
<div class="sourceCode" id="cb48"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb48-1" title="1">fact <span class="op">=</span> <span class="kw">lambda</span> n: <span class="dv">1</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="op">\</span></a>
<a class="sourceLine" id="cb48-2" title="2">                 n <span class="op">*</span> fact(n <span class="op">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb48-3" title="3">fact(<span class="dv">4</span>)</a></code></pre></div>
</div><div class="column">
<div class="centered">
<figure>
<img data-src="images/pila-control-factorial.svg" alt="Pila de control de fact tras tres activaciones desde fact(4)" class="plain" style="width:100.0%" /><figcaption>Pila de control de <code>fact</code> tras tres activaciones desde <code>fact(4)</code></figcaption>
</figure>
</div>
</div>
</div>
</section><section id="un-lenguaje-turing-completo" class="title-slide slide level2"><h2><span class="header-section-number">2.4</span> Un lenguaje Turing-completo</h2><ul>
<li><p>El paradigma funcional que hemos visto hasta ahora (uno que nos permite definir funciones, componer dichas funciones y aplicar recursividad, junto con el operador ternario condicional) es un lenguaje de programación <strong>completo</strong>.</p></li>
<li><p>Decimos que es <strong>Turing completo</strong>, lo que significa que puede computar cualquier función que pueda computar una máquina de Turing.</p></li>
<li><p>Como las máquinas de Turing son los ordenadores más potentes que podemos construir (ya que describen lo que cualquier ordenador es capaz de hacer), esto significa que nuestro lenguaje puede calcular todo lo que pueda calcular cualquier ordenador.</p></li>
</ul></section></section>
<section><section id="tipos-de-datos-recursivos" class="title-slide slide level1"><h1><span class="header-section-number">3</span> Tipos de datos recursivos</h1></section><section id="cadenas" class="title-slide slide level2"><h2><span class="header-section-number">3.1</span> Cadenas</h2><ul>
<li><p>Las <strong>cadenas</strong> se pueden considerar <strong>datos recursivos compuestos</strong>, ya que podemos decir que toda cadena <code>c</code>:</p>
<ul>
<li><p>o bien es la cadena vacía <code>''</code> (<em>caso base</em>),</p></li>
<li><p>o bien está formada por dos partes:</p>
<ul>
<li><p>El <strong>primer carácter</strong> de la cadena, al que se accede mediante <code>c[0]</code>.</p></li>
<li><p>El <strong>resto</strong> de la cadena (al que se accede mediante <code>c[1:]</code>), que también es una cadena (<em>caso recursivo</em>).</p></li>
</ul></li>
</ul></li>
<li><p>Eso significa que podemos acceder al segundo carácter de la cadena (suponiendo que exista) mediante <code>c[1:][0]</code>.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb49-1" title="1">cadena <span class="op">=</span> <span class="st">&#39;hola&#39;</span></a>
<a class="sourceLine" id="cb49-2" title="2">cadena[<span class="dv">0</span>]       <span class="co"># devuelve &#39;h&#39;</span></a>
<a class="sourceLine" id="cb49-3" title="3">cadena[<span class="dv">1</span>:]      <span class="co"># devuelve &#39;ola&#39;</span></a>
<a class="sourceLine" id="cb49-4" title="4">cadena[<span class="dv">1</span>:][<span class="dv">0</span>]   <span class="co"># devuelve &#39;o&#39;</span></a></code></pre></div></li>
</ul></section><section id="listas" class="title-slide slide level2"><h2><span class="header-section-number">3.2</span> Listas</h2><ul>
<li><p>Las <strong>listas</strong> son una generalización de las cadenas.</p></li>
<li><p>Una lista es una <strong>secuencia de elementos</strong> que no tienen por qué ser caracteres, sino que cada uno de ellos pueden ser <strong>de cualquier tipo</strong> (números, cadenas, booleanos, incluso otras listas).</p></li>
<li><p>Los literales de tipo lista se representan enumerando sus elementos separados por comas y encerrados entre corchetes.</p></li>
<li><p>Por ejemplo:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb50-1" title="1">lista <span class="op">=</span> [<span class="dv">27</span>, <span class="st">&#39;hola&#39;</span>, <span class="va">True</span>, <span class="fl">73.4</span>, [<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>], <span class="dv">99</span>]</a></code></pre></div></li>
</ul></section><section class="slide level4">

<ul>
<li><p>Las listas también pueden verse como un <strong>tipo de datos recursivo</strong>, ya que toda lista <code>l</code>:</p>
<ul>
<li><p>o bien es la lista vacía, representada mediante <code>[]</code> (<em>caso base</em>),</p></li>
<li><p>o bien está formada por dos partes:</p>
<ul>
<li><p>El <strong>primer elemento</strong> de la lista (al que se accede mediante <code>l[0]</code>), que hemos visto que puede ser de cualquier tipo.</p></li>
<li><p>El <strong>resto</strong> de la lista (al que se accede mediante <code>l[1:]</code>), que también es una lista (<em>caso recursivo</em>).</p></li>
</ul></li>
</ul></li>
<li><p>Según el ejemplo anterior:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb51-1" title="1">lista <span class="op">=</span> [<span class="dv">27</span>, <span class="st">&#39;hola&#39;</span>, <span class="va">True</span>, <span class="fl">73.4</span>, [<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>], <span class="dv">99</span>]</a>
<a class="sourceLine" id="cb51-2" title="2">lista[<span class="dv">0</span>]       <span class="co"># devuelve 27</span></a>
<a class="sourceLine" id="cb51-3" title="3">lista[<span class="dv">1</span>:]      <span class="co"># devuelve [&#39;hola&#39;, True, 73.4, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], 99]</span></a>
<a class="sourceLine" id="cb51-4" title="4">lista[<span class="dv">1</span>:][<span class="dv">0</span>]   <span class="co"># devuelve &#39;hola&#39;</span></a></code></pre></div></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Junto a las operaciones <code>l[0]</code> (primer elemento) y <code>c[1:]</code> (resto de la lista), tenemos también la operación <code>+</code> (<strong>concatenación</strong>), al igual que ocurre con las cadenas.</p></li>
<li><p>Con la concatenación se pueden crear nuevas listas a partir de otras listas.</p></li>
<li><p>Por ejemplo:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb52-1" title="1">[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>] <span class="op">+</span> [<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]  <span class="co"># devuelve [1, 2, 3, 4, 5, 6]</span></a></code></pre></div></li>
</ul>
</section><section id="rangos" class="title-slide slide level2"><h2><span class="header-section-number">3.3</span> Rangos</h2><ul>
<li><p>Un rango es un tipo de dato cuyos valores representan <strong>sencuencias de números enteros</strong>.</p></li>
<li><p>Los rangos se crean con la función <code>range</code>, cuya sintaxis es:</p>
<div class="line-block"><span style="color:teal"><em>&lt;rango&gt;</em></span> ::= <strong><code>range</code><code>(</code></strong>[<span style="color:teal"><em>&lt;inicio&gt;</em></span><strong><code>,</code></strong>] <span style="color:teal"><em>&lt;fin&gt;</em></span>[<strong><code>,</code></strong> <span style="color:teal"><em>&lt;salto&gt;</em></span>]<strong><code>)</code></strong></div></li>
<li><p><span style="color:teal"><em>&lt;inicio&gt;</em></span>, <span style="color:teal"><em>&lt;fin&gt;</em></span> y <span style="color:teal"><em>&lt;salto&gt;</em></span> deben ser números enteros.</p></li>
<li><p>Cuando se omite <span style="color:teal"><em>&lt;inicio&gt;</em></span>, se entiende que es <code>0</code>.</p></li>
<li><p>El valor de <span style="color:teal"><em>&lt;fin&gt;</em></span> no se alcanza nunca.</p></li>
<li><p>Cuando <span style="color:teal"><em>&lt;inicio&gt;</em></span> y <span style="color:teal"><em>&lt;fin&gt;</em></span> son iguales, representa el <em>rango vacío</em>.</p></li>
<li><p>Cuando <span style="color:teal"><em>&lt;inicio&gt;</em></span> es mayor que <span style="color:teal"><em>&lt;fin&gt;</em></span>, el <span style="color:teal"><em>&lt;salto&gt;</em></span> debería ser negativo. En caso contrario, también representaría el rango vacío.</p></li>
</ul></section><section class="slide level4">

<ul>
<li><p>Ejemplos:</p>
<ul>
<li><p><code>range(10)</code> representa la secuencia <span class="math inline">0, 1, 2, \ldots, 9</span></p></li>
<li><p><code>range(3, 10)</code> representa la secuencia <span class="math inline">3, 4, 5, \ldots, 9</span></p></li>
<li><p><code>range(0, 10, 2)</code> representa la secuencia <span class="math inline">0, 2, 4, 6, 8</span></p></li>
<li><p><code>range(4, 0, -1)</code> representa la secuencia <span class="math inline">4, 3, 2, 1</span></p></li>
<li><p><code>range(3, 3)</code> representa el rango vacío</p></li>
<li><p><code>range(4, 3)</code> también representa el rango vacío</p></li>
</ul></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Los rangos también pueden verse como un <strong>tipo de datos recursivo</strong>, ya que todo rango <code>r</code>:</p>
<ul>
<li><p>o bien es el rango vacío (<em>caso base</em>),</p></li>
<li><p>o bien está formado por dos partes:</p>
<ul>
<li><p>El <strong>primer elemento</strong> del rango (al que se accede mediante <code>r[0]</code>), que hemos visto que tiene que ser un número entero.</p></li>
<li><p>El <strong>resto</strong> del rango (al que se accede mediante <code>r[1:]</code>), que también es un rango (<em>caso recursivo</em>).</p></li>
</ul></li>
</ul></li>
<li><p>Según el ejemplo anterior:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb53-1" title="1">rango <span class="op">=</span> <span class="bu">range</span>(<span class="dv">4</span>, <span class="dv">7</span>)</a>
<a class="sourceLine" id="cb53-2" title="2">rango[<span class="dv">0</span>]       <span class="co"># devuelve 4</span></a>
<a class="sourceLine" id="cb53-3" title="3">rango[<span class="dv">1</span>:]      <span class="co"># devuelve range(5, 7)</span></a>
<a class="sourceLine" id="cb53-4" title="4">rango[<span class="dv">1</span>:][<span class="dv">0</span>]   <span class="co"># devuelve 5</span></a></code></pre></div></li>
</ul>
</section><section id="conversión-a-lista" class="title-slide slide level2"><h2><span class="header-section-number">3.4</span> Conversión a lista</h2><ul>
<li>Las cadenas y los rangos se pueden convertir fácilmente a listas usando la función <code>list</code>:</li>
</ul>
<div class="columns">
<div class="column" style="width:40%;">
<div class="sourceCode" id="cb54"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb54-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(<span class="st">&#39;hola&#39;</span>)</a>
<a class="sourceLine" id="cb54-2" title="2">[<span class="st">&#39;h&#39;</span>, <span class="st">&#39;o&#39;</span>, <span class="st">&#39;l&#39;</span>, <span class="st">&#39;a&#39;</span>]</a>
<a class="sourceLine" id="cb54-3" title="3"><span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(<span class="st">&#39;&#39;</span>)</a>
<a class="sourceLine" id="cb54-4" title="4">[]</a></code></pre></div>
</div><div class="column" style="width:60%;">
<div class="sourceCode" id="cb55"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb55-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="dv">10</span>))</a>
<a class="sourceLine" id="cb55-2" title="2">[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>]</a>
<a class="sourceLine" id="cb55-3" title="3"><span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">11</span>))</a>
<a class="sourceLine" id="cb55-4" title="4">[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">10</span>]</a>
<a class="sourceLine" id="cb55-5" title="5"><span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">30</span>, <span class="dv">5</span>))</a>
<a class="sourceLine" id="cb55-6" title="6">[<span class="dv">0</span>, <span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">15</span>, <span class="dv">20</span>, <span class="dv">25</span>]</a>
<a class="sourceLine" id="cb55-7" title="7"><span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">3</span>))</a>
<a class="sourceLine" id="cb55-8" title="8">[<span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">6</span>, <span class="dv">9</span>]</a>
<a class="sourceLine" id="cb55-9" title="9"><span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">-10</span>, <span class="dv">-1</span>))</a>
<a class="sourceLine" id="cb55-10" title="10">[<span class="dv">0</span>, <span class="dv">-1</span>, <span class="dv">-2</span>, <span class="dv">-3</span>, <span class="dv">-4</span>, <span class="dv">-5</span>, <span class="dv">-6</span>, <span class="dv">-7</span>, <span class="dv">-8</span>, <span class="dv">-9</span>]</a>
<a class="sourceLine" id="cb55-11" title="11"><span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="dv">0</span>))</a>
<a class="sourceLine" id="cb55-12" title="12">[]</a>
<a class="sourceLine" id="cb55-13" title="13"><span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">0</span>))</a>
<a class="sourceLine" id="cb55-14" title="14">[]</a></code></pre></div>
</div>
</div></section></section>
<section><section id="funciones-de-orden-superior" class="title-slide slide level1"><h1><span class="header-section-number">4</span> Funciones de orden superior</h1></section><section id="concepto" class="title-slide slide level2"><h2><span class="header-section-number">4.1</span> Concepto</h2><ul>
<li><p>Hemos visto que <strong>las funciones son</strong>, en realidad, <strong>abstracciones</strong> que describen operaciones compuestas a realizar sobre ciertos valores sin importar cuáles sean esos valores en concreto.</p></li>
<li><p>Por ejemplo, cuando definimos:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb56-1" title="1">cubo <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> x <span class="op">*</span> x</a></code></pre></div>
<p>no estamos hablando del cubo de un número en particular, sino más bien de un <strong>método</strong> para calcular el cubo de un número.</p></li>
<li><p>Por supuesto, nos la podemos arreglar sin definir el cubo, escribiendo siempre expresiones explícitas (como <code>3*3*3</code>, <code>y*y*y</code>, etc.) sin usar la palabra «cubo», pero eso nos obligaría siempre a expresarnos en términos de las operaciones primitivas de nuestro lenguaje (como <code>*</code>), en vez de poder usar términos de más alto nivel.</p>
<p>Es decir: <strong>nuestros programas podrían calcular el cubo de un número, pero no tendrían la habilidad de expresar el concepto de <em>elevar al cubo</em></strong>.</p></li>
</ul></section><section class="slide level4">

<ul>
<li><p>Una de las habilidades que deberíamos pedir a un lenguaje potente es la posibilidad de <strong>construir abstracciones</strong> asignando un nombre a los patrones más comunes, y luego trabajar directamente en términos de dichas abstracciones.</p></li>
<li><p>Las funciones nos permiten esta habilidad y esa es la razón de que todos los lenguajes (salvo los más primitivos) incluyan mecanismos para definir funciones.</p></li>
<li><p>Por ejemplo: en el caso anterior, vemos que hay un patrón (multiplicar algo por sí mismo tres veces) que se repite con frecuencia, y a partir de él construimos una abstracción que asigna un nombre a ese patrón (<em>elevar al cubo</em>). Esa abstracción la definimos como una función que describe la <em>regla</em> necesaria para elevar algo al cubo.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Muchas veces observamos el mismo patrón en funciones muy diferentes.</p></li>
<li><p>Para poder abstraer, de nuevo, lo que tienen en común dichas funciones, deberíamos ser capaces de manejar funciones que acepten a otras funciones como argumentos o que devuelvan otra función como resultado. A estas funciones que manejan otras funciones las llamaremos <strong>funciones de orden superior</strong>.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Por ejemplo, supongamos las dos funciones siguientes:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb57-1" title="1"><span class="co"># Suma los enteros comprendidos entre a y b:</span></a>
<a class="sourceLine" id="cb57-2" title="2">suma_enteros <span class="op">=</span> <span class="kw">lambda</span> a, b: <span class="dv">0</span> <span class="cf">if</span> a <span class="op">&gt;</span> b <span class="cf">else</span> a <span class="op">+</span> suma_enteros(a <span class="op">+</span> <span class="dv">1</span>, b)</a>
<a class="sourceLine" id="cb57-3" title="3"></a>
<a class="sourceLine" id="cb57-4" title="4"><span class="co"># Suma los cubos de los enteros comprendidos entre a y b:</span></a>
<a class="sourceLine" id="cb57-5" title="5">suma_cubos <span class="op">=</span> <span class="kw">lambda</span> a, b: <span class="dv">0</span> <span class="cf">if</span> a <span class="op">&gt;</span> b <span class="cf">else</span> cubo(a) <span class="op">+</span> suma_enteros(a <span class="op">+</span> <span class="dv">1</span>, b)</a></code></pre></div></li>
<li><p>Estas dos funciones comparten claramente un patrón subyacente común. Se diferencian solamente en:</p>
<ul>
<li><p>El nombre de la función</p></li>
<li><p>La función de <code>a</code> que se utiliza para calcular cada término</p></li>
</ul></li>
<li><p>Podríamos haber escrito las funciones anteriores rellenando los «casilleros» del siguiente <em>patrón general</em>:</p>
<div class="line-block"><span style="color:teal"><em>&lt;nombre&gt;</em></span> = <strong><code>lambda</code></strong> a, b: 0 <strong><code>if</code></strong> a &gt; b <strong><code>else</code></strong> <span style="color:teal"><em>&lt;término&gt;</em></span>(a) + <span style="color:teal"><em>&lt;nombre&gt;</em></span>(a + 1, b)</div></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>La existencia de este patrón común nos demuestra que hay una abstracción esperando que la saquemos a la superficie.</p></li>
<li><p>De hecho, los matemáticos han identificado hace mucho tiempo esta abstracción llamándola <strong>suma de una serie</strong>, y la expresan así: <span class="math display"> \sum _ {n=a}^b f(n) = f(a) + \ldots + f(b)</span></p></li>
<li><p>La ventaja que tiene usar la notación anterior es que se puede trabajar directamente con el concepto de sumatorio en vez de trabajar con sumas concretas, y podemos sacar conclusiones generales sobre los sumatorios independientemente de la serie particular que estemos tratando.</p></li>
<li><p>Igualmente, como programadores estamos interesados en que nuestro lenguaje tenga la suficiente potencia como para describir directamente el concepto de <em>sumatorio</em>, en vez de funciones particulares que calculen sumas concretas.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>En programación funcional lo conseguimos creando funciones que conviertan los «casilleros» en parámetros:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb58-1" title="1">suma <span class="op">=</span> <span class="kw">lambda</span> term, a, b: <span class="dv">0</span> <span class="cf">if</span> a <span class="op">&gt;</span> b <span class="cf">else</span> term(a) <span class="op">+</span> suma(term, a <span class="op">+</span> <span class="dv">1</span>, b)</a></code></pre></div></li>
<li><p>De esta forma, las dos funciones <code>suma_enteros</code> y <code>suma_cubos</code> anteriores se podrían definir en términos de esta <code>suma</code>:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb59-1" title="1">suma_enteros <span class="op">=</span> <span class="kw">lambda</span> a, b: suma(<span class="kw">lambda</span> x: x, a, b)</a>
<a class="sourceLine" id="cb59-2" title="2">suma_cubos <span class="op">=</span> <span class="kw">lambda</span> a, b: suma(<span class="kw">lambda</span> x: x <span class="op">*</span> x <span class="op">*</span> x, a, b)</a>
<a class="sourceLine" id="cb59-3" title="3"><span class="co"># O mejor aún:</span></a>
<a class="sourceLine" id="cb59-4" title="4">suma_cubos <span class="op">=</span> <span class="kw">lambda</span> a, b: suma(cubo, a, b)</a></code></pre></div></li>
<li><p>¿Se podría generalizar aún más la función <code>suma</code>?</p></li>
</ul>
</section><section id="map" class="title-slide slide level2"><h2><span class="header-section-number">4.2</span> <code>map</code></h2><ul>
<li><p>Supongamos que queremos escribir una función que, dada una lista de números, nos devuelva otra lista con los mismos números elevados al cubo.</p></li>
<li><p>Inténtalo primero como ejercicio.</p></li>
</ul></section><section class="slide level4">

<ul>
<li><p>Una forma de hacerlo sería:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb60-1" title="1">elevar_cubo <span class="op">=</span> <span class="kw">lambda</span> l: [] <span class="cf">if</span> l <span class="op">==</span> [] <span class="cf">else</span> <span class="op">\</span></a>
<a class="sourceLine" id="cb60-2" title="2">                        [cubo(l[<span class="dv">0</span>])] <span class="op">+</span> elevar_cubo(l[<span class="dv">1</span>:])</a></code></pre></div></li>
<li><p>¿Y elevar a la cuarta potencia?</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb61-1" title="1">elevar_cubo <span class="op">=</span> <span class="kw">lambda</span> l: [] <span class="cf">if</span> l <span class="op">==</span> [] <span class="cf">else</span> <span class="op">\</span></a>
<a class="sourceLine" id="cb61-2" title="2">                        [(<span class="kw">lambda</span> x: x <span class="op">**</span> <span class="dv">4</span>)(l[<span class="dv">0</span>])] <span class="op">+</span> elevar_cubo(l[<span class="dv">1</span>:])</a></code></pre></div></li>
<li><p>Es evidente que hay un patrón subyacente que se podría abstraer creando una función de orden superior que aplique una función <code>f</code> a los elementos de una lista y devuelva la lista resultante.</p>
<p>Esa función se llama <code>map</code>, y viene definida en Python:</p>
<div class="line-block">map(<span style="color:teal"><em>&lt;función&gt;</em></span>, <span style="color:teal"><em>&lt;iterable&gt;</em></span>) -&gt; <span style="color:teal"><em>&lt;iterador&gt;</em></span></div>
<p>donde <span style="color:teal"><em>&lt;iterable&gt;</em></span> puede ser cualquier cosa compuesta de elementos que se puedan recorrer de uno en uno, como una <strong>lista</strong>, una <strong>cadena</strong> o un <strong>rango</strong> (cualquier <em>secuencia</em> de elementos vale).</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Podemos usarla así:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb62-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="bu">map</span>(cubo, [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a>
<a class="sourceLine" id="cb62-2" title="2"><span class="op">&lt;</span><span class="bu">map</span> <span class="bu">object</span> at <span class="bn">0x7f22b25e9d68</span><span class="op">&gt;</span></a></code></pre></div>
<p>Lo que devuelve no es una lista, sino un objeto <em>iterador</em> que examinaremos con más detalle en posteriores temas.</p>
<p>Por ahora, lo que haremos será simplemente transformar ese iterador en la lista correspondiente usando la función <code>list</code> sobre el resultado de <code>map</code>:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb63-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(<span class="bu">map</span>(cubo, [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]))</a>
<a class="sourceLine" id="cb63-2" title="2">[<span class="dv">1</span>, <span class="dv">8</span>, <span class="dv">27</span>, <span class="dv">64</span>]</a></code></pre></div></li>
<li><p>Además de una lista, también podemos usar un rango:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb64-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(<span class="bu">map</span>(cubo, <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">5</span>)))</a>
<a class="sourceLine" id="cb64-2" title="2">[<span class="dv">1</span>, <span class="dv">8</span>, <span class="dv">27</span>, <span class="dv">64</span>]</a></code></pre></div></li>
<li><p>¿Cómo definirías la función <code>map</code>?</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Podríamos definirla así:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb65-1" title="1"><span class="bu">map</span> <span class="op">=</span> <span class="kw">lambda</span> f, l: [] <span class="cf">if</span> l <span class="op">==</span> [] <span class="cf">else</span> [f(l[<span class="dv">0</span>])] <span class="op">+</span> <span class="bu">map</span>(l[<span class="dv">1</span>:])</a></code></pre></div></li>
</ul>
</section><section id="filter" class="title-slide slide level2"><h2><span class="header-section-number">4.3</span> <code>filter</code></h2><ul>
<li><p><code>filter</code> es una <strong>función de orden superior</strong> que devuelve aquellos elementos de una lista (o cualquier cosa <em>iterable</em>) que cumplen una determinada condición.</p></li>
<li><p>Su sintaxis es:</p>
<div class="line-block">filter(<span style="color:teal"><em>&lt;función&gt;</em></span>, <span style="color:teal"><em>&lt;iterable&gt;</em></span>) -&gt; <span style="color:teal"><em>&lt;iterador&gt;</em></span></div></li>
<li><p>Por ejemplo:</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb66-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(<span class="bu">filter</span>(<span class="kw">lambda</span> x: x <span class="op">&gt;</span> <span class="dv">0</span>, [<span class="op">-</span><span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">-2</span>, <span class="dv">8</span>, <span class="dv">-3</span>, <span class="dv">9</span>]))</a>
<a class="sourceLine" id="cb66-2" title="2">[<span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">8</span>, <span class="dv">9</span>]</a></code></pre></div></li>
</ul></section><section id="reduce" class="title-slide slide level2"><h2><span class="header-section-number">4.4</span> <code>reduce</code></h2><ul>
<li><p><code>reduce</code> es una <strong>función de orden superior</strong> que aplica, de forma acumulativa, una función a todos los elementos de una lista (o cualquier cosa <em>iterable</em>).</p></li>
<li><p>Las operaciones se hacen agrupándose <strong>por la izquierda</strong>.</p></li>
<li><p>Captura un <strong>patrón muy frecuente</strong> de recursión sobre listas de elementos.</p></li>
<li><p>Por ejemplo, para calcular la suma de todos los elementos de una lista, haríamos:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb67-1" title="1">suma <span class="op">=</span> <span class="kw">lambda</span> l: <span class="dv">0</span> <span class="cf">if</span> l <span class="op">==</span> [] <span class="cf">else</span> l[<span class="dv">0</span>] <span class="op">+</span> suma(l[<span class="dv">1</span>:])</a></code></pre></div></li>
<li><p>Y para calcular el producto:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb68-1" title="1">producto <span class="op">=</span> <span class="kw">lambda</span> l: <span class="dv">1</span> <span class="cf">if</span> l <span class="op">==</span> [] <span class="cf">else</span> l[<span class="dv">0</span>] <span class="op">*</span> producto(l[<span class="dv">1</span>:])</a></code></pre></div></li>
<li><p>Como podemos observar, la estrategia de cálculo es esencialmente la misma (sólo se diferencian en la operación a realizar (<code>+</code> o <code>*</code>) y en el valor inicial o <em>elemento neutro</em> (<code>0</code> o <code>1</code>).</p></li>
</ul></section><section class="slide level4">

<ul>
<li><p>Si abstraemos ese patrón común podemos crear una función de orden superior que capture la idea de <strong>reducir todos los elementos de una lista a un único valor</strong>.</p></li>
<li><p>Eso es lo que hace la función <code>reduce</code>.</p></li>
<li><p>Su sintaxis es:</p>
<div class="line-block">reduce(<span style="color:teal"><em>&lt;función&gt;</em></span>, <span style="color:teal"><em>&lt;iterable&gt;</em></span>[, <span style="color:teal"><em>&lt;valor_inicial&gt;</em></span>]) -&gt; <span style="color:teal"><em>&lt;valor&gt;</em></span></div></li>
<li><p>El <span style="color:teal"><em>&lt;valor_inicial&gt;</em></span>, si existe, se usará como primer elemento de la lista en el cálculo y sirve como valor por defecto cuando la lista está vacía.</p></li>
<li><p>La <span style="color:teal"><em>&lt;función&gt;</em></span> debe recibir dos argumentos y devolver un valor.</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Para usarla, tenemos que <em>importarla</em> previamente del <em>módulo</em> <code>functools</code>.</p>
<ul>
<li><p>No es la primera vez que importamos un módulo. Ya lo hicimos con el módulo <code>math</code>.</p></li>
<li><p>En su momento estudiaremos con detalle qué son los módulos. Por ahora nos basta con lo que ya sabemos: que contienen definiciones que podemos incorporar a nuestros <em>scripts</em>.</p></li>
</ul></li>
<li><p>Por ejemplo, para calcular la suma y el producto de <code>[1, 2, 3, 4]</code>:</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb69-1" title="1"><span class="im">from</span> functools <span class="im">import</span> <span class="bu">reduce</span></a>
<a class="sourceLine" id="cb69-2" title="2">lista <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]</a>
<a class="sourceLine" id="cb69-3" title="3">suma_de_numeros <span class="op">=</span> <span class="bu">reduce</span>(<span class="kw">lambda</span> x, y: x <span class="op">+</span> y, lista, <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb69-4" title="4">producto_de_numeros <span class="op">=</span> <span class="bu">reduce</span>(<span class="kw">lambda</span> x, y: x <span class="op">*</span> y, lista, <span class="dv">1</span>)</a></code></pre></div></li>
<li><p>¿Cómo podríamos definir la función <code>reduce</code>?</p></li>
</ul>
</section><section class="slide level4">

<ul>
<li><p>Una forma (con valor inicial obligatorio) podría ser así:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb70-1" title="1"><span class="bu">reduce</span> <span class="op">=</span> <span class="kw">lambda</span> fun, lista, ini: ini <span class="cf">if</span> lista <span class="op">==</span> [] <span class="cf">else</span> <span class="op">\</span></a>
<a class="sourceLine" id="cb70-2" title="2">                                 lista[<span class="dv">0</span>] <span class="cf">if</span> lista[<span class="dv">1</span>:] <span class="op">==</span> [] <span class="cf">else</span> <span class="op">\</span></a>
<a class="sourceLine" id="cb70-3" title="3">                                 fun(lista[<span class="dv">0</span>], <span class="bu">reduce</span>(fun, lista[<span class="dv">1</span>:], ini))</a></code></pre></div></li>
</ul>
</section><section id="listas-por-comprensión" class="title-slide slide level2"><h2><span class="header-section-number">4.5</span> Listas por comprensión</h2><ul>
<li><p>Dos operaciones que se realizan con frecuencia sobre un iterador son:</p>
<ul>
<li><p>Realizar alguna operación sobre cada elemento (<code>map</code>)</p></li>
<li><p>Seleccionar un subconjunto de elementos que cumplan alguna condición (<code>filter</code>)</p></li>
</ul></li>
<li><p>Las listas por comprensión son una notación copiada del lenguaje Haskell que nos permite realizar ambas operaciones de una forma muy concisa:</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb71-1" title="1"><span class="op">&gt;&gt;&gt;</span> [x <span class="op">**</span> <span class="dv">3</span> <span class="cf">for</span> x <span class="kw">in</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]]</a>
<a class="sourceLine" id="cb71-2" title="2">[<span class="dv">1</span>, <span class="dv">8</span>, <span class="dv">27</span>, <span class="dv">64</span>]</a>
<a class="sourceLine" id="cb71-3" title="3"><span class="co"># equivale a:</span></a>
<a class="sourceLine" id="cb71-4" title="4"><span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="kw">lambda</span> x: x <span class="op">**</span> <span class="dv">3</span>, [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]))</a>
<a class="sourceLine" id="cb71-5" title="5">[<span class="dv">1</span>, <span class="dv">8</span>, <span class="dv">27</span>, <span class="dv">64</span>]</a>
<a class="sourceLine" id="cb71-6" title="6"></a>
<a class="sourceLine" id="cb71-7" title="7"><span class="op">&gt;&gt;&gt;</span> [x <span class="cf">for</span> x <span class="kw">in</span> [<span class="op">-</span><span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">-2</span>, <span class="dv">8</span>, <span class="dv">-3</span>, <span class="dv">9</span>] <span class="cf">if</span> x <span class="op">&gt;</span> <span class="dv">0</span>]</a>
<a class="sourceLine" id="cb71-8" title="8">[<span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">8</span>, <span class="dv">9</span>]</a>
<a class="sourceLine" id="cb71-9" title="9"><span class="co"># equivale a:</span></a>
<a class="sourceLine" id="cb71-10" title="10"><span class="op">&gt;&gt;&gt;</span> <span class="bu">list</span>(<span class="bu">filter</span>(<span class="kw">lambda</span> x: x <span class="op">&gt;</span> <span class="dv">0</span>, [<span class="op">-</span><span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">-2</span>, <span class="dv">8</span>, <span class="dv">-3</span>, <span class="dv">9</span>]))</a>
<a class="sourceLine" id="cb71-11" title="11">[<span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">8</span>, <span class="dv">9</span>]</a></code></pre></div></li>
</ul></section><section class="slide level4">

<ul>
<li>Su sintaxis es:</li>
</ul>

<div class="line-block"><span style="color:teal"><em>&lt;lista_comp&gt;</em></span> ::= <strong><code>[</code></strong><span style="color:teal"><em>&lt;expresión&gt;</em></span> (<strong><code>for</code></strong> <span style="color:teal"><em>&lt;identificador&gt;</em></span> <strong><code>in</code></strong> <span style="color:teal"><em>&lt;secuencia&gt;</em></span> [<strong><code>if</code></strong> <span style="color:teal"><em>&lt;condición&gt;</em></span>])+<strong><code>]</code></strong></div>

<ul>
<li><p>Los elementos de la salida generada serán los sucesivos valores de <span style="color:teal"><em>&lt;expresión&gt;</em></span>.</p></li>
<li><p>Las cláusulas <strong><code>if</code></strong> son opcionales. Si están, la <span style="color:teal"><em>&lt;expresión&gt;</em></span> sólo se evaluará y añadirá al resultado cuando se cumpla la <span style="color:teal"><em>&lt;condición&gt;</em></span>.</p></li>
<li><p>Por ejemplo:</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb72-1" title="1"><span class="op">&gt;&gt;&gt;</span> sec1 <span class="op">=</span> <span class="st">&#39;abc&#39;</span></a>
<a class="sourceLine" id="cb72-2" title="2"><span class="op">&gt;&gt;&gt;</span> sec2 <span class="op">=</span> (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb72-3" title="3"><span class="op">&gt;&gt;&gt;</span> [(x, y) <span class="cf">for</span> x <span class="kw">in</span> sec1 <span class="cf">for</span> y <span class="kw">in</span> sec2]</a>
<a class="sourceLine" id="cb72-4" title="4">[(<span class="st">&#39;a&#39;</span>, <span class="dv">1</span>), (<span class="st">&#39;a&#39;</span>, <span class="dv">2</span>), (<span class="st">&#39;a&#39;</span>, <span class="dv">3</span>),</a>
<a class="sourceLine" id="cb72-5" title="5"> (<span class="st">&#39;b&#39;</span>, <span class="dv">1</span>), (<span class="st">&#39;b&#39;</span>, <span class="dv">2</span>), (<span class="st">&#39;b&#39;</span>, <span class="dv">3</span>),</a>
<a class="sourceLine" id="cb72-6" title="6"> (<span class="st">&#39;c&#39;</span>, <span class="dv">1</span>), (<span class="st">&#39;c&#39;</span>, <span class="dv">2</span>), (<span class="st">&#39;c&#39;</span>, <span class="dv">3</span>)]</a></code></pre></div></li>
</ul>
</section></section>
<section id="bibliografía" class="title-slide slide level1 unnumbered"><h1>Bibliografía</h1><div id="refs" class="references" role="doc-bibliography">
<div id="ref-abelson_structure_1996">
<p>Abelson, Harold, Gerald Jay Sussman, and Julie Sussman. 1996. <em>Structure and Interpretation of Computer Programs</em>. 2nd ed. Cambridge, Mass. : New York: MIT Press ; McGraw-Hill.</p>
</div>
</div></section>
    </div>
  </div>

  <script src="reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Display the page number of the current slide
        slideNumber: true,
        // Push each slide change to the browser history
        history: true,
        // Transition style
        transition: 'slide', // none/fade/slide/convex/concave/zoom
        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1280,
        height: 1080,

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'reveal.js/plugin/notes/notes.js', async: true },
          { src: 'reveal.js/plugin/reveal.js-menu/menu.js', async: true },
          { src: 'reveal.js/plugin/reveal.js-quiz/quiz/js/quiz.js', async: true, callback: function() { prepareQuizzes({preventUnanswered: true, checkAnswerText: 'Comprueba la respuesta', nextQuestionText: 'Siguiente &raquo;', backButtonText: '&laquo; Anterior', tryAgainText: 'Prueba de nuevo', preventUnansweredText: 'Selecciona una respuesta', questionCountText: 'Pregunta %current de %total', skipStartButton: true}); } },
          { src: 'reveal.js/plugin/reveal-code-focus/vendor/highlight.js/highlight.pack.js' },
          { src: 'reveal.js/plugin/reveal-code-focus/reveal-code-focus.js', async: true, callback: function() { RevealCodeFocus(); } },
          { src: 'reveal.js/plugin/search/search.js', async: true },
          { src: 'reveal.js/plugin/customcontrols/customcontrols.js', async: true }
        ],

        customcontrols: {
          controls: [
            { icon: '<i class="fa fa-question-circle"></i>',
			  css: 'position: fixed; right: 50px; bottom: 50px; z-index: 30; font-size: 24px;',
			  action: 'Reveal.toggleHelp(); return false;'
			}
          ]
        },

        menu: {
          numbers: true,
          hideMissingTitles: true,
          themes: true,
          themesPath: 'reveal.js/css/theme/'
        }
      });
    </script>
    </body>
</html>
