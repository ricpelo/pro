<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Ricardo Pérez López">
  <title>Introducción</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="./reveal.js/dist/reset.css">
  <link rel="stylesheet" href="./reveal.js/dist/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #cb4b16; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #d33682; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #dc322f; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #93a1a1; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #268bd2; } /* DataType */
    code span.dv { color: #d33682; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #d33682; } /* Float */
    code span.fu { color: #268bd2; } /* Function */
    code span.im { font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #268bd2; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #a57800; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #2aa198; } /* SpecialString */
    code span.st { color: #2aa198; } /* String */
    code span.va { color: #6c71c4; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="./reveal.js/dist/theme/solarized.css" id="theme">
  <link rel="stylesheet" href="custom.css"/>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
   var mathElements = document.getElementsByClassName("math");
   var macros = [];
   for (var i = 0; i < mathElements.length; i++) {
    var texText = mathElements[i].firstChild;
    if (mathElements[i].tagName == "SPAN") {
     katex.render(texText.data, mathElements[i], {
      displayMode: mathElements[i].classList.contains('display'),
      throwOnError: false,
      macros: macros,
      fleqn: false
     });
  }}});
  </script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" />
  <link href="https://fonts.googleapis.com/css?family=Lato&display=swap" rel="stylesheet">
  <style type="text/css">
      #header-left {
          position: absolute;
          font-size: 25%;
          top: 0%;
          left: 0%;
          margin-left: 10px;
          margin-top: 10px;
      }
      #header-right {
          position: absolute;
          font-size: 25%;
          top: 0%;
          right: 0%;
          margin-right: 10px;
          margin-top: 10px;
      }
      #footer-left {
          position: absolute;
          font-size: 25%;
          bottom: 0%;
          left: 0%;
          margin-left: 10px;
          margin-bottom: 10px;
      }
  </style>
</head>
<body>
<div id="hidden" style="display:none;">
    <div id="header">
        <div id="header-left"></div>
        <div id="header-right"></div>
        <div id="footer-left"></div>
    </div>
</div>
<script type="text/javascript">
    document.addEventListener("DOMContentLoaded", function(event) {
        var title = document.getElementsByClassName('title')[0];
        title = title != null ? title.innerHTML : '';
        var author = document.getElementsByClassName('author')[0];
        author = author != null ? author.innerHTML : '';
        var date = document.getElementsByClassName('date')[0];
        date = date != null ? date.innerHTML : '';
        document.getElementById('header-left').innerHTML = '<a href="#/title-slide">' + title + '</a>';
        document.getElementById('footer-left').innerHTML = '<a href="https://pro.iesdonana.org">&copy; ' + author + ' (' + date + ')</a>';

        function updateHeader(nd) {
            var hr = document.getElementById('header-right');
            while (hr.children.length > 0) {
                hr.removeChild(hr.lastChild);
            }
            buscar(nd, 3, hr);
            buscar(nd, 2, hr);
            buscar(nd, 1, hr);
            hr.style.fontSize = Math.round(50 * Reveal.getScale()) + '%';
            hr.style.fontSize = Math.max(Number.parseInt(getComputedStyle(hr).fontSize), 12) + 'px';
            var hl = document.getElementById('header-left');
            hl.style.fontSize = hr.style.fontSize;
        }

        function buscar(nd, level, hr) {
            if (!nd.classList.contains('level' + (level - 1))) {
                for (var n = nd; n != null; n = n.previousSibling) {
                    if (n.nodeType == Node.TEXT_NODE) {
                        continue;
                    }
                    var cl = n.classList;
                    if (cl.contains('level' + level)) {
                        var h = n.querySelector('h' + level);
                    } else if (cl.contains('level' + (level - 1))) {
                        break;
                    } else {
                        continue;
                    }
                    if (h == null || Reveal.getCurrentSlide().id == 'title-slide') {
                        hr.innerHTML = '';
                    } else {
                        var el = document.createElement('a');
                        var href = '#/' + n.id;
                        el.href = href;
                        el.innerHTML = h.innerHTML;
                        var a = el.querySelector('a');
                        if (a !== null) {
                            a.href = href;
                        }
                        if (hr.innerHTML != '') {
                            hr.innerHTML = ' &mdash; ' + hr.innerHTML;
                        }
                        hr.insertBefore(el, hr.firstChild);
                    }
                    break;
                }
            }
        }

        // On Reveal.js ready event, copy header/footer <div>
        // into each `.slide-background` <div>
        Reveal.addEventListener('ready', function(event) {
            var header = document.getElementById('header');
            document.querySelector('.reveal').appendChild(header);
            updateHeader(Reveal.getCurrentSlide());
        });

        Reveal.addEventListener('slidechanged', function(event) {
            // event.previousSlide, event.currentSlide, event.indexh, event.indexv
            updateHeader(event.currentSlide);
        });
    });
</script>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">Introducción</h1>
  <p class="author">Ricardo Pérez López</p>
  <p class="date">IES Doñana, curso 2020/2021</p>
</section>
<section id="TOC">
<ul>
<li><a href="#/conceptos-básicos"><span class="toc-section-number">1</span> Conceptos básicos</a></li>
<li><a href="#/paradigmas-de-programación"><span class="toc-section-number">2</span> Paradigmas de programación</a></li>
<li><a href="#/lenguajes-de-programación"><span class="toc-section-number">3</span> Lenguajes de programación</a></li>
<li><a href="#/traductores"><span class="toc-section-number">4</span> Traductores</a></li>
<li><a href="#/resolución-de-problemas-mediante-programación"><span class="toc-section-number">5</span> Resolución de problemas mediante programación</a></li>
<li><a href="#/entornos-integrados-de-desarrollo"><span class="toc-section-number">6</span> Entornos integrados de desarrollo</a></li>
</ul>
</section>

<section>
<section id="conceptos-básicos" class="title-slide slide level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Conceptos básicos</h1>
<!--

---

```{=html}
<script data-quiz>
quiz = {"info":{"name":"","main":""},"questions":[{"q":"What number is the letter A in the English alphabet?","a":[{"option":"8","correct":false},{"option":"14","correct":false},{"option":"1","correct":true},{"option":"23","correct":false}],"correct":"<p><span>\u00a1Eso es!</span>The letter A is the first letter in the alphabet!</p>","incorrect":"<p><span>Mmmm... no.</span>It's the first letter of the alphabet. Did you actually <em>go</em> to kindergarden?</p>"}]}</script>
```

-->
</section>
<section id="informática" class="title-slide slide level2" data-number="1.1">
<h2 data-number="1.1"><span class="header-section-number">1.1</span> Informática</h2>
<ul>
<li><p>Definición:</p>
<div class="caja">
<p><strong>Informática</strong>:</p>
<p>La ciencia que estudia los sistemas de procesamiento automático de la información, también llamados <strong>sistemas informáticos</strong>.</p>
</div></li>
<li><p>Estos sistemas están formados por:</p>
<ul>
<li><p>Elementos físicos (<strong>hardware</strong>).</p></li>
<li><p>Elementos lógicos (<strong>software</strong>).</p></li>
<li><p>Elementos humanos (profesionales y usuarios).</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="1.1.0.0.1">

<ul>
<li><p>El <em>hardware</em> es todo aquello que podemos tocar:</p>
<ul>
<li><p>Ordenadores</p></li>
<li><p>Soportes de almacenamiento</p></li>
<li><p>Redes de comunicaciones</p></li>
<li><p>…</p></li>
</ul></li>
<li><p>El <em>software</em> es todo lo que <strong>no</strong> podemos tocar:</p>
<ul>
<li><p>Datos</p></li>
<li><p>Programas</p></li>
</ul></li>
<li><p>Pero en este módulo, cuando hablemos de <em>software</em> en general, nos estaremos refiriendo a <strong>programas</strong>.</p></li>
</ul>
</section>
<section id="procesamiento-automático" class="title-slide slide level3" data-number="1.1.1">
<h3 data-number="1.1.1"><span class="header-section-number">1.1.1</span> Procesamiento automático</h3>
<ul>
<li>El procesamiento automático de la información siempre tiene el mismo esquema de funcionamiento:</li>
</ul>
<div class="centered">
<p><img data-src="images/procesamiento-automatico.svg" class="plain" style="width:80.0%" /></p>
</div>
<ul>
<li><p>El <strong>objetivo</strong> del procesamiento automático de la información es <strong>convertir los <em>datos de entrada</em> en <em>datos de salida</em></strong> mediante un <em>hardware</em> que ejecuta las instrucciones definidas por un <em>software</em> (<strong>programas</strong>).</p></li>
<li><p>Los programas gobiernan el funcionamiento del <em>hardware</em>, indicándole qué tiene que hacer y cómo.</p></li>
</ul>
<div class="caja">
<p>La <strong>Programación</strong> es la ciencia y el arte de diseñar dichos programas.</p>
</div>
</section>
<section id="ejemplos" class="title-slide slide level4" data-number="1.1.1.1">
<h4 data-number="1.1.1.1"><span class="header-section-number">1.1.1.1</span> Ejemplos</h4>
<ul>
<li><p>Calcular la suma de cinco números:</p>
<ul>
<li><p><strong>Entrada</strong>: los cinco números.</p></li>
<li><p><strong>Proceso</strong>: sumar cada número con el siguiente hasta acumular el resultado final.</p></li>
<li><p><strong>Salida</strong>: la suma calculada.</p></li>
</ul></li>
<li><p>Dada una lista de alumnos con sus calificaciones finales, obtener otra lista ordenada de mayor a menor por la calificación obtenida y que muestre sólo los alumnos aprobados:</p>
<ul>
<li><p><strong>Entrada</strong>: Una lista de pares <em>(Nombre del alumno, Calificación)</em>.</p></li>
<li><p><strong>Proceso</strong>: Eliminar de la lista los pares que tengan una calificación menor que cinco y ordenar la lista resultante de mayor a menor según la calificación.</p></li>
<li><p><strong>Salida</strong>: la lista ordenada de alumnos aprobados.</p></li>
</ul></li>
</ul>
</section>
<section id="ejercicio" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejercicio</h5>
<ol class="example" type="1">
<li><p>Identificar la entrada, el proceso y la salida en los siguientes supuestos:</p>
<ol type="a">
<li><p>Convertir una temperatura en grados Fahrenheit a Celsius.</p></li>
<li><p>Calcular el área de un triángulo a partir de su base y su altura.</p></li>
<li><p>Calcular el perímetro de un cuadrado.</p></li>
<li><p>Determinar si una llamada entrante en un teléfono móvil es sospechosa de <em>spam</em>.</p></li>
</ol></li>
</ol>
</section>



<section id="ordenador" class="title-slide slide level2" data-number="1.2">
<h2 data-number="1.2"><span class="header-section-number">1.2</span> Ordenador</h2>

</section>
<section id="definición" class="title-slide slide level3" data-number="1.2.1">
<h3 data-number="1.2.1"><span class="header-section-number">1.2.1</span> Definición</h3>
<div class="caja">
<p><strong>Ordenador</strong>:</p>
<p>Un ordenador es una máquina que procesa información automáticamente de acuerdo con un programa almacenado.</p>
</div>
<ul>
<li><p>Es una <em>máquina</em>.</p></li>
<li><p>Su función es <em>procesar información</em>.</p></li>
<li><p>El procesamiento se realiza de forma <em>automática</em>.</p></li>
<li><p>El procesamiento se realiza siguiendo un <em>programa</em> (<em>software</em>).</p></li>
<li><p>Este programa está <em>almacenado</em> en una memoria interna del mismo ordenador (arquitectura de <strong>Von Neumann</strong>).</p></li>
</ul>
</section>

<section id="funcionamiento-básico" class="title-slide slide level3" data-number="1.2.2">
<h3 data-number="1.2.2"><span class="header-section-number">1.2.2</span> Funcionamiento básico</h3>

</section>
<section id="elementos-funcionales" class="title-slide slide level4" data-number="1.2.2.1">
<h4 data-number="1.2.2.1"><span class="header-section-number">1.2.2.1</span> Elementos funcionales</h4>
<ul>
<li><p>Un ordenador consta de tres componentes principales:</p>
<ol type="1">
<li><p><strong>Unidad central de proceso (CPU) o procesador</strong></p>
<ul>
<li><p><em>Unidad aritmético-lógica (ALU)</em></p></li>
<li><p><em>Unidad de control (UC)</em></p></li>
</ul></li>
<li><p><strong>Memoria</strong></p>
<ul>
<li><p><em>Memoria principal</em> o central</p>
<ul>
<li><p><em>Memoria de acceso aleatorio (RAM)</em></p></li>
<li><p><em>Memoria de sólo lectura (ROM)</em></p></li>
</ul></li>
<li><p><em>Memoria secundaria</em> o externa</p></li>
</ul></li>
<li><p><strong>Dispositivos de E/S</strong></p>
<ul>
<li><p><em>Dispositivos de entrada</em></p></li>
<li><p><em>Dispositivos de salida</em></p></li>
</ul></li>
</ol></li>
</ul>
</section>

<section id="unidad-central-de-proceso-cpu-o-procesador" class="title-slide slide level4" data-number="1.2.2.2">
<h4 data-number="1.2.2.2"><span class="header-section-number">1.2.2.2</span> Unidad central de proceso (CPU) o procesador</h4>
<ul>
<li><p><strong>Unidad aritmético-lógica (ALU)</strong>:</p>
<p>Realiza los cálculos y el procesamiento numérico y lógico.</p></li>
<li><p><strong>Unidad de control (UC)</strong>:</p>
<p>Ejecuta de las instrucciones enviando las señales a las distintas unidades funcionales involucradas.</p></li>
</ul>
</section>

<section id="memoria" class="title-slide slide level4" data-number="1.2.2.3">
<h4 data-number="1.2.2.3"><span class="header-section-number">1.2.2.3</span> Memoria</h4>
<ul>
<li><p><strong>Memoria principal</strong> o central:</p>
<p>Almacena los datos y los programas que los manipulan.</p>
<p>Ambos (datos y programas) deben estar en la memoria principal para que la CPU pueda acceder a ellos.</p>
<p>Dos tipos:</p>
<ul>
<li><p><strong>Memoria de acceso aleatorio (RAM)</strong>:</p>
<p>Su contenido se borra al apagar el ordenador.</p></li>
<li><p><strong>Memoria de sólo lectura (ROM)</strong>:</p>
<p>Información permanente (ni se borra ni se puede cambiar).</p>
<p>Contiene la información esencial (datos y software) para que el ordenador pueda arrancar.</p></li>
</ul></li>
<li><p><strong>Memoria secundaria</strong> o externa:</p>
<p>La información no se pierde al apagar el ordenador.</p>
<p>Más lenta que la memoria principal, pero de mucha más capacidad.</p></li>
</ul>
</section>

<section id="dispositivos-de-es" class="title-slide slide level4" data-number="1.2.2.4">
<h4 data-number="1.2.2.4"><span class="header-section-number">1.2.2.4</span> Dispositivos de E/S</h4>
<ul>
<li><p><strong>Dispositivos de entrada</strong>:</p>
<p>Introducen datos en el ordenador (<em>ejemplos</em>: teclado, ratón, escáner…)</p></li>
<li><p><strong>Dispositivos de salida</strong>:</p>
<p>Vuelcan datos fuera del ordenador (<em>ejemplos</em>: pantalla, impresora…)</p></li>
<li><p><strong>Dispositivos de entrada/salida</strong>:</p>
<p>Actúan simultáneamente como dispositivos de entrada y de salida (<em>ejemplos</em>: pantalla táctil, adaptador de red…)</p></li>
<li><p>Los dispositivos que acceden a <strong>soportes de almacenamiento masivo</strong> (las <strong>memorias secundarias</strong>) también se pueden considerar dispositivos de E/S:</p>
<ul>
<li><p>Los soportes de <strong>sólo lectura</strong> se leen con dispositivos de entrada (<em>ejemplo</em>: discos ópticos).</p></li>
<li><p>Los soportes de <strong>lectura/escritura</strong> operan como dispositivos de entrada/salida (<em>ejemplos</em>: discos duros, pendrives, tarjetas SD…).</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="1.2.2.4.1">

<div class="centered">
<figure>
<img data-src="images/esquema-basico.svg" class="plain" style="width:80.0%" alt="Esquema básico de un ordenador" /><figcaption aria-hidden="true">Esquema básico de un ordenador</figcaption>
</figure>
</div>
<ul>
<li><p>El programa se <strong>carga</strong> de la memoria secundaria a la memoria principal.</p></li>
<li><p>Una vez allí, la CPU va <strong>extrayendo</strong> las instrucciones que forman el programa y las va <strong>ejecutando</strong> paso a paso, en un bucle continuo que se denomina <strong>ciclo de instrucción</strong>.</p></li>
<li><p>Durante la ejecución del programa, la CPU recogerá los datos de entrada desde los dispositivos de entrada y los almacenará en la memoria principal, para que las instrucciones puedan operar con ellos.</p></li>
<li><p>Finalmente, los datos de salida se volcarán hacia los dispositivos de salida.</p></li>
</ul>
</section>

<section id="ciclo-de-instrucción" class="title-slide slide level4" data-number="1.2.2.5">
<h4 data-number="1.2.2.5"><span class="header-section-number">1.2.2.5</span> Ciclo de instrucción</h4>
<ul>
<li><p>En la <strong>arquitectura Von Neumann</strong>, los programas se almacenan en la memoria principal junto con los datos (por eso también se denomina «arquitectura de <strong>programa almacenado</strong>»).</p></li>
<li><p>Una vez que el programa está cargado en memoria, la CPU repite siempre los mismos pasos:</p>
<ol>
<li><p>(<strong>Fetch</strong>) Busca la siguiente instrucción en la memoria principal.</p></li>
<li><p>(<strong>Decode</strong>) Decodifica la instrucción (identifica qué instrucción es y se prepara para su ejecución).</p></li>
<li><p>(<strong>Execute</strong>) Ejecuta la instrucción (envía las señales de control necesarias a las distintas unidades funcionales).</p></li>
</ol></li>
</ul>
</section>
<section class="slide level5" data-number="1.2.2.5.1">

<div class="centered">
<figure>
<img data-src="images/ciclo-instruccion.svg" class="plain" style="width:80.0%" alt="Ciclo de instrucción" /><figcaption aria-hidden="true">Ciclo de instrucción</figcaption>
</figure>
</div>
</section>

<section id="representación-de-información" class="title-slide slide level4" data-number="1.2.2.6">
<h4 data-number="1.2.2.6"><span class="header-section-number">1.2.2.6</span> Representación de información</h4>
<ul>
<li><p>En un sistema informático, toda la información se almacena y se manipula en forma de números.</p></li>
<li><p>Por tanto, para que un sistema informático pueda procesar información, primero hay que representar dicha información usando números, proceso que se denomina <strong>codificación</strong>.</p>
<div class="caja">
<p><strong>Codificación</strong>:</p>
<p>Proceso mediante el cual se representa información dentro de un sistema informático, asociando a cada dato uno o más valores numéricos.</p>
</div></li>
<li><p>Una codificación, por tanto, es una correspondencia entre un conjunto de datos y un conjunto de números llamado <strong>código</strong>. Al codificar, lo que hacemos es asociar a cada dato un determinado número dentro del código.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.2.2.6.1">

<ul>
<li><p>Hay muchos tipos de información (textos, sonidos, imágenes, valores numéricos…) y eso hace que pueda haber muchas formas de codificación.</p></li>
<li><p>Incluso un mismo tipo de dato (un número entero, por ejemplo) puede tener distintas codificaciones, cada una con sus características y propiedades.</p></li>
<li><p>Distinguimos la forma en la que se representa la información <em>internamente</em> en el sistema informático (<strong>codificación interna</strong>) de la que usamos para comunicar dicha información <em>desde y hacia el exterior</em> (<strong>codificación externa</strong> o <strong>de E/S</strong>).</p></li>
</ul>
<div class="centered">
<p><img data-src="images/codificaciones.svg" class="plain" style="width:80.0%" /></p>
</div>
</section>

<section id="codificación-interna" class="title-slide slide level4" data-number="1.2.2.7">
<h4 data-number="1.2.2.7"><span class="header-section-number">1.2.2.7</span> Codificación interna</h4>
<ul>
<li><p>Los ordenadores son <strong>sistemas electrónicos digitales</strong> que trabajan conmutando entre varios posibles estados de una determinada magnitud física (voltaje, intensidad de corriente, etc.).</p></li>
<li><p>Lo más sencillo y práctico es usar únicamente dos estados posibles.</p>
<p>Por ejemplo:</p>
<ul>
<li><p>0 V y 5 V de voltaje.</p></li>
<li><p>0 mA y 100 mA de intensidad de corriente.</p></li>
</ul></li>
<li><p>A cada uno de los dos posibles estados le hacemos corresponder (arbitrariamente) un valor numérico <strong>0</strong> ó <strong>1</strong>. A ese valor se le denomina <strong>bit</strong> (contracción de <em>binary digit</em>, dígito binario).</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.2.2.7.1">

<ul>
<li><p>Por ejemplo, la memoria principal de un ordenador está formada por millones de celdas, parecidas a microscópicos condensadores. Cada uno de estos condensadores puede estar cargado o descargado y, por tanto, es capaz de almacenar un bit:</p>
<ul>
<li>Condensador cargado: bit a 1</li>
<li>Condensador descargado: bit a 0</li>
</ul>
<div class="caja">
<p><strong>Bit</strong>:</p>
<p>Un bit es, por tanto, la unidad mínima de información que es capaz de almacenar y procesar un ordenador, y equivale a un <strong>dígito binario</strong>.</p>
</div></li>
<li><p>En la práctica, se usan unidades múltiplos del bit:</p>
<ul>
<li>1 byte = 8 bits</li>
<li>1 Kibibyte (KiB) = <span class="math inline">2^{10}</span> bytes = 1024 bytes</li>
<li>1 Mebibyte (MiB) = <span class="math inline">2^{20}</span> bytes = 1024 Kibibytes</li>
<li>1 Gibibyte (GiB) = <span class="math inline">2^{30}</span> bytes = 1024 Mebibytes</li>
<li>1 Tebibyte (TiB) = <span class="math inline">2^{40}</span> bytes = 1024 Gibibytes</li>
</ul></li>
</ul>
</section>

<section id="sistema-binario" class="title-slide slide level4" data-number="1.2.2.8">
<h4 data-number="1.2.2.8"><span class="header-section-number">1.2.2.8</span> Sistema binario</h4>
<ul>
<li><p>El sistema de numeración que usamos habitualmente los seres humanos es el <strong>decimal</strong> o sistema <strong>en base diez</strong>.</p></li>
<li><p>En ese sistema disponemos de diez dígitos distintos (0, 1, 2, 3, 4, 5, 6, 7, 8 y 9) y cada dígito en un determinado número tiene un peso que es múltiplo de una potencia de diez.</p>
<p>Por ejemplo: <span class="math display">243 = 2 \times 10^2 + 4 \times 10^1 + 3 \times 10^0</span></p></li>
<li><p>El sistema de numeración que usan los ordenadores es el <strong>sistema binario</strong> o sistema <strong>en base dos</strong>, en el cual disponemos sólo de dos dígitos (0 y 1) y cada peso es múltiplo de una potencia de dos.</p>
<p>Por ejemplo: <span class="math display">101 = 1 \times 2^2 + 0 \times 2^1 + 1 \times 2^0</span></p></li>
</ul>
</section>
<section class="slide level5" data-number="1.2.2.8.1">

<ul>
<li><p>Generalmente, los <strong>números naturales</strong> se codifican internamente mediante su representación en binario.</p></li>
<li><p>Los <strong>números enteros</strong> se suelen codificar mediante:</p>
<ul>
<li><p>Bit de signo (signo y magnitud)</p></li>
<li><p>Complemento a uno</p></li>
<li><p>Complemento a dos</p></li>
</ul></li>
<li><p>Los <strong>números reales</strong> se pueden codificar mediante:</p>
<ul>
<li><p>Coma fija</p></li>
<li><p>Coma flotante</p>
<ul>
<li><p>Simple precisión</p></li>
<li><p>Doble precisión</p></li>
</ul></li>
<li><p>Decimal codificado en binario (BCD)</p></li>
</ul></li>
</ul>
</section>

<section id="codificación-externa" class="title-slide slide level4" data-number="1.2.2.9">
<h4 data-number="1.2.2.9"><span class="header-section-number">1.2.2.9</span> Codificación externa</h4>
<ul>
<li><p>La información enviada desde y hacia el exterior del sistema informático se representa en forma de <strong>cadenas de caracteres</strong>.</p></li>
<li><p>Para representar cadenas de caracteres y comunicarse con el exterior, el ordenador utiliza <strong>códigos de E/S</strong> o <strong>códigos externos</strong>.</p></li>
<li><p>A cada carácter (letra, dígito, signo de puntuación, símbolo especial…) le corresponde un <em>código</em> (que es un número) dentro de un <strong>conjunto de caracteres</strong>.</p></li>
<li><p>Existen conjuntos de caracteres:</p>
<ul>
<li><p>De <strong>longitud fija</strong>: a todos los caracteres les corresponden un código, y todos los códigos tienen la misma longitud (mismo número de bytes).</p></li>
<li><p>De <strong>longitud variable</strong>: en el mismo conjunto de caracteres hay códigos más largos y más cortos (por tanto, hay caracteres que ocupan más bytes que otros).</p></li>
</ul></li>
</ul>
</section>

<section id="ascii" class="title-slide slide level4" data-number="1.2.2.10">
<h4 data-number="1.2.2.10"><span class="header-section-number">1.2.2.10</span> ASCII</h4>
<ul>
<li><p><em>American Standard Code for Information Interchange</em>.</p></li>
<li><p>El conjunto de caracteres ASCII (o <strong>código ASCII</strong>) es el más implantado en el <em>hardware</em> de los equipos informáticos.</p></li>
<li><p>Es la base de otros códigos más modernos, como el ISO-8859-1 o el Unicode.</p></li>
<li><p>Es un código de 7 bits:</p>
<ul>
<li><p>Cada carácter ocupa 7 bits.</p></li>
<li><p>Hay <span class="math inline">2^7 = 128</span> caracteres posibles.</p></li>
<li><p>Los 32 primeros códigos (del 0 al 31) son no imprimibles (códigos de control).</p></li>
</ul></li>
<li><p>El ISO-8859-1 es un código de 8 bits que extiende el ASCII con un bit más para contener caracteres latinos.</p></li>
</ul>
</section>

<section id="unicode" class="title-slide slide level4" data-number="1.2.2.11">
<h4 data-number="1.2.2.11"><span class="header-section-number">1.2.2.11</span> Unicode</h4>
<ul>
<li><p>Con 8 bits (y con 7 bits aún menos) no es posible representar todos los posibles caracteres de todos los sistemas de escritura usados en el mundo.</p></li>
<li><p>Unicode es el estándar de codificación de caracteres más completo y universal en la actualidad.</p></li>
<li><p>Cada carácter en Unicode se define mediante un identificador numérico llamado <em>code point</em>.</p></li>
<li><p>Unicode define tres formas de codificación:</p>
<ul>
<li><p><strong>UTF-8</strong>: codificación de 8 bits, de longitud variable (cada <em>code point</em> puede ocupar de 1 a 4 bytes). <strong>El más usado en la actualidad.</strong></p></li>
<li><p><strong>UTF-16</strong>: codificación de 16 bits, de longitud variable (cada <em>code point</em> puede ocupar 1 ó 2 palabras de 16 bits).</p></li>
<li><p><strong>UTF-32</strong>: codificación de 32 bits, de longitud fija (cada <em>code point</em> ocupa 1 palabra de 32 bits).</p></li>
</ul></li>
</ul>
</section>



<section id="problema" class="title-slide slide level2" data-number="1.3">
<h2 data-number="1.3"><span class="header-section-number">1.3</span> Problema</h2>
<ul>
<li><p>Escribimos programas para que el ordenador procese información de forma automática.</p></li>
<li><p>Pero ese procesamiento automático se lleva a cabo por una razón: <strong>resolver un problema</strong> usando un ordenador.</p></li>
<li><p>Si un problema es <strong>resoluble</strong> usando un ordenador (<em>no todos lo son</em>), podremos escribir un programa que lo resuelva.</p></li>
<li><p>Estos son los problemas que nos interesa estudiar en Programación.</p></li>
</ul>
</section>
<section id="generalización" class="title-slide slide level3" data-number="1.3.1">
<h3 data-number="1.3.1"><span class="header-section-number">1.3.1</span> Generalización</h3>
<ul>
<li><p>En programación nos interesa siempre resolver problemas generales y no casos particulares.</p></li>
<li><p>Por ejemplo, el problema de calcular la suma de 4 y 3 es un <strong>problema particular</strong>, porque una solución al problema sólo servirá para resolver <em>ese</em> problema en concreto, y no servirá para sumar otro par de números (el 9 y 5, por ejemplo).</p></li>
<li><p>En cambio, el problema de calcular la suma de cualquier par de números enteros es un <strong>problema general</strong>, ya que una solución al problema serviría para resolver cualquier caso particular de ese problema general.</p>
<ul>
<li>Por ejemplo, esa solución al problema general me serviría para calcular la suma de 4 y 3, de 9 y 5, de 12 y 38, … De hecho, infinitos casos particulares.</li>
</ul></li>
</ul>
</section>

<section id="ejemplares-de-un-problema" class="title-slide slide level3" data-number="1.3.2">
<h3 data-number="1.3.2"><span class="header-section-number">1.3.2</span> Ejemplares de un problema</h3>
<ul>
<li><p>A los casos particulares de un problema general se les denomina <strong>ejemplares</strong> del problema.</p>
<ul>
<li>Por ejemplo, la pareja <span class="math inline">(4, 3)</span> es un ejemplar del problema general de sumar dos números enteros.</li>
</ul></li>
<li><p>Normalmente, un problema consistirá en una colección infinita de ejemplares.</p>
<ul>
<li>Pero también hay problemas finitos (aunque muy grandes) como el de jugar perfectamente al ajedrez.</li>
</ul></li>
<li><p>La solución a un problema debe resolver correctamente todos los ejemplares del mismo, es decir, debe resolver el problema general de forma que sirva para todos sus ejemplares.</p></li>
</ul>
</section>

<section id="dominio-de-definición" class="title-slide slide level3" data-number="1.3.3">
<h3 data-number="1.3.3"><span class="header-section-number">1.3.3</span> Dominio de definición</h3>
<ul>
<li><p>El <strong>dominio de definición</strong> de un problema describe con precisión el conjunto de sus ejemplares.</p>
<ul>
<li>Por ejemplo: en el problema de sumar dos números enteros, sus ejemplares serán cualquier pareja de números enteros (no vale que los números sean reales o fracciones). Ese es su dominio de definición.</li>
</ul></li>
<li><p>La solución al problema debe centrarse en el dominio de definición del problema, y no está obligado a resolver ejemplares que se encuentren fuera de dicho dominio de definición.</p>
<ul>
<li>Por ejemplo: un programa que resuelva correctamente el problema de sumar dos números enteros no tiene por qué funcionar correctamente si intentamos usarlo para sumar dos fracciones.</li>
</ul></li>
</ul>
</section>

<section id="jerarquías-de-generalización" class="title-slide slide level3" data-number="1.3.4">
<h3 data-number="1.3.4"><span class="header-section-number">1.3.4</span> Jerarquías de generalización</h3>
<ul>
<li><p>Se dice que un problema <span class="math inline">P</span> es <strong>más general</strong> que un problema <span class="math inline">Q</span> (o bien, que es una <strong>generalización</strong> del problema <span class="math inline">Q</span>) si los ejemplares de <span class="math inline">Q</span> también son ejemplares de <span class="math inline">P</span>, y además hay ejemplares de <span class="math inline">P</span> que no lo son de <span class="math inline">Q</span>.</p>
<ul>
<li>Es otra forma de decir que el conjunto de ejemplares de <span class="math inline">Q</span> es un <em>subconjunto propio</em> del conjunto de ejemplares de <span class="math inline">P</span>.</li>
</ul></li>
<li><p>Igualmente, se dice que <span class="math inline">Q</span> es un problema <strong>menos general</strong> o <strong>más particular</strong> que el problema <span class="math inline">P</span> (o bien, que es una <strong>especialización</strong> del problema <span class="math inline">P</span>).</p></li>
<li><p>Este concepto resulta interesante porque, si tenemos una solución al problema <span class="math inline">P</span>, podremos usarla para resolver el problema <span class="math inline">Q</span>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.3.4.0.1">

<div class="centered">
<figure>
<img data-src="images/jerarquias-generalizacion.svg" class="plain" style="width:50.0%" alt="P es un problema más general que Q" /><figcaption aria-hidden="true"><span class="math inline">P</span> es un problema más general que <span class="math inline">Q</span></figcaption>
</figure>
</div>
</section>
<section class="slide level5" data-number="1.3.4.0.2">

<ul>
<li><p>Por ejemplo, el problema de calcular la suma de <em>tres</em> números enteros es un problema <strong>más general</strong> que el de sumar <em>dos</em> números enteros, porque éste último se puede considerar un caso particular del primero (haciendo que uno de los tres números a sumar valga cero).</p></li>
<li><p>Por tanto, si tenemos un método para resolver el problema más general (el de sumar tres números) podemos usarlo para resolver uno menos general (el de sumar dos números).</p></li>
<li><p>En este caso, basta con hacer que uno de los tres números sea cero y los otros dos sean los números a sumar:</p></li>
</ul>
<div class="centered">
<figure>
<img data-src="images/sumar-dos-numeros.svg" class="plain" style="width:50.0%" alt="Sumar dos números es un caso particular de sumar tres" /><figcaption aria-hidden="true">Sumar dos números es un caso particular de sumar tres</figcaption>
</figure>
</div>
</section>
<section id="ejercicios" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejercicios</h5>
<ol start="2" class="example" type="1">
<li><p>Con cada uno de los siguientes problemas, dar al menos un ejemplar del mismo e inventar un problema más general:</p>
<ol type="a">
<li><p>Calcular cuántos días han pasado entre dos fechas del mismo año.</p></li>
<li><p>Calcular el perímetro de un cuadrado a partir de la longitud de uno de sus lados.</p></li>
</ol></li>
<li><p>Inventar un problema más particular para el problema de sumar dos fracciones de números enteros y dar dos ejemplares distintos de cada uno de los dos problemas.</p></li>
<li><p>Dado el siguiente problema: «Calcular cuántos picos y cuántas patas hay en una granja con <span class="math inline">X</span> gallinas y <span class="math inline">Y</span> cerdos», determinar si los siguientes casos son <em>ejemplares</em> del problema o bien son <em>especializaciones</em> del problema:</p>
<ol type="a">
<li><p>Calcular cuántos picos y cuántas patas hay en una granja con 5 gallinas y 7 cerdos.</p></li>
<li><p>Calcular cuántas patas hay en una granja con <span class="math inline">Z</span> cerdos.</p></li>
</ol></li>
</ol>
</section>


<section id="algoritmo" class="title-slide slide level2" data-number="1.4">
<h2 data-number="1.4"><span class="header-section-number">1.4</span> Algoritmo</h2>

</section>
<section id="definición-1" class="title-slide slide level3" data-number="1.4.1">
<h3 data-number="1.4.1"><span class="header-section-number">1.4.1</span> Definición</h3>
<div class="caja">
<p><strong>Algoritmo</strong>:</p>
<p>Un algoritmo es un método para resolver un problema.</p>
</div>
<ul>
<li><p>Está formado por una secuencia de pasos o <strong>instrucciones</strong> que se deben seguir (o <strong>ejecutar</strong>) para resolver el problema.</p></li>
<li><p>La palabra «algoritmo» proviene de <strong>Mohammed Al-Khowârizmi</strong>, matemático persa que vivió durante el siglo IX y reconocido por definir una serie de reglas paso a paso para sumar, restar, multiplicar y dividir números decimales.</p></li>
<li><p><strong>Euclides</strong>, el gran matemático griego (del siglo IV a. C.) que inventó un método para encontrar el máximo común divisor de dos números, se considera con Al-Khowârizmi el otro gran padre de la Algorítmica (la ciencia que estudia los algoritmos).</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.4.1.0.1">

<ul>
<li><p>El estudio de los algoritmos es importante porque la resolución de un problema exige el diseño de un algoritmo que lo resuelva.</p></li>
<li><p>Una vez diseñado el algoritmo, se traduce a un programa informático usando un <em>lenguaje de programación</em>.</p></li>
<li><p>Finalmente, un ordenador ejecuta dicho programa.</p></li>
</ul>
<div class="centered">
<figure>
<img data-src="images/resolucion-problema.svg" class="plain" style="width:80.0%" alt="Resolución de un problema" /><figcaption aria-hidden="true">Resolución de un problema</figcaption>
</figure>
</div>
</section>
<section class="slide level5" data-number="1.4.1.0.2">

<script data-quiz>
quiz = {"info":{"name":"","main":""},"questions":[{"q":"\u00bfQu\u00e9 es lo primero que hay que hacer a la hora de resolver un problema mediante un programa inform\u00e1tico?","a":[{"option":"Dise\u00f1ar el algoritmo","correct":false},{"option":"Estudiar el problema","correct":true},{"option":"Ejecutar el programa","correct":false},{"option":"Escribir el programa","correct":false}],"correct":"<p><span>\u00a1Eso es!</span>Lo primero que hay que hacer es estudiar el problema que hay que resolver.</p>","incorrect":"<p><span>Mmmm... no.</span>Hay algo que debes hacer antes.</p>"},{"q":"\u00bfY lo segundo?","a":[{"option":"Ejecutar el programa","correct":false},{"option":"Estudiar el problema","correct":false},{"option":"Escribir el programa","correct":false},{"option":"Dise\u00f1ar el algoritmo","correct":true}],"correct":"<p><span>\u00a1Eso es!</span>Lo segundo es dise\u00f1ar el algoritmo que resuelva el problema.</p>","incorrect":"<p><span>Mmmm... no.</span>No es correcto.</p>"},{"q":"\u00bfY lo tercero?","a":[{"option":"Estudiar el problema","correct":false},{"option":"Ejecutar el programa","correct":false},{"option":"Escribir el programa","correct":true},{"option":"Dise\u00f1ar el algoritmo","correct":false}],"correct":"<p><span>\u00a1Eso es!</span>Lo tercero es traducir el algoritmo en un programa usando un lenguaje de programaci\u00f3n.</p>","incorrect":"<p><span>Mmmm... no.</span>No es correcto.</p>"},{"q":"\u00bfY por \u00faltimo?","a":[{"option":"Escribir el programa","correct":false},{"option":"Ejecutar el programa","correct":true},{"option":"Estudiar el problema","correct":false},{"option":"Dise\u00f1ar el algoritmo","correct":false}],"correct":"<p><span>\u00a1Eso es!</span>Por \u00faltimo, se ejecuta el programa en un ordenador.</p>","incorrect":"<p><span>Mmmm... no.</span>Eso se debe hacer antes.</p>"}]}</script>
</section>

<section id="características" class="title-slide slide level3" data-number="1.4.2">
<h3 data-number="1.4.2"><span class="header-section-number">1.4.2</span> Características</h3>
<ul>
<li><p>Un algoritmo debe ser:</p>
<ul>
<li><p><strong>Preciso</strong>: debe expresarse de forma no ambigua. La precisión afecta por igual a dos aspectos:</p>
<ul>
<li><p>Al <em>orden</em> de los pasos que han de llevarse a cabo.</p></li>
<li><p>Al <em>contenido</em> de los pasos, pues en cada uno hay que saber qué hacer exactamente.</p></li>
</ul></li>
<li><p><strong>Determinado</strong>: si se sigue un algoritmo dos veces, se debe obtener el mismo resultado cada vez.</p></li>
<li><p><strong>Finito</strong>: debe terminar en algún momento, es decir, debe tener un número finito de pasos.</p></li>
</ul></li>
</ul>
</section>

<section id="representación" class="title-slide slide level3" data-number="1.4.3">
<h3 data-number="1.4.3"><span class="header-section-number">1.4.3</span> Representación</h3>
<div class="columns">
<div class="column" style="width:50%;">
<ul>
<li><p>Un algoritmo se puede describir usando el <strong>lenguaje natural</strong>, es decir, cualquier idioma humano.</p></li>
<li><p>¿Qué <span style="color:red">problema</span> tiene esta forma de representación?</p>
<div class="centered">
<p><span style="color:red"><strong>Ambigüedad</strong></span></p>
</div></li>
<li><p>En ciertos contextos la ambigüedad es asumible, pero <strong>NO</strong> cuando el destinatario es un ordenador.</p></li>
<li><p>¿Podemos decir que esta receta de cocina es un algoritmo?</p></li>
</ul>
</div><div class="column" style="width:50%;">
<div class="caja">
<div style="font-size: 90%">
<p><strong>Instrucciones para hacer una tortilla</strong>:</p>
<ol type="1">
<li>Coger dos huevos.</li>
<li>Encender el fuego.</li>
<li>Echar aceite a la sartén.</li>
<li>Batir los huevos.</li>
<li>Echar los huevos batidos en la sartén.</li>
<li>Esperar a que se haga por debajo.</li>
<li>Dar la vuelta a la tortilla.</li>
<li>Esperar de nuevo.</li>
<li>Sacar cuando esté lista.</li>
</ol>
<p><strong>Fin</strong></p>
</div>
</div>
</div>
</div>
</section>
<section id="ordinograma" class="title-slide slide level4" data-number="1.4.3.1">
<h4 data-number="1.4.3.1"><span class="header-section-number">1.4.3.1</span> Ordinograma</h4>
<ul>
<li><p>Representación gráfica que describe un algoritmo en forma de diagrama de flujo.</p></li>
<li><p>Las flechas indican el orden de ejecución de las instrucciones.</p></li>
<li><p>Los nodos condicionales (los rombos) indican que la ejecución se bifurca a uno u otro camino dependiendo de si se cumple o no una condición.</p></li>
</ul>
</section>

<section id="ejemplo" class="title-slide slide level4" data-number="1.4.3.2">
<h4 data-number="1.4.3.2"><span class="header-section-number">1.4.3.2</span> Ejemplo</h4>
<p>Determinar cuál es el máximo de dos números</p>
<div class="centered">
<p><img data-src="images/maximo.svg" class="plain" style="width:50.0%" /></p>
</div>
</section>

<section id="pseudocódigo" class="title-slide slide level4" data-number="1.4.3.3">
<h4 data-number="1.4.3.3"><span class="header-section-number">1.4.3.3</span> Pseudocódigo</h4>
<ul>
<li><p>Es un <strong>lenguaje <em>semi-formal</em></strong>, a medio camino entre el lenguaje natural y el lenguaje que entendería un ordenador (lenguaje de programación).</p></li>
<li><p>Está pensado para ser interpretado por una persona y no por un ordenador.</p></li>
<li><p>En general, no se tienen en cuenta las limitaciones impuestas por el <em>hardware</em> (CPU, memoria…) o el <em>software</em> (tamaño máximo de los datos, codificación interna…), siempre y cuando no sea importante el estudio de la eficiencia o la complejidad del algoritmo.</p></li>
<li><p>En ese sentido, se usa como un lenguaje de programación <em>idealizado</em>.</p></li>
</ul>
</section>

<section id="ejemplo-1" class="title-slide slide level4" data-number="1.4.3.4">
<h4 data-number="1.4.3.4"><span class="header-section-number">1.4.3.4</span> Ejemplo</h4>
<div class="line-block"><strong>Algoritmo</strong>: Obtener el mayor de dos números<br />
<br />
1. <span class="math inline">X \leftarrow</span> <strong>leer</strong> número<br />
2. <span class="math inline">Y \leftarrow</span> <strong>leer</strong> número<br />
3. <strong>si</strong> <span class="math inline">X &gt; Y</span> <strong>entonces</strong> <strong>saltar</strong> al paso 6<br />
4. <strong>escribir</strong> “Y es mayor que X”<br />
5. <strong>saltar</strong> al paso 7<br />
6. <strong>escribir</strong> “X es mayor que Y”<br />
7. <strong>fin</strong></div>
</section>


<section id="cualidades-deseables" class="title-slide slide level3" data-number="1.4.4">
<h3 data-number="1.4.4"><span class="header-section-number">1.4.4</span> Cualidades deseables</h3>
<ul>
<li><p><strong>Corrección</strong>: El algoritmo debe solucionar correctamente el problema.</p></li>
<li><p><strong>Claridad</strong>: Debe ser legible y comprensible para el ser humano.</p></li>
<li><p><strong>Generalidad</strong>: Un algoritmo debe resolver problemas generales. Por ejemplo, un algoritmo que sume dos números enteros debe servir para sumar cualquier pareja de números enteros, y no, solamente, para sumar dos números determinados, como pueden ser el 3 y el 5.</p></li>
<li><p><strong>Eficiencia</strong>: Un algoritmo es mejor cuanto menos recursos (tiempo, espacio…) necesita para resolver el problema. Por eso no debe realizar pasos innecesarios ni recordar más información de la necesaria.</p></li>
<li><p><strong>Sencillez</strong>: Hay que intentar que la solución sea sencilla, aun a costa de perder un poco de eficiencia; es decir, se tiene que buscar un equilibrio entre la claridad y la eficiencia.</p></li>
<li><p><strong>Modularidad</strong>: Un algoritmo puede formar parte de la solución a un problema mayor. A su vez, dicho algoritmo puede descomponerse en otros si esto favorece a la claridad del mismo.</p></li>
</ul>
</section>

<section id="computabilidad" class="title-slide slide level3" data-number="1.4.5">
<h3 data-number="1.4.5"><span class="header-section-number">1.4.5</span> Computabilidad</h3>
<ul>
<li><p>¿Todos los problemas pueden resolverse de forma algorítmica?</p></li>
<li><p>Dicho de otra forma, queremos saber lo siguiente:</p>
<div class="caja centered">
<p>Dado un problema, ¿existe un algoritmo que lo resuelva?</p>
</div></li>
</ul>
</section>
<section class="slide level5" data-number="1.4.5.0.1">

<ul>
<li><p>Todo problema <span class="math inline">P</span> lleva asociada una función <span class="math inline">f_P: D \rightarrow R</span>, donde:</p>
<ul>
<li><p><span class="math inline">D</span> es el conjunto de los datos de entrada.</p></li>
<li><p><span class="math inline">R</span> es el conjunto de los resultados del problema.</p></li>
</ul></li>
<li><p>Asimismo, todo algoritmo <span class="math inline">A</span> lleva asociada una función <span class="math inline">f_A</span>.</p></li>
<li><p>La pregunta es: ¿existe un algoritmo A tal que <span class="math inline">f_A = f_P</span>?</p></li>
<li><p>Y de ahí vamos a la pregunta general:</p>
<div class="caja centered">
<p>¿Toda función <span class="math inline">f</span> es computable (resoluble algorítmicamente)?</p>
</div></li>
</ul>
</section>
<section class="slide level5" data-number="1.4.5.0.2">

<p>La respuesta es que <strong>NO</strong>.</p>
<ul>
<li>Se puede demostrar que hay más funciones que algoritmos, por lo que <strong>existen funciones que no se pueden computar mediante un algoritmo</strong> (no son computables).</li>
</ul>
</section>
<section class="slide level5" data-number="1.4.5.0.3">

<ul>
<li><p>La dificultad que tiene estudiar la computabilidad de funciones está en que no tenemos una definición formal de «<em>algoritmo</em>».</p></li>
<li><p>A comienzos del S. XX, se crearon (independientemente uno del otro) dos formalismos matemáticos para representar el concepto de <em>algoritmo</em>:</p>
<ul>
<li><p>Alonzo Church creó el <strong>cálculo lambda</strong>.</p></li>
<li><p>Alan Turing creó la <strong>máquina de Turing</strong>.</p></li>
</ul></li>
<li><p>Posteriormente se demostró que los dos formalismos eran totalmente equivalentes y eran, además, equivalentes a las <strong>gramáticas formales</strong>.</p></li>
<li><p>Esto llevó a formular la llamada <strong>tesis de Church-Turing</strong>, que dice que</p>
<div class="caja centered">
<p>«<em>Todo algoritmo es equivalente a una máquina de Turing.</em>»</p>
</div></li>
<li><p>La tesis de Church-Turing es indemostrable pero prácticamente toda la comunidad científica la acepta como verdadera.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.4.5.0.4">

<ul>
<li><p>Usando esos formalismos, se pudo demostrar que hay problemas que no se pueden resolver mediante algoritmos.</p></li>
<li><p>Uno de los problemas que no tienen una solución algorítmica es el llamado <strong>problema de la parada</strong>:</p>
<div class="caja">
<p><strong>Problema de la parada</strong>:</p>
<p>Dado un algoritmo y un posible dato de entrada, determinar (a priori, sin ejecutarlo previamente) si el algoritmo se detendrá y producirá un valor de salida.</p>
</div></li>
<li><p>Nunca podremos hacer un algoritmo que resuelva el problema de la parada en términos generales (en casos particulares sí se puede).</p></li>
</ul>
</section>

<section id="corrección" class="title-slide slide level3" data-number="1.4.6">
<h3 data-number="1.4.6"><span class="header-section-number">1.4.6</span> Corrección</h3>
<ul>
<li><p>¿Cómo sabemos si un algoritmo es <strong>correcto</strong>?</p></li>
<li><p>¿Qué significa eso de que un algoritmo sea correcto?</p></li>
<li><p>Supongamos que, para un problema <span class="math inline">P</span>, existe un algoritmo <span class="math inline">A</span>. Lo que tenemos que averiguar es si se cumple: <span class="math display">f_P = f_A</span></p></li>
<li><p>¿Cómo lo hacemos?</p>
<ul>
<li><p>Si el conjunto <span class="math inline">D</span> de datos de entrada es <strong>finito</strong>, podríamos comparar todos los resultados de salida con los resultados esperados y ver si coinciden (<strong>pruebas exhaustivas</strong>). Normalmente es imposible.</p></li>
<li><p>Si <span class="math inline">D</span> es <strong>infinito</strong>, es imposible realizar una comprobación empírica de la corrección del algoritmo (se pueden realizar <strong>pruebas no exhaustivas</strong> que comprueban algunos datos de entrada pero no todos, por lo que no demuestran que el algoritmo es correcto pero sí pueden demostrar que es incorrecto).</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="1.4.6.0.1">

<ul>
<li><p>Lo mejor (pero más difícil) es recurrir a <strong>métodos formales</strong>:</p>
<ul>
<li><p><strong>Diseño a priori</strong>: se construye el algoritmo en base a una demostración (lo que se denomina también <strong>demostración constructiva</strong>).</p></li>
<li><p><strong>Diseño a posteriori</strong>: se construye el algoritmo de forma más o menos intuitiva y, una vez diseñado, tratar de demostrar su corrección.</p></li>
</ul></li>
<li><p>En ambos casos, es importante definir con mucha precisión qué problema queremos resolver.</p></li>
<li><p>Para ello, se describe el problema mediante una <strong>especificación formal</strong>.</p></li>
</ul>
</section>

<section id="complejidad" class="title-slide slide level3" data-number="1.4.7">
<h3 data-number="1.4.7"><span class="header-section-number">1.4.7</span> Complejidad</h3>
<ul>
<li><p>¿Cómo de <strong>eficiente</strong> es un algoritmo?</p></li>
<li><p>La eficiencia de un algoritmo se mide en función del <strong>consumo de recursos</strong> que necesita el algoritmo para su ejecución.</p>
<ul>
<li>Los principales recursos son el <strong>tiempo</strong> y el <strong>espacio</strong>.</li>
</ul></li>
<li><p>Dados dos algoritmos distintos que resuelvan el mismo problema, en general nos interesará usar el más eficiente de ellos (al margen de otras consideraciones, como la claridad, la legibilidad, la mantenibilidad, la reusabilidad, etc.)</p></li>
<li><p>¿Cómo medimos la eficiencia de un algoritmo?</p></li>
<li><p>¿Cómo comparamos la eficiencia de dos algoritmos?</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.4.7.0.1">

<ul>
<li><p>El <strong>análisis de algoritmos</strong> estudia la eficiencia de un algoritmo desde un punto de vista abstracto (independiente de la máquina, el lenguaje de programación, la carga de trabajo, etc.).</p></li>
<li><p>Define el consumo de recursos <strong>en función del tamaño del ejemplar del problema a resolver</strong>.</p></li>
<li><p>Por ejemplo:</p>
<ul>
<li><p>Supongamos el problema de comprobar cuántas vocales hay en una frase.</p></li>
<li><p>La <strong>entrada</strong> al algoritmo será la frase (una cadena de caracteres).</p></li>
<li><p>La <strong>salida</strong> será el número de vocales que hay en la cadena.</p></li>
<li><p>Cada una de las posibles cadenas de entrada representan un <strong>ejemplar</strong> del problema a resolver.</p></li>
<li><p>Cabe esperar que el algoritmo tarde más en dar el resultado cuanto más larga sea la cadena de entrada.</p></li>
<li><p>Por tanto, el <strong>tamaño del ejemplar</strong> será la longitud de la cadena.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="1.4.7.0.2">

<ul>
<li><p>Si tenemos dos algoritmos <span class="math inline">A</span> y <span class="math inline">B</span> (que resuelven el mismo problema anterior) con tiempos de ejecución <span class="math display">t_A(n) \simeq 3n^2</span> y <span class="math display">t_B(n) \simeq
4n</span> siendo <span class="math inline">n</span> la longitud de la cadena de entrada, el algoritmo <span class="math inline">B</span> se considera más eficiente que <span class="math inline">A</span> ya que su tiempo de ejecución es menor a medida que aumenta <span class="math inline">n</span>.</p></li>
<li><p>Esto es así aunque hay algún caso (como el de <span class="math inline">n = 1</span>) donde el algoritmo <span class="math inline">A</span> es más eficiente que <span class="math inline">B</span>, ya que la constante multiplicativa 3 que aparece en <span class="math inline">t_A(n)</span> es más pequeña que la constante 4 que aparece en <span class="math inline">t_B(n)</span>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.4.7.0.3">

<div class="centered">
<figure>
<img data-src="images/grafica-funciones.svg" class="plain" style="width:60.0%" alt="Representación gráfica de 3n^2 y 4n" /><figcaption aria-hidden="true">Representación gráfica de <span class="math inline">3n^2</span> y <span class="math inline">4n</span></figcaption>
</figure>
</div>
</section>
<section class="slide level5" data-number="1.4.7.0.4">

<ul>
<li><p>En general, no estamos interesados en las constantes concretas que puedan aparecer en las <span class="math inline">t(n)</span>, ni en el valor que éstas puedan tomar para un <span class="math inline">n</span> concreto, sino que tan sólo nos interesa la <strong>forma</strong> que puedan tener las funciones <span class="math inline">t(n)</span> y cómo crecen a medida que aumenta <span class="math inline">n</span>.</p></li>
<li><p>Por eso, clasificamos el consumo de recursos usando una <strong>notación asintótica</strong>, con la cual podemos ordenar las funciones <span class="math inline">t(n)</span> según determinados <em>órdenes de crecimiento</em> cuando <span class="math inline">n</span> crece hasta el infinito.</p></li>
<li><p>En el ejemplo anterior, tenemos <span class="math display">t_A(n) \in O(n^2)</span> que se lee «<span class="math inline">t_A(n)</span> es del orden de <span class="math inline">n^2</span>», y <span class="math display">t_B(n) \in O(n)</span> que se lee «<span class="math inline">t_B(n)</span> es del orden de <span class="math inline">n</span>». Podemos decir también que <span class="math inline">A</span> tiene <strong>tiempo cuadrático</strong> y <span class="math inline">B</span> <strong>tiempo lineal</strong>.</p></li>
<li><p>Como <span class="math inline">O(n) \subset O(n^2)</span> (porque <span class="math inline">n^2</span> crece más deprisa que <span class="math inline">n</span>), podemos concluir que <span class="math inline">t_B(n) &lt; t_A(n)</span> para un valor de <span class="math inline">n</span> suficientemente grande (o sea, <em>asintóticamente</em>). Por tanto, <span class="math inline">B</span> es un algoritmo más eficiente que <span class="math inline">A</span>.</p></li>
</ul>
</section>


<section id="programa" class="title-slide slide level2" data-number="1.5">
<h2 data-number="1.5"><span class="header-section-number">1.5</span> Programa</h2>
<ul>
<li><p>Definición:</p>
<div class="caja">
<p><strong>Programa</strong>:</p>
<p>Un programa es la codificación de un algoritmo en un lenguaje de programación.</p>
</div></li>
<li><p>Si el algoritmo está bien definido, <em>traducir</em> ese algoritmo en un programa equivalente puede resultar trivial.</p></li>
<li><p>El texto del programa escrito en ese lenguaje de programación se denomina <strong>código fuente</strong>. Programar, al final, consiste en escribir (<em>codificar</em>) el código fuente de nuestro programa.</p></li>
<li><p>Los algoritmos están pensados para ser entendidos por un ser humano, mientras que los programas se escriben para ser interpretados y ejecutados por un ordenador.</p></li>
<li><p>Por ello, toda posible ambigüedad que pudiera quedar en el algoritmo debe eliminarse al codificarlo en forma de programa.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.5.0.0.1">

<ul>
<li><p>Programar depende mucho de las características del lenguaje de programación elegido.</p></li>
<li><p>Lo ideal es usar un lenguaje que se parezca lo más posible al <em>pseudolenguaje</em> utilizado para describir el correspondiente algoritmo.</p></li>
<li><p>En un programa también hay que considerar <strong>aspectos y limitaciones</strong> que no se suelen tener en cuenta en un algoritmo:</p>
<ul>
<li><p><strong>El tamaño de los datos en memoria:</strong> por ejemplo, en un lenguaje de programación suele haber límites en cuanto a la cantidad de dígitos que puede tener un número o su precisión decimal.</p></li>
<li><p><strong>Restricciones en los datos:</strong> dependiendo del tipo de los datos, pueden ser mutables o inmutables, de tamaño fijo o variable, etc.</p></li>
<li><p><strong>La semántica de las instrucciones:</strong> un símbolo usado en un algoritmo puede tener otro significado distinto en el programa, o puede que sólo pueda usarse en el programa bajo ciertas condiciones que no hace falta considerar en el algoritmo.</p></li>
</ul></li>
</ul>
</section>
</section>
<section>
<section id="paradigmas-de-programación" class="title-slide slide level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Paradigmas de programación</h1>

</section>
<section id="definición-2" class="title-slide slide level2" data-number="2.1">
<h2 data-number="2.1"><span class="header-section-number">2.1</span> Definición</h2>
<div class="caja">
<p><strong>Paradigma de programación</strong>:</p>
<p>Es un <strong><em>estilo</em></strong> de desarrollar programas, es decir, un <strong>modelo</strong> para resolver problemas computacionales.</p>
</div>
</section>
<section class="slide level5" data-number="2.1.0.0.1">

<ul>
<li><p>Cada paradigma entiende la programación desde una perspectiva diferente, partiendo de unos conceptos básicos diferentes y con unas reglas diferentes.</p></li>
<li><p>Cuando diseñamos un algoritmo o escribimos un programa, lo hacemos siguiendo un determinado paradigma, y éste impregna por completo la forma en la que describimos la solución al problema en el que estamos trabajando.</p></li>
<li><p>No existe un único paradigma de programación y cada uno tiene sus peculiaridades que lo hacen diferente.</p></li>
<li><p>Un <strong>lenguaje de programación (o pseudocódigo)</strong> se dice que <strong><em>soporta</em> un determinado paradigma</strong> cuando con dicho lenguaje se pueden escribir algoritmos o programas según el «estilo» que impone dicho paradigma.</p></li>
<li><p>Incluso existen <strong>lenguajes <em>multiparadigma</em></strong> capaces de soportar varios paradigmas al mismo tiempo.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.1.0.0.2">

<ul>
<li>Los paradigmas de programación más importantes son:</li>
</ul>
<p><br></p>
<p><span class="math display">\text{Paradigmas} \begin{cases}
\text{Imperativo} \begin{cases}
                    \text{Estructurado} \\
                    \text{Orientado a objetos}
                  \end{cases} \\
\\
\text{Declarativo} \begin{cases}
                     \text{Funcional} \\
                     \text{Lógico} \\
                     \text{De bases de datos}
                   \end{cases}
\end{cases}</span></p>
</section>
<section class="slide level5" data-number="2.1.0.0.3">

<div class="centered">
<figure>
<img data-src="images/paradigmas.png" style="width:100.0%" alt="Principales paradigmas © 2008 Peter Van Roy" /><figcaption aria-hidden="true">Principales paradigmas © 2008 Peter Van Roy</figcaption>
</figure>
</div>
</section>

<section id="imperativo" class="title-slide slide level2" data-number="2.2">
<h2 data-number="2.2"><span class="header-section-number">2.2</span> Imperativo</h2>
<ul>
<li><p>El <strong>paradigma imperativo</strong> está basado en el concepto de <strong>sentencia</strong>. Un programa imperativo está formado por una sucesión de sentencias que se ejecutan en orden y que llevan a cabo una de estas acciones:</p>
<ul>
<li><p><strong>Cambiar el estado</strong> interno del programa, usualmente mediante la sentencia de <em>asignación</em>.</p></li>
<li><p>Cambiar el <strong>flujo de control</strong> del programa, haciendo que la ejecución se bifurque (<em>salte</em>) a otra parte del mismo.</p></li>
</ul></li>
<li><p>La ejecución de un programa imperativo, por tanto, consiste en una sucesión de cambios de estado controlados por mecanismos de control y que dependen del orden en el que se realizan.</p></li>
<li><p>Existen varios paradigmas con las características del paradigma imperativo, por lo que podemos decir que <strong>existen varios paradigmas imperativos</strong>.</p></li>
</ul>
</section>
<section id="estructurado" class="title-slide slide level3" data-number="2.2.1">
<h3 data-number="2.2.1"><span class="header-section-number">2.2.1</span> Estructurado</h3>
<ul>
<li><p>El <strong>paradigma estructurado</strong> es un paradigma imperativo en el que el flujo de control del programa se define mediante las denominadas <strong>estructuras de control</strong>.</p></li>
<li><p>Se apoya a nivel teórico en los resultados del conocido <strong>teorema de Böhm y Jacopini</strong>, que establece que cualquier programa se puede escribir usando solamente tres estructuras básicas:</p>
<ul>
<li>Secuencia</li>
<li>Selección</li>
<li>Iteración</li>
</ul></li>
<li><p>Con estas tres estructuras conseguimos que los programas se puedan leer de arriba abajo como compuestos por <strong>bloques anidados o independientes</strong> que se leen como un todo conjunto.</p></li>
<li><p>Su aparición llevó asociada la aparición de una <strong>metodología de desarrollo</strong> según la cual los programas se escriben por niveles de abstracción mediante refinamientos sucesivos y usando en cada nivel sólo las tres estructuras básicas.</p></li>
</ul>
</section>

<section id="orientado-a-objetos" class="title-slide slide level3" data-number="2.2.2">
<h3 data-number="2.2.2"><span class="header-section-number">2.2.2</span> Orientado a objetos</h3>
<ul>
<li><p>El <strong>paradigma orientado a objetos</strong> se apoya en los conceptos de <strong>objeto</strong> y <strong>mensaje</strong>.</p></li>
<li><p>Un programa orientado a objetos está formado por una colección de objetos que se intercambian mensajes entre sí.</p></li>
<li><p>Los objetos son entidades que existen dentro del programa y que poseen un cierto <strong>estado interno</strong>.</p></li>
<li><p>Cuando un objeto envía un mensaje a otro, el objeto que recibe el mensaje reaccionará llevando a cabo alguna acción, que probablemente provocará un <strong>cambio en su estado interno</strong> y que, posiblemente, provocará también el envío de mensajes a otros objetos.</p></li>
<li><p>La programación orientada a objetos está vista como una forma natural de entender la programación y es, con diferencia, <strong>el paradigma más usado en la actualidad</strong>.</p></li>
</ul>
</section>


<section id="declarativo" class="title-slide slide level2" data-number="2.3">
<h2 data-number="2.3"><span class="header-section-number">2.3</span> Declarativo</h2>
<ul>
<li><p>La <strong>programación declarativa</strong> engloba a una familia de paradigmas de programación de muy alto nivel.</p></li>
<li><p>En programación declarativa se describe la solución a un problema definiendo las <strong>propiedades</strong> que debe cumplir dicha solución en lugar de definir las <strong>instrucciones</strong> que se deben ejecutar para resolver el problema.</p></li>
<li><p>Se dice que un programa imperativo describe <strong>cómo</strong> resolver el problema, mientras que un programa declarativo describe <strong>qué</strong> forma debe tener la solución al problema.</p></li>
<li><p>Para dar forma a la solución, se utilizan formalismos abstractos matemáticos y lógicos, lo que da lugar a los dos grandes paradigmas declarativos: la <strong>programación funcional</strong> y <strong>la programación lógica</strong>.</p></li>
</ul>
</section>
<section id="funcional" class="title-slide slide level3" data-number="2.3.1">
<h3 data-number="2.3.1"><span class="header-section-number">2.3.1</span> Funcional</h3>
<ul>
<li><p>La <strong>programación funcional</strong> es un paradigma de programación declarativa basado en el uso de <strong>funciones matemáticas</strong>.</p></li>
<li><p>Tiene su origen teórico en el <strong>cálculo lambda</strong> de Alonzo Church (los lenguajes funcionales se pueden considerar azúcar sintáctico del cálculo lambda).</p></li>
<li><p>Una función (en programación funcional) define de un cálculo a realizar a partir de unos datos de entrada, con la propiedad de que el resultado de la función sólo puede depender de dichos datos de entrada (lo que se denomina <strong>transparencia referencial</strong>).</p></li>
<li><p>Eso significa que una función no puede tener estado interno ni su resultado puede depender del estado interno del programa. Por tanto, no existen los <strong>efectos laterales</strong>.</p></li>
<li><p>Demostrar la corrección de un programa funcional o paralelizar su ejecución es <strong>mucho más fácil</strong> que con un programa imperativo.</p></li>
</ul>
</section>

<section id="lógico" class="title-slide slide level3" data-number="2.3.2">
<h3 data-number="2.3.2"><span class="header-section-number">2.3.2</span> Lógico</h3>
<ul>
<li><p>La <strong>programación lógica</strong> es un paradigma de programación declarativa basado en el uso de la <strong>lógica de predicados de primer orden</strong>.</p></li>
<li><p>Básicamente, un programa lógico es una colección de definiciones que forman un conjunto de <strong>axiomas</strong> en un sistema de <strong>deducción lógica</strong>.</p></li>
<li><p>Ejecutar un programa lógico equivale a poner en marcha un mecanismo deductivo que trata de <strong>demostrar un teorema</strong> a partir de los axiomas.</p></li>
<li><p>Se usa principalmente en <strong>inteligencia artificial</strong>, en <strong>demostración automática</strong> y en <strong>procesamiento del lenguaje natural</strong>.</p></li>
<li><p>El más conocido de los lenguajes de programación lógica es <strong>Prolog</strong>.</p></li>
</ul>
</section>

<section id="de-bases-de-datos" class="title-slide slide level3" data-number="2.3.3">
<h3 data-number="2.3.3"><span class="header-section-number">2.3.3</span> De bases de datos</h3>
<ul>
<li><p>Los sistemas de gestión de bases de datos relacionales (SGBDR) disponen de un lenguaje que permite al usuario consultar y manipular la información almacenada.</p></li>
<li><p>A esos lenguajes se los denomina <strong>lenguajes de bases de datos</strong> o <strong>lenguajes de consulta</strong>.</p></li>
<li><p>El lenguaje de consulta más conocido es el <strong>SQL</strong>.</p></li>
<li><p>Los SGBDR se basan en el <em>modelo relacional</em>, que es un modelo matemático.</p></li>
<li><p>SQL es, básicamente, una implementación del <strong>álgebra relacional</strong>.</p></li>
<li><p>Con SQL, el usuario indica <em>qué</em> desea obtener y el SGBDR determina automáticamente el mejor camino para alcanzar dicho objetivo.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.3.3.0.1">

<script data-quiz>
quiz = {"info":{"name":"","main":""},"questions":[{"q":"El paradigma funcional es un paradigma...","a":[{"option":"Imperativo","correct":false},{"option":"Declarativo","correct":true}],"correct":"<p><span>\u00a1Eso es!</span>El paradigma funcional es un paradigma declarativo de gran auge hoy en d\u00eda.</p>","incorrect":"<p><span>Mmmm... no.</span>El paradigma funcional <em>NO</em> es un paradigma imperativo.</p>"},{"q":"Entre los paradigmas imperativos tenemos...","a":[{"option":"El paradigma de bases de datos","correct":false},{"option":"El paradigma l\u00f3gico","correct":false},{"option":"El paradigma orientado a objetos","correct":true}],"correct":"<p><span>\u00a1Eso es!</span>El paradigma orientado a objetos es un paradigma imperativo porque los objetos cambian su estado al enviarse mensajes entre ellos.</p>","incorrect":"<p><span>Mmmm... no.</span>No es correcto.</p>"}]}</script>
</section>
<section id="ejercicios-1" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejercicios</h5>
<ol start="5" class="example" type="1">
<li><p>¿Qué paradigmas de programación soportan los lenguajes Python y Java?</p></li>
<li><p>¿Hay más paradigmas de programación? Busca en Internet un par de ejemplos de paradigmas que no se hayan nombrado aquí. Para cada uno, describe en una sola frase sus características básicas.</p></li>
</ol>
</section>

</section>
<section>
<section id="lenguajes-de-programación" class="title-slide slide level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Lenguajes de programación</h1>

</section>
<section id="definición-3" class="title-slide slide level2" data-number="3.1">
<h2 data-number="3.1"><span class="header-section-number">3.1</span> Definición</h2>
<div class="caja">
<p><strong>Lenguaje de programación:</strong></p>
<p>Un lenguaje de programación es un <strong>lenguaje formal</strong> que proporciona una serie de instrucciones que permiten a un programador escribir programas destinados a controlar el comportamiento físico y lógico de un ordenador.</p>
</div>
<ul>
<li><p>Un <strong>programa</strong> es la <strong>codificación de un algoritmo</strong> en un lenguaje de programación.</p></li>
<li><p>Por tanto: cuando escribimos un algoritmo en un lenguaje de programación, obtenemos un programa.</p></li>
<li><p>Estos lenguajes están determinados por un conjunto de símbolos (llamado <em>alfabeto</em>), reglas gramaticales (léxico/morfológicas y sintácticas) y reglas semánticas, que en conjunto definen las estructuras válidas en el lenguaje y su significado.</p></li>
</ul>
</section>
<section id="sintaxis" class="title-slide slide level3" data-number="3.1.1">
<h3 data-number="3.1.1"><span class="header-section-number">3.1.1</span> Sintaxis</h3>
<ul>
<li><p>A la forma visible de un lenguaje de programación se la conoce como <strong>sintaxis</strong>.</p></li>
<li><p>La sintaxis de un lenguaje de programación describe las combinaciones posibles de los símbolos que forman un programa sintácticamente correcto.</p></li>
<li><p>La sintaxis define dos elementos principales:</p>
<ul>
<li><p>Los <strong>componentes léxicos</strong>, es decir, los elementos mínimos que forman un programa (palabras clave, números, identificadores, caracteres de puntuación como paréntesis o comas, etc…).</p></li>
<li><p>La <strong>estructura gramatical</strong>, es decir, cómo se pueden combinar los componentes léxicos para formar «frases» correctas según la sintaxis del lenguaje.</p></li>
</ul></li>
</ul>
</section>
<section id="notación-ebnf" class="title-slide slide level4" data-number="3.1.1.1">
<h4 data-number="3.1.1.1"><span class="header-section-number">3.1.1.1</span> Notación EBNF</h4>
<ul>
<li><p>La sintaxis de los lenguajes de programación es definida generalmente utilizando:</p>
<ul>
<li><p><strong>Expresiones regulares</strong> (para la estructura léxica)</p></li>
<li><p><strong>Notación de Backus-Naur extendida</strong> (para la estructura gramatical)</p></li>
</ul></li>
<li><p>Cada una de esas notaciones son formalismos usados para describir estructuras sintácticas en gramáticas formales.</p></li>
<li><p>Las expresiones regulares las estudiaremos a lo largo del curso, ya que resultan muy útiles para procesar cadenas.</p></li>
<li><p>Conocer la notación de Backus-Naur resulta de gran interés porque la mayoría de los lenguajes de programación la utilizan para documentar su sintaxis.</p></li>
</ul>
</section>

<section id="ejemplo-2" class="title-slide slide level4" data-number="3.1.1.2">
<h4 data-number="3.1.1.2"><span class="header-section-number">3.1.1.2</span> Ejemplo</h4>
<div class="columns">
<div class="column" style="width:53%;">
<div class="line-block"><span style="color:teal">⟨<em>frases</em>⟩</span> ::= <span style="color:teal">⟨<em>frase</em>⟩</span> (<strong><code>y</code></strong> <span style="color:teal">⟨<em>frase</em>⟩</span>)* <strong><code>.</code></strong><br />
<span style="color:teal">⟨<em>frase</em>⟩</span> ::= <span style="color:teal">⟨<em>sujeto</em>⟩</span> <span style="color:teal">⟨<em>predicado</em>⟩</span><br />
<span style="color:teal">⟨<em>sujeto</em>⟩</span> ::= <span style="color:teal">⟨<em>articulo</em>⟩</span> <span style="color:teal">⟨<em>sustantivo</em>⟩</span> <span style="color:teal">⟨<em>adjetivo</em>⟩</span>+<br />
<span style="color:teal">⟨<em>predicado</em>⟩</span> ::= <span style="color:teal">⟨<em>verbo</em>⟩</span> [<span style="color:teal">⟨<em>adverbio</em>⟩</span>]<br />
<span style="color:teal">⟨<em>artículo</em>⟩</span> ::= <strong><code>el</code></strong> | <strong><code>la</code></strong><br />
<span style="color:teal">⟨<em>sustantivo</em>⟩</span> ::= <strong><code>niño</code></strong> | <strong><code>vaca</code></strong><br />
<span style="color:teal">⟨<em>adjetivo</em>⟩</span> ::= <strong><code>grande</code></strong> | <strong><code>azul</code></strong><br />
<span style="color:teal">⟨<em>verbo</em>⟩</span> ::= <strong><code>come</code></strong> | <strong><code>salta</code></strong> | <strong><code>corre</code></strong><br />
<span style="color:teal">⟨<em>adverbio</em>⟩</span> ::= <strong><code>mucho</code></strong> | <strong><code>poco</code></strong></div>
<ul>
<li>Cada regla sintáctica (llamada <strong>producción</strong>) está formada por dos partes separadas por <span style="color:teal">::=</span> , donde a la izquierda hay un símbolo no terminal y a la derecha puede haber una lista de símbolos terminales y no terminales.</li>
</ul>
</div><div class="column" style="width:47%;">
<ul>
<li>Los nombres entre ángulos (como <span style="color:teal">⟨<em>predicado</em>⟩</span>) se llaman <strong>símbolos no terminales</strong>.</li>
<li>Los símbolos en negrita y azul (como <strong><code>la</code></strong>) se llaman <strong>símbolos terminales</strong>.</li>
<li>La barra vertical <span style="color:teal">|</span> indica poder elegir entre dos <strong>opciones</strong>.</li>
<li>El <span style="color:teal">*</span> representa 0, 1 ó más <strong>repeticiones</strong> de lo que acompaña.</li>
<li>El <span style="color:teal">+</span> representa 1 ó más <strong>repeticiones</strong> de lo que acompaña.</li>
<li>Los corchetes <span style="color:teal">[</span> y <span style="color:teal">]</span> indican <strong>optatividad</strong>.</li>
<li>Los paréntesis <span style="color:teal">(</span> y <span style="color:teal">)</span> <strong>agrupan</strong>.</li>
</ul>
</div>
</div>
</section>
<section class="slide level5" data-number="3.1.1.2.1">

<ul>
<li><p>Las gramáticas sirven para <em>reconocer</em> o <em>producir</em> frases correctas en un determinado lenguaje.</p></li>
<li><p>Por ejemplo, podemos preguntarnos si la frase «<code>el niño grande come mucho.</code>» es sintácticamente correcta según la gramática anterior.</p></li>
<li><p>Para ello, comprobamos si es posible <em>derivar</em> esa frase a partir de las producciones de la gramática, partiendo del <strong>símbolo inicial</strong>, que siempre es el primer símbolo no terminal que aparece en la gramática (en este caso, <span style="color:teal">⟨<em>frases</em>⟩</span>).</p></li>
<li><p>Cada paso del procedimiento se llama <em>derivación</em>, y consiste en ir sustituyendo, de izquierda a derecha, los símbolos no terminales que vayamos encontrando por su correspondiente definición (lo que hay a la derecha del <span style="color:teal">::=</span> ).</p></li>
<li><p>Iremos avanzando mientras encontremos símbolos terminales que coincidan con los de la frase.</p></li>
<li><p>El procedimiento finalizará con éxito cuando se acabe la frase, o con fracaso si algún símbolo terminal no coincide con el esperado.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.1.1.2.2">

<ul>
<li><p>En este caso:</p>
<div class="line-block"><span style="color:teal">⟨<em>frases</em>⟩</span><br />
  <span class="math inline">\Rightarrow</span> <span style="color:teal">⟨<em>frase</em>⟩</span> <strong><code>.</code></strong><br />
  <span class="math inline">\Rightarrow</span> <span style="color:teal">⟨<em>sujeto</em>⟩</span> <span style="color:teal">⟨<em>predicado</em>⟩</span> <strong><code>.</code></strong><br />
  <span class="math inline">\Rightarrow</span> <span style="color:teal">⟨<em>artículo</em>⟩</span> <span style="color:teal">⟨<em>sustantivo</em>⟩</span> <span style="color:teal">⟨<em>adjetivo</em>⟩</span>+ <span style="color:teal">⟨<em>predicado</em>⟩</span> <strong><code>.</code></strong><br />
  <span class="math inline">\Rightarrow</span> <strong><code>el</code></strong> <span style="color:teal">⟨<em>sustantivo</em>⟩</span> <span style="color:teal">⟨<em>adjetivo</em>⟩</span>+ <span style="color:teal">⟨<em>predicado</em>⟩</span> <strong><code>.</code></strong><br />
  <span class="math inline">\Rightarrow</span> <strong><code>el</code></strong> <strong><code>niño</code></strong> <span style="color:teal">⟨<em>adjetivo</em>⟩</span>+ <span style="color:teal">⟨<em>predicado</em>⟩</span> <strong><code>.</code></strong><br />
  <span class="math inline">\Rightarrow</span> <strong><code>el</code></strong> <strong><code>niño</code></strong> <strong><code>grande</code></strong> <span style="color:teal">⟨<em>predicado</em>⟩</span> <strong><code>.</code></strong><br />
  <span class="math inline">\Rightarrow</span> <strong><code>el</code></strong> <strong><code>niño</code></strong> <strong><code>grande</code></strong> <span style="color:teal">⟨<em>verbo</em>⟩</span> [<span style="color:teal">⟨<em>adverbio</em>⟩</span>] <strong><code>.</code></strong><br />
  <span class="math inline">\Rightarrow</span> <strong><code>el</code></strong> <strong><code>niño</code></strong> <strong><code>grande</code></strong> <strong><code>come</code></strong> [<span style="color:teal">⟨<em>adverbio</em>⟩</span>] <strong><code>.</code></strong><br />
  <span class="math inline">\Rightarrow</span> <strong><code>el</code></strong> <strong><code>niño</code></strong> <strong><code>grande</code></strong> <strong><code>come</code></strong> <strong><code>mucho</code></strong> <strong><code>.</code></strong></div></li>
<li><p>El procedimiento ha tenido éxito, por lo que podemos afirmar que la gramática ha <em>reconocido</em> la frase, o que la frase <em>satisface</em> la gramática o que <em>cumple</em> con la gramática.</p></li>
<li><p>Eso se expresa diciendo que:</p></li>
</ul>
<p><span style="color:teal">⟨<em>frases</em>⟩</span> <span class="math inline">\stackrel{\ast}{\Rightarrow}</span> <strong><code>el</code></strong> <strong><code>niño</code></strong> <strong><code>grande</code></strong> <strong><code>come</code></strong> <strong><code>mucho</code></strong> <strong><code>.</code></strong></p>
</section>
<section class="slide level5" data-number="3.1.1.2.3">

<ul>
<li>Otra forma de representarlo es mediante un diagrama llamado <strong>árbol de análisis sintáctico</strong>.</li>
</ul>
<div class="centered">
<figure>
<img data-src="images/arbol-analisis.svg" class="plain" style="width:70.0%" alt="Árbol de análisis sintáctico para «el niño come mucho.»" /><figcaption aria-hidden="true">Árbol de análisis sintáctico para «<code>el niño come mucho.</code>»</figcaption>
</figure>
</div>
</section>
<section id="ejercicios-2" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejercicios</h5>
<ol start="7" class="example" type="1">
<li><p>Comprobar si son sintácticamente correctas las siguientes frases según la gramática anterior:</p>
<ol type="a">
<li><code>la vaca corre.</code></li>
<li><code>la vaca grande salta.</code></li>
<li><code>la vaca grande azul salta.</code></li>
<li><code>el niño come.</code></li>
<li><code>niño come.</code></li>
<li><code>la niño grande salta poco.</code></li>
<li><code>la vaca azul come</code></li>
<li><code>el niño grande salta poco y la vaca azul corre mucho.</code></li>
</ol></li>
</ol>
</section>
<section class="slide level5" data-number="3.1.1.2.4">

<ol start="8" class="example" type="1">
<li><p>¿Qué frases genera (o reconoce) la siguiente gramática? Poner ejemplos:</p>
<div class="line-block"><span style="color:teal">⟨<em>expresión</em>⟩</span> ::= <span style="color:teal">⟨<em>átomo</em>⟩</span> | <span style="color:teal">⟨<em>lista</em>⟩</span><br />
<span style="color:teal">⟨<em>átomo</em>⟩</span> ::= <span style="color:teal">⟨<em>número</em>⟩</span> | <span style="color:teal">⟨<em>símbolo</em>⟩</span><br />
<span style="color:teal">⟨<em>lista</em>⟩</span> ::= <strong><code>(</code></strong> <span style="color:teal">⟨<em>expresión</em>⟩</span>* <strong><code>)</code></strong><br />
<span style="color:teal">⟨<em>número</em>⟩</span> ::= [<strong><code>+</code></strong> | <strong><code>-</code></strong>] <span style="color:teal">⟨<em>dígito</em>⟩</span>+<br />
<span style="color:teal">⟨<em>símbolo</em>⟩</span> ::= <span style="color:teal">⟨<em>letra</em>⟩</span>+<br />
<span style="color:teal">⟨<em>dígito</em>⟩</span> ::= <strong><code>0</code></strong> | <strong><code>1</code></strong> | <strong><code>2</code></strong> | <strong><code>3</code></strong> | <strong><code>4</code></strong> | <strong><code>5</code></strong> | <strong><code>6</code></strong> | <strong><code>7</code></strong> | <strong><code>8</code></strong> | <strong><code>9</code></strong><br />
<span style="color:teal">⟨<em>letra</em>⟩</span> ::= <strong><code>a</code></strong> | <strong><code>b</code></strong> | … | <strong><code>z</code></strong></div></li>
</ol>
</section>


<section id="semántica-estática" class="title-slide slide level3" data-number="3.1.2">
<h3 data-number="3.1.2"><span class="header-section-number">3.1.2</span> Semántica estática</h3>
<ul>
<li><p>La semántica estática define las <strong>restricciones</strong> sobre la estructura de los textos válidos que resulta imposible o muy difícil expresar mediante formalismos sintácticos estándar como los que acabamos de ver.</p></li>
<li><p>Es decir: hay programas sintácticamente correctos que, sin embargo, no resultan ser programas válidos según las reglas de la semántica estática del lenguaje.</p></li>
<li><p>La semántica estática de un lenguaje está fuertemente relacionado con su <strong>sistema de tipos</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.1.2.0.1">

<ul>
<li><p>Por ejemplo:</p>
<ul>
<li><p>Comprobar que los tipos de los datos a operar son los correctos:</p>
<p>Si intentamos hacer <code>4 + 'hola'</code>, sintácticamente puede ser correcto pero no tiene sentido sumar una cadena a un número.</p></li>
<li><p>Comprobar que un nombre está ligado a un valor antes de usarlo en una expresión.</p>
<p>Sintácticamente puede ser correcto hacer <code>4 + x</code>, pero si no se sabe qué es <code>x</code>, el programa no puede realizar la operación.</p></li>
<li><p>Comprobar que el número y tipo de argumentos en la llamada a una función coincide con el número y tipo de parámetros de la función.</p>
<p>Si se quiere calcular el coseno de 24 se puede hacer <code>cos(24)</code>, pero no tiene sentido hacer <code>cos(24, 35)</code> (se llama a la función con dos argumentos en vez de uno) o <code>cos('hola')</code> (se la llama con una cadena en lugar de un número).</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.1.2.0.2">

<ul>
<li><p>En el ejemplo que vimos de los niños y las vacas, hemos encontrado frases sintácticamente correctas según la gramática pero que no son completamente correctas o lógicas.</p></li>
<li><p>Por ejemplo, la frase «<code>la niño grande salta poco.</code>» es sintácticamente correcta (podemos derivarla a partir del símbolo inicial de la gramática), pero sabemos que no es <em>completamente</em> correcta porque no hay concordancia de género entre el artículo <code>la</code> y el sustantivo <code>niño</code>.</p></li>
</ul>
</section>

<section id="semántica-dinámica" class="title-slide slide level3" data-number="3.1.3">
<h3 data-number="3.1.3"><span class="header-section-number">3.1.3</span> Semántica dinámica</h3>
<ul>
<li><p>La semántica dinámica (o simplemente <strong>semántica</strong>) de un lenguaje de programación expresa el <strong>significado</strong> de cada construcción del lenguaje.</p></li>
<li><p>Es un concepto muy complicado de formalizar y por ello se suele definir de manera informal en la documentación del lenguaje en función de los <strong>efectos</strong> que produce cada construcción del lenguaje dentro de un programa.</p></li>
</ul>
</section>


<section id="evolución-histórica" class="title-slide slide level2" data-number="3.2">
<h2 data-number="3.2"><span class="header-section-number">3.2</span> Evolución histórica</h2>
<ul>
<li><p><strong>1804: El telar de Jacquard (<em>Joseph Marie Jacquard</em>)</strong></p>
<ul>
<li>Tarjetas perforadas para controlar los diseños en los tejidos.</li>
</ul></li>
<li><p><strong>1837 – 1871: La máquina analítica (<em>Charles Babbage</em>)</strong></p>
<ul>
<li><p>En 1842, el matemático italiano Luigi Menabrea escribió una descripción de la máquina en frances.</p></li>
<li><p>En 1843, <strong>Ada Lovelace</strong> la traduce al inglés e incorpora unas anotaciones propias en las que especifica con detalle un método para calcular los números de Bernoulli con esa máquina. Por ello, se la considera <strong>la primera programadora de la historia</strong>.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.0.0.1">

<ul>
<li><p><strong>1890: Máquinas tabuladoras electromecánicas (<em>Herman Hollerith, Tabulating Machine Company</em>)</strong></p>
<ul>
<li>Hollerith está considerado <strong>el primer informático de la historia</strong>, por crear las primeras máquinas de procesamiento automático de la información.</li>
<li>Con ellas se creó el censo de los EE.UU.</li>
<li>Su empresa acabó llamándose <strong>IBM</strong>.</li>
</ul></li>
<li><p><strong>1936: El gran año de los modelos formales computacionales:</strong></p>
<ul>
<li><p><strong>Cálculo lambda (<em>Alonzo Church</em>)</strong></p>
<ul>
<li>Un modelo universal de computación basado en la abstracción y aplicación de funciones.</li>
</ul></li>
<li><p><strong>Máquinas de Turing (<em>Alan Turing</em>)</strong></p>
<ul>
<li>Un modelo universal de computación basado en máquinas abstractas que manipulan símbolos escritos en una cinta de acuerdo a una serie de reglas definidas.</li>
</ul></li>
<li><p><strong>Sorpresa</strong>: ambos modelos son <strong>equivalentes</strong>.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.0.0.2">

<ul>
<li><p><strong>El trabajo de <em>Konrad Zuse</em>:</strong></p>
<ul>
<li><p><strong>1941: Ordenador Z3</strong></p>
<ul>
<li><p>El primer ordenador digital programable que realmente llegó a funcionar.</p></li>
<li><p>Por ello, Zuse es considerado <strong>el inventor del ordenador moderno</strong>.</p></li>
</ul></li>
<li><p><strong>1945: Ordenador Z4</strong></p>
<ul>
<li><p>El primer ordenador digital comercial del mundo.</p></li>
<li><p>Se vendió a varias universidades.</p></li>
</ul></li>
<li><p><strong>1948: Plankalkül</strong></p>
<ul>
<li><p>Considerado <strong>el primer lenguaje de programación</strong>.</p></li>
<li><p>Diseñado, pero no implantado en su época.</p></li>
</ul></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.0.0.3">

<ul>
<li><p><strong>(<em>Hasta aquí</em>):</strong> Todo se programa en <strong>lenguaje máquina</strong></p></li>
<li><p><strong>1949: Lenguaje ensamblador (<em>EDSAC</em>)</strong></p></li>
<li><p><strong>Primeros Autocódigos:</strong></p>
<ul>
<li><p><strong>1952: Autocódigo de Glennie (<em>Alick Glennie, Universidad de Manchester</em>)</strong></p></li>
<li><p><strong>1955: Autocódigo del Mark 1 (<em>Ralph Anthony Brooker, Universidad de Manchester</em>)</strong></p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.0.0.4">

<ul>
<li><p><strong>1957: Fortran (<em>John Backus, IBM</em>)</strong></p>
<ul>
<li>El primer lenguaje de alto nivel de propósito general de uso masivo en tener una implementación funcional.</li>
</ul></li>
<li><p><strong>1958: LISP (<em>John McCarthy, Instituto de Tecnología de Massachusetts</em>)</strong></p>
<ul>
<li><p>Basado en el cálculo lambda.</p></li>
<li><p>Destinado al procesamiento simbólico y a la investigación en Inteligencia Artificial.</p></li>
</ul></li>
<li><p><strong>1958 – 1960: Familia de lenguajes ALGOL (<em>Backus, Naur, Wijngaarden, Bauer, Perlis, McCarthy y otros</em>):</strong></p>
<ul>
<li><p><strong>1958: ALGOL 58</strong></p>
<ul>
<li>Introdujo el concepto de bloque de código (sentencia compuesta).</li>
</ul></li>
<li><p><strong>1960: ALGOL 60</strong></p>
<ul>
<li><p>Influyó mucho en lenguajes posteriores.</p></li>
<li><p>Introdujo las funciones anidadas y el ámbito léxico.</p></li>
</ul></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.0.0.5">

<ul>
<li><p><strong>1959: FLOW-MATIC (<em>Grace Hopper, Remington Rand</em>)</strong></p>
<ul>
<li><p>El primer lenguaje de alto nivel orientado a las aplicaciones de gestión.</p></li>
<li><p>El primero en usar sentencias y palabras en inglés.</p></li>
</ul></li>
<li><p><strong>1960: COBOL (<em>Grace Hopper, Comisión CODASYL y Departamento de Defensa de los EE.UU.</em>)</strong></p>
<ul>
<li>Inspirado en FLOW-MATIC.</li>
</ul></li>
<li><p><strong>1962: Simula (<em>Ole-Johan Dahl y Kristen Nygaard, Norwegian Computer Center</em>)</strong></p>
<ul>
<li>Considerado el primer lenguaje <strong>orientado a objetos</strong>.</li>
</ul></li>
<li><p><strong>1970: Pascal (<em>Niklaus Wirth</em>)</strong></p>
<ul>
<li><p>Lenguaje imperativo, procedimental, estructurado, pequeño, eficiente, heredero del ALGOL 60.</p></li>
<li><p>Muy usado en la enseñanza de la programación.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.0.0.6">

<ul>
<li><p><strong>1972: Prolog (<em>Alain Colmerauer, Universidad de Marsella</em>)</strong></p>
<ul>
<li>El primer lenguaje de <strong>programación lógica</strong>.</li>
</ul></li>
<li><p><strong>1972: C (<em>Dennis Ritchie, Laboratorios Bell</em>)</strong></p>
<ul>
<li><p>Lenguaje de <strong>nivel medio</strong> (de alto nivel pero con acceso directo a la máquina y al sistema operativo).</p></li>
<li><p>Lenguaje <strong>de sistemas</strong></p></li>
</ul></li>
<li><p><strong>1975: Scheme (<em>Gerald Jay Sussman, Guy L. Steele, Jr., MIT</em>)</strong></p>
<ul>
<li>Lenguaje funcional basado en LISP con ámbito léxico.</li>
</ul></li>
<li><p><strong>1978: ML (<em>Robin Milner, Universidad de Edimburgo</em>)</strong></p>
<ul>
<li><p>Lenguaje de <strong>programación funcional</strong> con sistema de tipos estático y polimórfico.</p></li>
<li><p>En realidad es una familia de lenguajes, entre los que se encuentran Standard ML, OCaml o F#.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.0.0.7">

<ul>
<li><p><strong>1980: Smalltalk (<em>Alan Kay, Adele Goldberg, Xerox PARC</em>)</strong></p>
<ul>
<li>Lenguaje orientado a objetos puro, reflexivo, con tipado dinámico, con un entorno propio de desarrollo y ejecución.</li>
</ul></li>
<li><p><strong>1985: C++ (<em>Bjarne Stroustrup, Laboratorios Bell</em>)</strong></p>
<ul>
<li>Extensión orientada a objetos del lenguaje C.</li>
</ul></li>
<li><p><strong>1990: Haskell (<em>Simon Peyton Jones, Paul Hudak, Philip Wadler y otros</em>)</strong></p>
<ul>
<li>Lenguaje funcional puro con evaluación no estricta y sistema de tipos polimórfico y fuertemente tipado.</li>
</ul></li>
<li><p><strong>1991: Python (<em>Guido Van Rossum, CWI de Holanda</em>)</strong></p>
<ul>
<li>Lenguaje multiparadigma interpretado, dinámico y multiplataforma.</li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.0.0.8">

<ul>
<li><p><strong>1995: Un año especialmente destacable:</strong></p>
<ul>
<li><p><strong>Java (<em>James Gosling, Sun Microsystems</em>)</strong></p>
<ul>
<li><p>Lenguaje orientado a objetos, el más usado en la actualidad.</p></li>
<li><p>Genera código para una máquina virtual presente en millones de dispositivos en todo el mundo.</p></li>
</ul></li>
<li><p><strong>JavaScript (<em>Brendan Eich, Netscape Communications</em>)</strong></p>
<ul>
<li><p>Lenguaje multiparadigma, basado en prototipos e interpretado.</p></li>
<li><p>Usado como lenguaje cliente en los navegadores web.</p></li>
</ul></li>
<li><p><strong>PHP (<em>Rasmus Lerdorf</em>)</strong></p>
<ul>
<li><p>Lenguaje multiparadigma e interpretado.</p></li>
<li><p>Usado principalmente como lenguaje de servidor en aplicaciones web.</p></li>
</ul></li>
<li><p><strong>Ruby (<em>Yukihiro Matsumoto</em>)</strong></p>
<ul>
<li>Lenguaje interpretado orientado a objetos puro.</li>
</ul></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.0.0.9">

<ul>
<li><p><strong>2000: C# (<em>Anders Hejlsberg, Microsoft</em>)</strong></p>
<ul>
<li>Lenguaje orientado a objetos para la plataforma .NET.</li>
</ul></li>
<li><p><strong>2003: Scala (<em>Martin Odersky, Escuela Politécnica Federal de Lausana, Suiza</em>)</strong></p>
<ul>
<li>Lenguaje multiparadigma (funcional y orientado a objetos) para la máquina virtual de Java.</li>
</ul></li>
<li><p>Swift, Kotlin, TypeScript, Julia, Go, Rust, Perl 6, Clojure…</p></li>
</ul>
</section>
<section id="ejercicio-1" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejercicio</h5>
<ol start="9" class="example" type="1">
<li>Busca en Internet información sobre un lenguaje de programación que no se haya comentado aquí y que se haya creado no antes del año 2000. Anota el paradigma (o paradigmas) que soporta y los lenguajes que influyeron en su diseño.</li>
</ol>
</section>

<section id="clasificación" class="title-slide slide level2" data-number="3.3">
<h2 data-number="3.3"><span class="header-section-number">3.3</span> Clasificación</h2>

</section>
<section id="por-nivel" class="title-slide slide level3" data-number="3.3.1">
<h3 data-number="3.3.1"><span class="header-section-number">3.3.1</span> Por nivel</h3>
<ul>
<li><p>Dependiendo del <strong>nivel</strong> del lenguaje de programación tenemos:</p>
<ul>
<li><p>Lenguajes de bajo nivel</p></li>
<li><p>Lenguajes de alto nivel</p></li>
</ul></li>
</ul>
</section>
<section id="lenguajes-de-bajo-nivel" class="title-slide slide level4" data-number="3.3.1.1">
<h4 data-number="3.3.1.1"><span class="header-section-number">3.3.1.1</span> Lenguajes de bajo nivel</h4>
<ul>
<li><p>Características:</p>
<ul>
<li><p>Lenguajes basados en el paradigma imperativo.</p></li>
<li><p>Más cercanos a la máquina.</p></li>
<li><p>Con poca o nula capacidad de abstracción.</p></li>
<li><p>Se trabaja directamente con elementos propios del <em>hardware</em> del ordenador.</p></li>
<li><p>Atados a la arquitectura interna de la máquina para la que se programa.</p></li>
<li><p>Programas difíciles de escribir, depurar, mantener y portar.</p></li>
<li><p>Se consigue el máximo control del ordenador.</p></li>
</ul></li>
<li><p>Principales ejemplos:</p>
<ul>
<li><p>Código máquina</p></li>
<li><p>Ensamblador</p></li>
</ul></li>
</ul>
</section>

<section id="lenguajes-de-alto-nivel" class="title-slide slide level4" data-number="3.3.1.2">
<h4 data-number="3.3.1.2"><span class="header-section-number">3.3.1.2</span> Lenguajes de alto nivel</h4>
<ul>
<li><p>Características:</p>
<ul>
<li><p>Lenguajes que pueden estar basados en cualquier paradigma, aunque la tendencia es que sean cada vez más <em>declarativos</em>.</p></li>
<li><p>Más cercanos al ser humano.</p></li>
<li><p>Mayor capacidad de abstracción.</p></li>
<li><p>Independiente de la arquitectura y los detalles internos del ordenador o el sistema operativo.</p></li>
<li><p>Programas más fáciles de escribir, depurar, mantener y portar.</p></li>
<li><p>Menor control de los recursos de la máquina.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.1.2.1">

<ul>
<li><p>Ejemplos de lenguajes de alto nivel:</p>
<div class="columns">
<div class="column">
<ul>
<li>Fortran</li>
<li>LISP</li>
<li>COBOL</li>
<li>BASIC</li>
<li>Pascal</li>
<li>C</li>
<li>Java</li>
</ul>
</div><div class="column">
<ul>
<li>Ruby</li>
<li>C++</li>
<li>Python</li>
<li>JavaScript</li>
<li>C#</li>
<li>PHP</li>
<li>Haskell</li>
</ul>
</div>
</div></li>
</ul>
</section>
<section id="ejercicio-2" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejercicio</h5>
<ol start="10" class="example" type="1">
<li>Ordena cronológicamente la lista anterior por el año de creación de cada lenguaje.</li>
</ol>
</section>


<section id="por-generación" class="title-slide slide level3" data-number="3.3.2">
<h3 data-number="3.3.2"><span class="header-section-number">3.3.2</span> Por generación</h3>
<ol type="1">
<li><p><strong>Primera generación</strong>: Se programa directamente en <em>código máquina</em>.</p></li>
<li><p><strong>Segunda generación</strong>: Aparece el <em>lenguaje ensamblador</em> como un lenguaje simbólico que se traduce a lenguaje máquina usando un <em>programa ensamblador</em>.</p></li>
<li><p><strong>Tercera generación</strong>: Aparecen los <em>lenguajes de alto nivel</em> con los que se puede programar con códigos independientes de la máquina. El código fuente se traduce a código máquina usando programas específicos llamados <strong>traductores</strong>.</p></li>
<li><p><strong>Cuarta generación</strong>: Herramientas que combinan un lenguaje de programación de alto nivel con un <em>software</em> de generación de pantallas, listados, informes, etc. orientado al desarrollo rápido de aplicaciones. Ejemplos característicos son los lenguajes de <strong>programación visual</strong>.</p></li>
<li><p><strong>Quinta generación</strong>: Es una denominación que se usó durante un tiempo para los lenguajes de programación de muy alto nivel (funciones y lógicos) destinados principalmente a resolver problemas de <strong>Inteligencia Artificial</strong>, pero como término ya ha caído en desuso.</p></li>
</ol>
</section>

<section id="por-propósito" class="title-slide slide level3" data-number="3.3.3">
<h3 data-number="3.3.3"><span class="header-section-number">3.3.3</span> Por propósito</h3>
<ul>
<li><p>Dependiendo del tipo de programa que podemos escribir con el lenguaje, tenemos:</p>
<ul>
<li><p><strong>Lenguajes de propósito general</strong>: Con ellos se pueden escribir programas muy diversos. No están atados a un tipo concreto de problema a resolver. Ejemplos:</p>
<ul>
<li>LISP, Pascal, C, Java, Ruby, C++, Python, C#, Haskell…</li>
</ul></li>
<li><p><strong>Lenguajes de propósito específico</strong>: Son lenguajes mucho más especializados y destinados principalmente a resolver un tipo determinado de problema. No sirven para escribir cualquier tipo de programa pero, dentro de su ámbito de actuación, suelen funcionar mejor que los lenguajes de propósito general. Ejemplos:</p>
<ul>
<li><p>Lenguajes de consulta a bases de datos (SQL)</p></li>
<li><p>Lenguajes de descripción de hardware (VHDL)</p></li>
<li><p>Lenguajes para desarrollo de aplicaciones de gestión (COBOL)</p></li>
</ul></li>
</ul></li>
</ul>
</section>

<section id="por-paradigma" class="title-slide slide level3" data-number="3.3.4">
<h3 data-number="3.3.4"><span class="header-section-number">3.3.4</span> Por paradigma</h3>
<ul>
<li><p>Dependiendo del paradigma de programación que soporta el lenguaje, podemos encontrar:</p>
<ul>
<li><p>Lenguajes imperativos</p></li>
<li><p>Lenguajes funcionales</p></li>
<li><p>Lenguajes orientados a objetos</p></li>
<li><p>Lenguajes lógicos</p></li>
<li><p>Lenguajes dirigidos por eventos</p></li>
<li><p>Lenguajes multiparadigma</p></li>
</ul></li>
</ul>
</section>

</section>
<section>
<section id="traductores" class="title-slide slide level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Traductores</h1>

</section>
<section id="definición-4" class="title-slide slide level2" data-number="4.1">
<h2 data-number="4.1"><span class="header-section-number">4.1</span> Definición</h2>
<ul>
<li><p>El único lenguaje que entiende la máquina directamente es el <strong>lenguaje máquina</strong> o <strong>código máquina</strong>, que es un lenguaje de <strong>bajo nivel</strong>.</p></li>
<li><p>Para poder programar con un lenguaje de <strong>alto nivel</strong>, necesitamos usar herramientas <em>software</em> que traduzcan nuestro programa al lenguaje máquina que entiende el ordenador.</p></li>
<li><p>Estas herramientas <em>software</em> son los <strong>traductores</strong>.</p>
<div class="caja">
<p><strong>Traductor:</strong></p>
<p>Es un <em>software</em> que traduce un programa escrito en un lenguaje a otro lenguaje, conservando su significado.</p>
</div></li>
</ul>
</section>
<section class="slide level5" data-number="4.1.0.0.1">

<ul>
<li><p>El traductor transforma el programa fuente (o <strong>código fuente</strong>) en el programa objeto (o <strong>código objeto</strong>).</p></li>
<li><p>El código fuente está escrito en el <strong>lenguaje fuente</strong> (que generalmente será un lenguaje de alto nivel).</p></li>
<li><p>El código objeto está escrito en el <strong>lenguaje objeto</strong> (que generalmente será código máquina).</p></li>
<li><p>Durante el proceso de traducción, el traductor también informa al programador de posibles <strong>errores</strong> en el código fuente.</p></li>
</ul>
<div class="centered">
<figure>
<img data-src="images/traduccion.svg" class="plain" style="width:80.0%" alt="El proceso de traducción" /><figcaption aria-hidden="true">El proceso de traducción</figcaption>
</figure>
</div>
</section>

<section id="compiladores" class="title-slide slide level2" data-number="4.2">
<h2 data-number="4.2"><span class="header-section-number">4.2</span> Compiladores</h2>
<ul>
<li><p>Definición:</p>
<div class="caja">
<p><strong>Compilador</strong>:</p>
<p>Es un traductor que convierte un programa escrito en un lenguaje de <strong>más alto nivel</strong> a un lenguaje de <strong>más bajo nivel</strong>.</p>
</div></li>
<li><p>Generalmente, el lenguaje objeto suele ser <strong>código máquina</strong> y el resultado de la compilación es un <strong>objeto ejecutable</strong> directamente por la máquina.</p></li>
</ul>
<div class="centered">
<p><img data-src="images/compilacion.svg" class="plain" style="width:80.0%" /></p>
</div>
</section>
<section id="ensambladores" class="title-slide slide level3" data-number="4.2.1">
<h3 data-number="4.2.1"><span class="header-section-number">4.2.1</span> Ensambladores</h3>
<ul>
<li><p>Un caso particular de compilador es el <strong>ensamblador</strong>:</p>
<div class="caja">
<p><strong>Ensamblador</strong>:</p>
<p>Es un compilador que traduce un programa escrito en <strong>lenguaje ensamblador</strong> a código máquina.</p>
</div></li>
<li><p>Muchas veces, los compiladores se construyen <em>en cadena</em>: en lugar de generar código máquina directamente, generan código ensamblador que sirve de entrada a un programa ensamblador que generará el código objeto final.</p></li>
</ul>
<div class="centered">
<p><img data-src="images/ensamblado.svg" class="plain" style="width:80.0%" /></p>
</div>
</section>


<section id="intérpretes" class="title-slide slide level2" data-number="4.3">
<h2 data-number="4.3"><span class="header-section-number">4.3</span> Intérpretes</h2>
<ul>
<li><p>Un <strong>intérprete</strong> es un caso muy especial de traductor.</p></li>
<li><p>En lugar de generar código objeto, el intérprete <strong>lee el código fuente y lo ejecuta directamente</strong>.</p></li>
<li><p>El intérprete funciona, por tanto, como un <strong>simulador</strong> de una máquina que hablara el lenguaje de alto nivel en el que está escrito el programa fuente.</p></li>
</ul>
<div class="centered">
<p><img data-src="images/interpretes.svg" class="plain" style="width:80.0%" /></p>
</div>
</section>
<section class="slide level5" data-number="4.3.0.0.1">

<ul>
<li><p>El desarrollo de programas se ve <strong>acelerado</strong> con un intérprete ya que no es necesario pasar por el proceso de compilación ni, por tanto, generar el código objeto para poder ejecutar el programa.</p></li>
<li><p>Sin embargo, si el programa fuente tiene errores sintácticos, el intérprete no informará de ellos hasta el momento en el que intente ejecutar la instrucción errónea, es decir, <strong>los errores se muestran en tiempo de ejecución, no en tiempo de compilación</strong>.</p></li>
<li><p>Hay lenguajes <em>compilados</em> y lenguajes <em>interpretados</em>, e incluso lenguajes que son ambas cosas (tienen compiladores e intérpretes).</p></li>
</ul>
</section>
<section id="interactivos-repl" class="title-slide slide level3" data-number="4.3.1">
<h3 data-number="4.3.1"><span class="header-section-number">4.3.1</span> Interactivos (<em>REPL</em>)</h3>
<ul>
<li><p>A los intérpretes que hemos visto hasta ahora se les denomina <strong>intérpretes por lotes</strong>, ya que tratan al programa fuente como un lote de instrucciones conjuntas.</p></li>
<li><p>A diferencia de los anteriores, los <strong>intérpretes interactivos</strong> son programas que solicitan al programador que introduzca por teclado, una a una, las instrucciones que se desean ejecutar, y el intérprete las va ejecutando a medida que el programador las va introduciendo.</p></li>
<li><p>Su comportamiento se resume en el siguiente bucle:</p>
<ol type="1">
<li><p>Leer la siguiente instrucción por teclado (<em><strong>R</strong>ead</em>).</p></li>
<li><p>Ejecutar o evaluar la instrucción (<em><strong>E</strong>val</em>).</p></li>
<li><p>Imprimir por la pantalla el resultado (<em><strong>P</strong>rint</em>).</p></li>
<li><p>Repetir el bucle (<em><strong>L</strong>oop</em>).</p></li>
</ol></li>
</ul>
</section>
<section class="slide level5" data-number="4.3.1.0.1">

<ul>
<li><p>Los intérpretes interactivos son ideales para:</p>
<ul>
<li><p>Aprender conceptos de programación.</p></li>
<li><p>Experimentar con el lenguaje.</p></li>
<li><p>Probar rápidamente el efecto de una instrucción.</p></li>
</ul></li>
</ul>
</section>

</section>
<section>
<section id="resolución-de-problemas-mediante-programación" class="title-slide slide level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Resolución de problemas mediante programación</h1>

</section>
<section id="introducción" class="title-slide slide level2" data-number="5.1">
<h2 data-number="5.1"><span class="header-section-number">5.1</span> Introducción</h2>
<ul>
<li><p>El proceso de resolución de un problema con un ordenador pasa por escribir y ejecutar un programa.</p></li>
<li><p>Aunque diseñar programas es, esencialmente, un proceso creativo, se puede considerar una serie de fases o pasos comunes, que generalmente deben seguir todos los programadores.</p></li>
<li><p>Si bien se han ordenado según un esquema lógico, hay que considerar que algunos de esos pasos se repiten a lo largo del desarrollo del programa siguiendo un esquema iterativo e incremental, y otros (como la documentación) se deben realizar continuamente a lo largo de todo el proceso y no sólo al final como un paso más del mismo.</p></li>
</ul>
</section>
<section class="slide level5" data-number="5.1.0.0.1">

<ul>
<li><p>Los pasos para la resolución de un problema mediante programación son los siguientes:</p>
<ol>
<li><p>Especificación.</p></li>
<li><p>Análisis del problema.</p></li>
<li><p>Diseño del algoritmo.</p></li>
<li><p>Verificación.</p></li>
<li><p>Estudio de la eficiencia.</p></li>
<li><p>Codificación.</p></li>
<li><p>Traducción y ejecución.</p></li>
<li><p>Pruebas.</p></li>
<li><p>Depuración.</p></li>
<li><p>Documentación.</p></li>
<li><p>Mantenimiento.</p></li>
</ol></li>
</ul>
</section>

<section id="especificación" class="title-slide slide level2" data-number="5.2">
<h2 data-number="5.2"><span class="header-section-number">5.2</span> Especificación</h2>
<ul>
<li><p>La <strong>especificación de un <em>problema</em></strong> describe <strong>qué</strong> problema hay que resolver sin entrar a detallar <strong>cómo</strong> hay que resolverlo.</p></li>
<li><p>La <strong>especificación de un <em>programa</em></strong> describe <strong>qué</strong> tiene que hacer el programa para resolver un problema sin detallar aún <strong>cómo</strong> va a resolverlo.</p></li>
<li><p>En esta fase, se ve al programa como una <strong>caja negra</strong> de la que se sabe <em>qué</em> debe hacer pero aún no sabemos <em>cómo</em> va a hacerlo.</p></li>
</ul>
</section>
<section class="slide level5" data-number="5.2.0.0.1">

<ul>
<li><p>La especificación define con precisión (cuanto más formal mejor):</p>
<ul>
<li><p>Cuál es la <strong>entrada requerida</strong>:</p>
<ul>
<li><p>Qué datos de entrada se necesitan y qué propiedades deben cumplir.</p></li>
<li><p>Con esto se determina el <strong>dominio de definición</strong> del problema, es decir, el conjunto de sus ejemplares.</p></li>
</ul></li>
<li><p>Cuál es la <strong>salida deseada</strong>:</p>
<ul>
<li><p>Básicamente, es el resultado que se desea obtener como solución al problema.</p></li>
<li><p>Normalmente se describe en función de los datos de entrada.</p></li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="ejemplo-3" class="title-slide slide level4" data-number="5.2.0.1">
<h4 data-number="5.2.0.1"><span class="header-section-number">5.2.0.1</span> Ejemplo</h4>
<ul>
<li><p>Se desea determinar el máximo de dos números enteros.</p>
<ul>
<li><p><em>Entrada</em>: los dos números enteros (llamémosles <span class="math inline">n_1</span> y <span class="math inline">n_2</span>).</p></li>
<li><p><em>Salida</em>: el mayor de los dos números.</p></li>
</ul></li>
<li><p>Se representaría esquemáticamente así:</p>
<p><span class="math display">\begin{cases}
  \text{\textbf{Entrada}}: n_1, n_2 \in \mathbb{Z} \\
  \text{\textit{Máximo}} \\
  \text{\textbf{Salida}}: \text{el mayor de ambos}
\end{cases}</span></p></li>
<li><p>En las especificaciones está permitido usar operaciones (funciones, por ejemplo) siempre y cuando estén perfectamente especificadas, aunque no estén implementadas en el lenguaje de programación.</p></li>
<li><p>A esas operaciones se las denomina <strong>operaciones ocultas</strong> o <strong>auxiliares</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="5.2.0.1.1">

<ul>
<li><p>Por ejemplo, si disponemos de la función oculta <span class="math inline">max</span> que devuelve el máximo de dos números, nuestra especificación podría quedar así:</p>
<p><span class="math display">\begin{cases}
  \text{\textbf{Entrada}}: n_1, n_2 \in \mathbb{Z} \\
  \text{\textit{Máximo}} \\
  \text{\textbf{Salida}}: max(n_1, n_2)
\end{cases}</span></p></li>
<li><p>Con esta especificación estamos describiendo que, si se reciben como datos de entrada dos números enteros cualesquiera, el programa <em>Máximo</em> calculará y devolverá a la salida el mayor de ellos.</p></li>
<li><p>Si los datos de entrada no satisfacen los requisitos necesarios, el programa tiene derecho a responder de cualquier manera, o a no responder en absoluto.</p></li>
</ul>
</section>


<section id="análisis-del-problema" class="title-slide slide level2" data-number="5.3">
<h2 data-number="5.3"><span class="header-section-number">5.3</span> Análisis del problema</h2>
<ul>
<li><p>A partir de la especificación, se estudia detalladamente el problema a resolver, los requisitos que se deben cumplir y las posibles restricciones que pueda tener la solución.</p></li>
<li><p>En el ejemplo anterior:</p>
<ul>
<li>Hay que comparar el valor de los dos números y devolver el mayor de ellos.</li>
<li>Si los dos números son iguales, se puede devolver cualquiera de los dos.</li>
</ul></li>
</ul>
</section>

<section id="diseño-del-algoritmo" class="title-slide slide level2" data-number="5.4">
<h2 data-number="5.4"><span class="header-section-number">5.4</span> Diseño del algoritmo</h2>
<ul>
<li><p>Una vez analizado el problema con detalle, se diseña un algoritmo que cumpla con todas las posibles restricciones y satisfaga la especificación del problema.</p></li>
<li><p>El estilo en el que se describa el algoritmo debe ir acorde con el paradigma del lenguaje de programación que se usará luego para codificar el algoritmo en un programa.</p></li>
<li><p>El algoritmo se representa con cualquier herramienta adecuada para ello (ordinogramas, pseudocódigo, etc.) la cual también depende del estilo o paradigma utilizado.</p>
<ul>
<li>Por ejemplo, se podría usar un ordinograma para representar un algoritmo imperativo pero no para uno funcional.</li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="5.4.0.0.1">

<ul>
<li>Un algoritmo descrito en pseudocódigo siguiendo un estilo estructurado podría ser:</li>
</ul>
<div class="line-block"><strong>Algoritmo:</strong> Cálculo del máximo de dos números<br />
<strong>Entrada:</strong> <span class="math inline">n_1, n_2 \in \mathbb{Z}</span><br />
<strong>Salida:</strong> el mayor de ambos<br />
<br />
<strong>inicio</strong><br />
    <strong>si</strong> <span class="math inline">n_1 &gt; n_2</span> <strong>entonces</strong><br />
        <strong>devolver</strong> <span class="math inline">n_1</span><br />
    <strong>sino</strong><br />
        <strong>devolver</strong> <span class="math inline">n_2</span><br />
<strong>fin</strong></div>
</section>

<section id="verificación" class="title-slide slide level2" data-number="5.5">
<h2 data-number="5.5"><span class="header-section-number">5.5</span> Verificación</h2>
<ul>
<li><p>Es el proceso por el cual se intenta <strong>demostrar</strong> que el algoritmo diseñado es <strong>correcto</strong>.</p></li>
<li><p>Un algoritmo es correcto cuando <strong>satisface su especificación</strong>.</p></li>
<li><p>Es un proceso basado en las matemáticas y la lógica, y consiste en considerar que el algoritmo es un <strong>teorema</strong> a demostrar en un sistema deductivo lógico en el que hay <em>axiomas</em> y <em>reglas de inferencia</em>.</p></li>
<li><p>Puede resultar muy difícil incluso en casos sencillos.</p></li>
<li><p>En la práctica, su uso se reduce a bloques pequeños y críticos del programa.</p></li>
</ul>
</section>

<section id="estudio-de-la-eficiencia" class="title-slide slide level2" data-number="5.6">
<h2 data-number="5.6"><span class="header-section-number">5.6</span> Estudio de la eficiencia</h2>
<ul>
<li><p>Cuando disponemos de un algoritmo correcto que resuelve el problema, podemos optar por estudiar la eficiencia del mismo.</p></li>
<li><p>Si el algoritmo es correcto pero ineficiente, no suele resultar práctico, y se debe optar por diseñar otro algoritmo más eficiente.</p></li>
</ul>
</section>

<section id="codificación" class="title-slide slide level2" data-number="5.7">
<h2 data-number="5.7"><span class="header-section-number">5.7</span> Codificación</h2>
<ul>
<li><p>Una vez diseñado y verificado, <strong>el algoritmo se codifica en un lenguaje de programación</strong> usando un editor de textos o un IDE (<em>Entorno Integrado de Desarrollo</em>).</p></li>
<li><p>Se considera una tarea casi mecanizable, pero aún hay decisiones que pueden influir a la hora de codificar un programa y que sólo puede tomar un programador experimentado.</p></li>
<li><p>El lenguaje de programación utilizado es una decisión de diseño que hay que justificar.</p></li>
<li><p>El diseño del algoritmo debería ser independiente del lenguaje de programación en el que se vaya a codificar posteriormente el programa, pero el <em>estilo</em> (paradigma) influye mucho.</p></li>
</ul>
</section>
<section class="slide level5" data-number="5.7.0.0.1">

<ul>
<li><p>Codificación del algoritmo anterior en lenguaje Python:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">def</span> maximo(n1, n2):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>    <span class="co">&quot;&quot;&quot;Calcula el máximo de dos números.&quot;&quot;&quot;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    <span class="cf">if</span> n1 <span class="op">&gt;</span> n2:</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>        <span class="cf">return</span> n1</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>        <span class="cf">return</span> n2</span></code></pre></div></li>
<li><p>Codificación en lenguaje Java:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="co">/**</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a> <span class="co">*</span> Calcula el máximo de dos números.</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a> <span class="co">*/</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">maximo</span>(<span class="dt">int</span> n1, <span class="dt">int</span> n2) {</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>    <span class="kw">if</span> (n1 &gt; n2) {</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>        <span class="kw">return</span> n1;</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>    } <span class="kw">else</span> {</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>        <span class="kw">return</span> n2;</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>    }</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>}</span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="5.7.0.0.2">

<ul>
<li><p>Codificación en lenguaje Haskell:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="fu">max</span><span class="ot"> ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="fu">max</span> a b</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    <span class="op">|</span> a <span class="op">&gt;</span> b     <span class="ot">=</span> a</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> b</span></code></pre></div></li>
</ul>
</section>

<section id="traducción-y-ejecución" class="title-slide slide level2" data-number="5.8">
<h2 data-number="5.8"><span class="header-section-number">5.8</span> Traducción y ejecución</h2>
<ul>
<li><p>Una vez escrito el programa, se procede a su ejecución. Para ello:</p>
<ul>
<li><p>Si el lenguaje es <strong>compilado</strong>: se compila, se genera el código objeto y se ejecuta éste.</p></li>
<li><p>Si el lenguaje es <strong>interpretado</strong>: se ejecuta el código fuente directamente por medio del intérprete del lenguaje.</p></li>
</ul></li>
<li><p>Si durante la compilación (o ejecución, en el caso de un lenguaje interpretado) el traductor muestra <strong>errores en el programa fuente</strong>, es preciso volver a editar el programa, corregir los errores e intentar de nuevo.</p></li>
<li><p>Los errores que un traductor puede detectar son, principalmente:</p>
<ul>
<li><p>Errores <strong>sintácticos</strong> (por ejemplo, falta o sobra un paréntesis)</p></li>
<li><p>Errores <strong>de semántica estática</strong> (por ejemplo, se intenta sumar una cadena a un número, detectable mediante un <strong>chequeo de tipos</strong>)</p></li>
</ul></li>
</ul>
</section>
<section id="ejercicio-3" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejercicio</h5>
<ol start="11" class="example" type="1">
<li>Desde el punto de vista de la detección de errores sintácticos o de semántica estática, ¿qué resulta más interesante: un compilador o un intérprete? Razona la respuesta.</li>
</ol>
</section>

<section id="pruebas" class="title-slide slide level2" data-number="5.9">
<h2 data-number="5.9"><span class="header-section-number">5.9</span> Pruebas</h2>
<ul>
<li><p>Para determinar que el programa funciona correctamente, se determina una <strong>batería de pruebas</strong> que debe superar el mismo para concluir que se comporta como debe.</p></li>
<li><p>Esas baterías de prueba (o <strong>casos de prueba</strong>) consisten en una serie de <strong>datos de entrada</strong> con los que se estimula al programa, emparejados junto a una serie de <strong>resultados esperables</strong> que se comparan con los resultados reales que el programa genera a partir de los datos de entrada.</p></li>
<li><p>Si los generados coinciden con los esperables, se concluye que el programa está funcionando <strong>correctamente</strong>.</p></li>
<li><p>En caso contrario, decimos que el programa <strong>falla</strong> y debemos localizar el error (o errores) que provocan el mal funcionamiento.</p></li>
</ul>
</section>
<section class="slide level5" data-number="5.9.0.0.1">

<ul>
<li><p><strong>Las pruebas pueden detectar la presencia de errores, pero nunca pueden garantizar la ausencia de los mismos.</strong></p></li>
<li><p>La verificación formal es la única forma de garantizar la ausencia de errores en un programa.</p></li>
<li><p>Entonces, ¿por qué hacemos pruebas?</p>
<ul>
<li><p>Para comprobar que no se han <em>colado</em> errores al codificar el algoritmo (aunque hayamos verificado la corrección del algoritmo, se nos puede haber colado un error al codificarlo en el programa).</p></li>
<li><p>A veces, simplemente, no verificamos, y lo único que tenemos son las pruebas.</p></li>
<li><p>También es importante comprobar la <strong>eficiencia</strong> del programa con ejecuciones <em>reales</em>.</p></li>
</ul></li>
</ul>
</section>

<section id="depuración" class="title-slide slide level2" data-number="5.10">
<h2 data-number="5.10"><span class="header-section-number">5.10</span> Depuración</h2>
<ul>
<li><p>La <strong>depuración</strong> es el proceso de <strong>encontrar</strong> los errores del programa y <strong>corregir</strong> o eliminar dichos errores.</p></li>
<li><p>En caso de ser <strong>errores sintácticos o de semántica estática</strong>, el traductor facilita mucho la tarea de localizar la posición concreta del mismo en el programa fuente, gracias a los <strong>mensajes de error</strong> que genera durante la compilación o interpretación del programa.</p></li>
<li><p>Si tenemos un <strong>error lógico</strong> (un error en la lógica del programa que provoca que éste produzca resultados incorrectos), normalmente resulta más difícil de localizar.</p></li>
</ul>
</section>

<section id="documentación" class="title-slide slide level2" data-number="5.11">
<h2 data-number="5.11"><span class="header-section-number">5.11</span> Documentación</h2>
<ul>
<li><p>La documentación es el proceso por el cual incorporamos al código fuente del programa de toda la información que pueda ayudar en la comprensión y el mantenimiento del mismo.</p></li>
<li><p>La documentación de un programa puede ser interna o externa:</p>
<ul>
<li><p>La <strong>documentación interna</strong> forma parte del código fuente del programa y se refiere al uso de comentarios, identificadores descriptivos, indentación, reglas de estilo, etc. Todo orientado a ayudar a entender el código cuando lo lea un humano.</p></li>
<li><p>La <strong>documentación externa</strong> va fuera del código fuente e incluye análisis, diagramas de flujo y/o pseudocódigos, manuales de usuario con instrucciones para ejecutar el programa y para interpretar los resultados.</p></li>
</ul></li>
</ul>
</section>

<section id="mantenimiento" class="title-slide slide level2" data-number="5.12">
<h2 data-number="5.12"><span class="header-section-number">5.12</span> Mantenimiento</h2>
<ul>
<li><p>La vida útil de un programa rara vez termina cuando se ha acabado de programar y los usuarios comienzan a usarlo, sino que a partir de ese momento comienza una de las etapas más importantes y probablemente más costosas en tiempo y esfuerzo: el <strong>mantenimiento</strong>.</p></li>
<li><p>Mantener un programa consiste en realizar acciones encaminadas a:</p>
<ul>
<li><p>Corregir los fallos que puedan aparecer como consecuencia del uso del programa (fallos que no se localizaron previamente en la fase de pruebas).</p></li>
<li><p>Adaptar el programa a nuevas condiciones de utilización (nuevos sistemas operativos, nuevas plataformas <em>hardware</em>…)</p></li>
<li><p>Mejorar el programa incorporando nuevas funcionalidades.</p></li>
</ul></li>
<li><p>Para ello, es fundamental que el programa esté correctamente documentado.</p></li>
</ul>
</section>

<section id="ingeniería-del-software" class="title-slide slide level2" data-number="5.13">
<h2 data-number="5.13"><span class="header-section-number">5.13</span> Ingeniería del software</h2>
<ul>
<li><p>En los años 60, los problemas a resolver son cada vez más complejos y los ordenadores son cada vez más potentes pero los programadores son incapaces de escribir programas que aprovechen esa potencia y que sean fiables.</p></li>
<li><p>Además resulta difícil estimar el presupuesto y el tiempo necesarios para desarrollar programas.</p></li>
<li><p>En 1968, Fiedrich Bauer habla por primera vez de la <strong>crisis del software</strong> en la primera Conferencia sobre Ingeniería del Software de la OTAN en Garmish (Alemania).</p></li>
<li><p>Se llega a la conclusión de que no basta con tener mejores herramientas (lenguajes), sino que hay que dar un enfoque más industrial y sistemático al desarrollo de software.</p></li>
<li><p>Aparece la <strong>ingeniería del software</strong> como disciplina.</p></li>
</ul>
</section>
<section class="slide level5" data-number="5.13.0.0.1">

<ul>
<li><p>La ingeniería del software no considera a la programación como una disciplina científica o como un arte, sino como un proceso sistemático que va más allá de escribir código.</p></li>
<li><p>Cuando el programa a desarrollar es grande, escribir código es sólo una de las tareas que hay que realizar. También hay que:</p>
<ul>
<li><p>Realizar un análisis del sistema.</p></li>
<li><p>Estimar y planificar el tiempo y el esfuerzo necesarios para desarrollar la solución.</p></li>
<li><p>Aplicar procedimientos estandarizados.</p></li>
<li><p>Elaborar documentación.</p></li>
<li><p>Medir la calidad del producto resultante.</p></li>
</ul></li>
<li><p>El desarrollo de software complejo requiere pasar por varias etapas que, juntas, forman lo que se llama el <strong>ciclo de vida</strong> del software.</p></li>
</ul>
</section>
</section>
<section>
<section id="entornos-integrados-de-desarrollo" class="title-slide slide level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Entornos integrados de desarrollo</h1>

</section>
<section id="definición-5" class="title-slide slide level2" data-number="6.1">
<h2 data-number="6.1"><span class="header-section-number">6.1</span> Definición</h2>
<ul>
<li><p>Definición:</p>
<div class="caja">
<p>Un <strong>entorno integrado de desarrollo</strong> o <strong>IDE</strong> (del inglés, <em>Integrated Development Environment</em>), es una herramienta <em>software</em> que proporciona servicios que facilitan el desarrollo de software al programador.</p>
</div></li>
<li><p>Está formado por un <strong>editor de textos</strong> donde el programador puede codificar el programa en el lenguaje de programación correspondiente, alrededor del cual pueden orbitar una serie de herramientas satélite, como:</p>
<ul>
<li>Herramientas visuales para la creación de <em>interfaces gráficas de usuario</em></li>
<li>Sistemas de control de versiones</li>
<li>Visor de documentación</li>
<li>Intérpretes interactivos</li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="6.1.0.0.1">

<ul>
<li><p>Asimismo, el editor de textos del IDE suele incorporar facilidades que ayudan a escribir código con más comodidad:</p>
<ul>
<li><p>Resaltado de sintaxis</p></li>
<li><p>Autocompletado de código</p></li>
<li><p>Ayudas a la refactorización</p></li>
</ul></li>
<li><p>Los IDE suelen ir asociados a un lenguaje o grupo de lenguajes de programación concreto y, por lo tanto, son herramientas especializadas utilizadas para programar en el lenguaje o lenguajes para los que han sido diseñadas. Por ejemplo:</p>
<ul>
<li><p>PyCharm es un IDE para programar en el lenguaje Python.</p></li>
<li><p>IntelliJ IDEA es un IDE para programar en el lenguaje Java.</p></li>
</ul></li>
</ul>
</section>

<section id="editores-de-textos" class="title-slide slide level2" data-number="6.2">
<h2 data-number="6.2"><span class="header-section-number">6.2</span> Editores de textos</h2>
<ul>
<li><p>Un editor de textos, por contra, es una herramienta <em>software</em> que, en principio, sólo cuenta con la posibilidad de editar texto «plano» cuyo contenido puede ser de cualquier tipo (no necesariamente un código fuente).</p></li>
<li><p>Al ser una herramienta general, no dispone de características específicas para escribir programas.</p></li>
<li><p>Los principales editores de textos que podemos encontrar en el mercado son:</p>
<ul>
<li>Vim</li>
<li>Emacs</li>
<li>Atom</li>
<li>Sublime Text</li>
<li>Visual Studio Code</li>
</ul></li>
</ul>
</section>
<section id="editores-vs.-ide" class="title-slide slide level3" data-number="6.2.1">
<h3 data-number="6.2.1"><span class="header-section-number">6.2.1</span> Editores vs. IDE</h3>
<ul>
<li><p>Los mejores editores de textos son <strong>extensibles</strong>, es decir, es posible ampliar su funcionalidad por medio de <em>extensiones</em>.</p></li>
<li><p>Esto hace que podamos personalizar su aspecto y funcionalidad hasta crear con ellos un IDE completo y ajustado a nuestras necesidades.</p></li>
<li><p>Gracias a ello, podemos usar el mismo editor de textos tanto para crear documentos de texto genéricos como para escribir programas. Por tanto, sólo tenemos que aprender el manejo de una única herramienta.</p></li>
<li><p>No obstante, los IDE suelen incorporar modos de funcionamiento que <em>imitan</em> a los de los editores de textos más conocidos (como Vim o Emacs).</p></li>
</ul>
</section>

<section id="visual-studio-code" class="title-slide slide level3" data-number="6.2.2">
<h3 data-number="6.2.2"><span class="header-section-number">6.2.2</span> Visual Studio Code</h3>
<ul>
<li><p>Es el editor de textos que vamos a usar en clase.</p></li>
<li><p>Es <em>software</em> libre, y por tanto podemos usarlo sin ningún tipo de restricción.</p></li>
<li><p>Además, es extensible y dispone de una enorme cantidad de extensiones que nos van a permitir construirnos nuestro propio IDE para los lenguajes que vamos a usar en clase.</p></li>
</ul>
</section>

</section>
<section>
<section id="ejercicios-3" class="title-slide slide level1 unnumbered unlisted">
<h1 class="unnumbered unlisted">Ejercicios</h1>

</section>
<section id="ejercicios-4" class="title-slide slide level2 unnumbered unlisted">
<h2 class="unnumbered unlisted">Ejercicios</h2>
<ol start="12" class="example" type="1">
<li><p>Supongamos los siguientes problemas:</p>
<ol type="i">
<li>Resolver una ecuación de primer grado de la forma <span class="math inline">a + bx = 0</span>.</li>
<li>Sumar dos fracciones.</li>
<li>Interpretar una partitura al violín.</li>
<li>Hacer la cuenta atrás, desde 10 hasta 0.</li>
</ol>
<ul>
<li><p>Para cada uno de ellos, se pide que:</p>
<ol type="a">
<li>Identifiques cuáles son los datos y los resultados.</li>
<li>Describas un problema más general y, si se puede, otro menos general.</li>
<li>Distingas cuáles de esos problemas pueden resolverse mediante algoritmos y cuáles no.</li>
<li>Esboces, con tus propias palabras o en pseudocódigo, un algoritmo para los problemas (i), (ii) y (iv).</li>
</ol></li>
</ul></li>
</ol>
</section>
<section class="slide level5" data-number="6.2.2.0.1">

<ol start="13" class="example" type="1">
<li><p>El problema de restar dos enteros positivos se puede resolver por un procedimiento análogo al de la suma lenta, al que llamaremos <strong>resta lenta</strong>.</p>
<ul>
<li><p>Se pide:</p>
<ol type="a">
<li>Escribir un ordinograma para este problema.</li>
<li>Estudiar cómo evoluciona para el cálculo de <span class="math inline">5 - 2</span>.</li>
<li>Estudiar su complejidad.</li>
<li>Estudiar su corrección.</li>
<li>Expresar el algoritmo en pseudocódigo.</li>
</ol></li>
</ul></li>
</ol>
</section>
</section>
<section id="bibliografía" class="title-slide slide level1 unnumbered unlisted">
<h1 class="unnumbered unlisted">Bibliografía</h1>
<div id="refs" class="references hanging-indent" role="doc-bibliography">
<div id="ref-aguilar_fundamentos_2008">
<p>Aguilar, Luis Joyanes. 2008. <em>Fundamentos de Programación</em>. Aravaca: McGraw-Hill Interamericana de España.</p>
</div>
<div id="ref-pareja_flores_desarrollo_1997">
<p>Pareja Flores, Cristóbal, Manuel Ojeda Aciego, Ángel Andeyro Quesada, and Carlos Rossi Jiménez. 1997. <em>Desarrollo de Algoritmos Y Técnicas de Programación En Pascal</em>. Madrid: Ra-Ma.</p>
</div>
<div id="ref-van-roy_concepts_2004">
<p>Van-Roy, Peter, and Seif Haridi. 2004. <em>Concepts, Techniques, and Models of Computer Programming</em>. Cambridge, Mass: MIT Press.</p>
</div>
</div>
</section>
    </div>
  </div>

  <script src="./reveal.js/dist/reveal.js"></script>

  // reveal.js plugins
  <script src="./reveal.js/plugin/notes/notes.js"></script>
  <script src="./reveal.js/plugin/search/search.js"></script>
  <script src="./reveal.js/plugin/zoom/zoom.js"></script>
  <script src="./reveal.js/plugin/reveal.js-menu/menu.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
        // Display the page number of the current slide
        slideNumber: true,
        // Push each slide change to the browser history
        history: true,
        // Transition style
        transition: 'slide', // none/fade/slide/convex/concave/zoom
        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1280,
        height: 1080,

        menu: {
          hideMissingTitles: true,
        },

        dependencies: [
          { src: './reveal.js/plugin/reveal.js-quiz/quiz/js/quiz.js', async: true, callback: function() { prepareQuizzes({preventUnanswered: true, checkAnswerText: 'Comprueba la respuesta', nextQuestionText: 'Siguiente &raquo;', backButtonText: '&laquo; Anterior', tryAgainText: 'Prueba de nuevo', preventUnansweredText: 'Selecciona una respuesta', questionCountText: 'Pregunta %current de %total', skipStartButton: true}); } }
        ],

        // reveal.js plugins
        plugins: [
          RevealMenu,
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    </body>
</html>
