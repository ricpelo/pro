<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Ricardo Pérez López">
  <title>Abstracciones funcionales</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=1280">
  <link rel="stylesheet" href="./reveal.js/dist/reset.css">
  <link rel="stylesheet" href="./reveal.js/dist/reveal.css">
  <style>
    .reveal .sourceCode {  /* see #7635 */
      overflow: visible;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      { color: #268bd2;  }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #cb4b16; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #d33682; } /* BaseN */
    code span.bu { color: #4070a0; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #dc322f; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #93a1a1; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #6c71c4; } /* DataType */
    code span.dv { color: #d33682; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #d33682; } /* Float */
    code span.fu { color: #4070a0; } /* Function */
    code span.im { font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #268bd2; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #a57800; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #2aa198; } /* SpecialString */
    code span.st { color: #2aa198; } /* String */
    code span.va { color: #6c71c4; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    /* CSS for citations */
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
      margin-bottom: 0em;
    }
    .hanging-indent div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }  </style>
  <link rel="stylesheet" href="./reveal.js/dist/theme/solarized.css" id="theme">
  <link rel="stylesheet" href="custom.css"/>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css" />
  <link href="https://fonts.googleapis.com/css?family=Lato&display=swap" rel="stylesheet">
  <style type="text/css">
      #header-left {
          position: absolute;
          font-size: 25%;
          top: 0%;
          left: 0%;
          margin-left: 10px;
          margin-top: 10px;
      }
      #header-right {
          position: absolute;
          font-size: 25%;
          top: 0%;
          right: 0%;
          margin-right: 10px;
          margin-top: 10px;
      }
      #footer-left {
          position: absolute;
          font-size: 25%;
          bottom: 0%;
          left: 0%;
          margin-left: 10px;
          margin-bottom: 10px;
      }
  </style>
</head>
<body>
<div id="hidden" style="display:none;">
    <div id="header">
        <div id="header-left"></div>
        <div id="header-right"></div>
        <div id="footer-left"></div>
    </div>
</div>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">Abstracciones funcionales</h1>
  <p class="author">Ricardo Pérez López</p>
  <p class="date">IES Doñana, curso 2025/2026</p>
</section>
<section id="TOC">
<nav role="doc-toc"> 
<ul>
<li><a href="#/abstracciones-lambda"
id="/toc-abstracciones-lambda"><span class="toc-section-number">1</span>
Abstracciones lambda</a></li>
<li><a href="#/ámbitos" id="/toc-ámbitos"><span
class="toc-section-number">2</span> Ámbitos</a></li>
<li><a href="#/abstracciones-funcionales"
id="/toc-abstracciones-funcionales"><span
class="toc-section-number">3</span> Abstracciones funcionales</a></li>
<li><a href="#/recursividad" id="/toc-recursividad"><span
class="toc-section-number">4</span> Recursividad</a></li>
</ul>
</nav>
</section>

<section>
<section id="abstracciones-lambda" class="title-slide slide level1"
data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span>
Abstracciones lambda</h1>

</section>
<section id="expresiones-lambda" class="title-slide slide level2"
data-number="1.1">
<h2 data-number="1.1"><span class="header-section-number">1.1</span>
Expresiones lambda</h2>
<ul>
<li><p>Las <strong>expresiones lambda</strong> (también llamadas
<strong>abstracciones lambda</strong> o <strong>funciones
anónimas</strong> en algunos lenguajes) son expresiones que capturan la
idea abstracta de «<strong>función</strong>».</p></li>
<li><p>Son la forma más simple y primitiva de describir funciones en un
lenguaje funcional.</p></li>
<li><p>Su sintaxis (simplificada) es:</p>
<div class="line-block"><span
style="color:teal">⟨<em>expresión_lambda</em>⟩</span> ::=
<strong><code>lambda</code></strong> [<span
style="color:teal">⟨<em>lista_parámetros</em>⟩</span>]<strong><code>:</code></strong>
<span style="color:teal">⟨<em>expresión</em>⟩</span><br />
<span style="color:teal">⟨<em>lista_parámetros</em>⟩</span> :=
<strong><code>identificador</code></strong>
(<strong><code>,</code></strong>
<strong><code>identificador</code></strong>)*</div></li>
<li><p>Por ejemplo, la siguiente expresión lambda captura la idea
general de «<em>suma</em>»:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span></code></pre></div></li>
</ul>
</section>

<section id="parámetros-y-cuerpos" class="title-slide slide level2"
data-number="1.2">
<h2 data-number="1.2"><span class="header-section-number">1.2</span>
Parámetros y cuerpos</h2>
<ul>
<li><p>Los identificadores que aparecen entre la palabra clave <code
class="sourceCode python"><span class="kw">lambda</span></code> y el
carácter de dos puntos (<code>:</code>) son los
<strong>parámetros</strong> de la expresión lambda.</p></li>
<li><p>La expresión que aparece tras los dos puntos (<code>:</code>) es
el <strong>cuerpo</strong> de la expresión lambda.</p></li>
<li><p>En el ejemplo anterior:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span></code></pre></div>
<ul>
<li><p>Los parámetros son <code class="sourceCode python">x</code> e
<code class="sourceCode python">y</code>.</p></li>
<li><p>El cuerpo es <code
class="sourceCode python">x <span class="op">+</span> y</code>.</p></li>
<li><p>Esta expresión lambda captura la idea general de sumar dos
valores (que en principio pueden ser de cualquier tipo, siempre y cuando
admitan el operador <code>+</code>).</p></li>
<li><p>En sí misma, esa expresión devuelve un valor válido que
representa a una función.</p></li>
</ul></li>
</ul>
</section>

<section id="aplicación-funcional" class="title-slide slide level2"
data-number="1.3">
<h2 data-number="1.3"><span class="header-section-number">1.3</span>
Aplicación funcional</h2>
<ul>
<li><p>De la misma manera que podemos aplicar una función a unos
argumentos, también podemos aplicar una expresión lambda a unos
argumentos.</p></li>
<li><p>Por ejemplo, la aplicación de la función <code
class="sourceCode python"><span class="bu">max</span></code> sobre los
argumentos <code
class="sourceCode python"><span class="dv">3</span></code> y <code
class="sourceCode python"><span class="dv">5</span></code> es una
expresión que se escribe como <code
class="sourceCode python"><span class="bu">max</span>(<span class="dv">3</span>, <span class="dv">5</span>)</code>
y que denota el valor <strong>cinco</strong>.</p></li>
<li><p>Igualmente, la aplicación de una expresión lambda como</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span></code></pre></div>
<p>sobre los argumentos <code
class="sourceCode python"><span class="dv">4</span></code> y <code
class="sourceCode python"><span class="dv">3</span></code> se representa
así:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>)</span></code></pre></div>
<p>O sea, que la expresión lambda representa el papel de una
función.</p></li>
</ul>
</section>
<section id="evaluación-de-una-aplicación-funcional"
class="title-slide slide level3" data-number="1.3.1">
<h3 data-number="1.3.1"><span class="header-section-number">1.3.1</span>
Evaluación de una aplicación funcional</h3>
<ul>
<li><p>En nuestro <em>modelo de sustitución</em>, la <strong>evaluación
de la aplicación de una expresión lambda</strong> consiste en
<strong>sustituir</strong>, en el cuerpo de la expresión lambda,
<strong>cada parámetro por su argumento correspondiente</strong> (por
orden) y devolver la expresión resultante <em>parentizada</em> (o sea,
entre paréntesis).</p></li>
<li><p>A esta operación se la denomina <strong>aplicación
funcional</strong> o <strong>β-reducción</strong>.</p></li>
<li><p>Siguiendo con el ejemplo anterior:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>)</span></code></pre></div>
<p>sustituimos en el cuerpo de la expresión lambda los parámetros <code
class="sourceCode python">x</code> e <code
class="sourceCode python">y</code> por los argumentos <code
class="sourceCode python"><span class="dv">4</span></code> y <code
class="sourceCode python"><span class="dv">3</span></code>,
respectivamente, y parentizamos la expresión resultante, lo que da:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>(<span class="dv">4</span> <span class="op">+</span> <span class="dv">3</span>)</span></code></pre></div>
<p>que simplificando (según las reglas del operador <code>+</code>) da
<code
class="sourceCode python"><span class="dv">7</span></code>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.3.1.0.1">

<ul>
<li><p>Es importante hacer notar que el cuerpo de una expresión lambda
sólo se evalúa cuando se lleva a cabo una β-reducción (es decir, cuando
se aplica la expresión lambda a unos argumentos), y no antes.</p></li>
<li><p>Por tanto, el cuerpo de la expresión lambda no se evalúa cuando
se define la expresión.</p></li>
<li><p>Por ejemplo, al evaluar la expresión:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span></code></pre></div>
<p>el intérprete no evalúa la expresión del cuerpo (<code
class="sourceCode python">x <span class="op">+</span> y</code>), sino
que crea un valor de tipo «función» pero sin entrar a ver «qué hay» en
el cuerpo.</p>
<p>Sólo se mira lo que hay en el cuerpo cuando se aplica la expresión
lambda a unos argumentos.</p></li>
<li><p>En particular, podemos tener una expresión lambda como la
siguiente, que sólo dará error cuando se aplique a un argumento, no
antes:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lambda</span> x: x <span class="op">+</span> <span class="dv">1</span><span class="op">/</span><span class="dv">0</span></span></code></pre></div></li>
</ul>
</section>

<section id="funciones-con-nombre" class="title-slide slide level3"
data-number="1.3.2">
<h3 data-number="1.3.2"><span class="header-section-number">1.3.2</span>
Funciones con nombre</h3>
<ul>
<li><p>Si hacemos la siguiente definición:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>suma <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span></code></pre></div>
<p>le estamos dando un nombre a la expresión lambda, es decir, a una
función.</p></li>
<li><p>A partir de ese momento podemos usar <code
class="sourceCode python">suma</code> en lugar de su valor (la expresión
lambda), por lo que podemos hacer:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>suma(<span class="dv">4</span>, <span class="dv">3</span>)</span></code></pre></div>
<p>en lugar de</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>)</span></code></pre></div></li>
<li><p>Cuando aplicamos a sus argumentos una función así definida
también podemos decir que estamos <strong>invocando</strong> o
<strong>llamando</strong> a la función. Por ejemplo, en <code
class="sourceCode python">suma(<span class="dv">4</span>, <span class="dv">3</span>)</code>
estamos <em>llamando</em> a la función <code
class="sourceCode python">suma</code>, o hay una <em>llamada</em> a la
función <code class="sourceCode python">suma</code>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.3.2.0.1">

<ul>
<li><p>La evaluación de la llamada a <code
class="sourceCode python">suma(<span class="dv">4</span>, <span class="dv">3</span>)</code>
implicará realizar los siguientes tres pasos y en este orden:</p>
<ol type="1">
<li><p>Sustituir el nombre de la función <code
class="sourceCode python">suma</code> por su definición, es decir, por
la expresión lambda a la cual está ligado.</p></li>
<li><p>Evaluar los argumentos que aparecen en la llamada.</p></li>
<li><p>Aplicar la expresión lambda a sus argumentos
(β-reducción).</p></li>
</ol></li>
<li><p>Esto implica la siguiente secuencia de reescrituras:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>suma(<span class="dv">4</span>, <span class="dv">3</span>)                    <span class="co"># evalúa suma y devuelve su definición</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>)  <span class="co"># evalúa 4 y devuelve 4</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>)  <span class="co"># evalúa 3 y devuelve 3</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>)  <span class="co"># aplica la expresión lambda sus argumentos</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">4</span> <span class="op">+</span> <span class="dv">3</span>)                     <span class="co"># evalúa 4 + 3 y devuelve 7</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">7</span></span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="1.3.2.0.2">

<ul>
<li><p>Como una expresión lambda es una función, <strong>aplicar una
expresión lambda a unos argumentos es como llamar a una función
pasándole dichos argumentos</strong>.</p></li>
<li><p>Por tanto, también podemos decir que <strong><em>llamamos</em> o
<em>invocamos</em> una expresión lambda</strong>, pasándole unos
argumentos durante esa llamada.</p></li>
<li><p>En consecuencia, ampliamos ahora nuestra gramática de las
expresiones en Python incorporando las expresiones lambda como un tipo
de función:</p>
<div class="line-block"><span
style="color:teal">⟨<em>llamada_función</em>⟩</span> ::= <span
style="color:teal">⟨<em>función</em>⟩</span><strong><code>(</code></strong>[<span
style="color:teal">⟨<em>lista_argumentos</em>⟩</span>]<strong><code>)</code></strong><br />
<span style="color:teal">⟨<em>función</em>⟩</span> ::=
<strong><code>identificador</code></strong><br />
                         | <strong><code>(</code></strong><span
style="color:teal">⟨<em>expresión_lambda</em>⟩</span><strong><code>)</code></strong><br />
<span style="color:teal">⟨<em>expresión_lambda</em>⟩</span> ::=
<strong><code>lambda</code></strong> [<span
style="color:teal">⟨<em>lista_parámetros</em>⟩</span>]<strong><code>:</code></strong>
<span style="color:teal">⟨<em>expresión</em>⟩</span><br />
<span style="color:teal">⟨<em>lista_parámetros</em>⟩</span> ::=
<strong><code>identificador</code></strong>(<strong><code>,</code></strong>
<strong><code>identificador</code></strong>)*<br />
<span style="color:teal">⟨<em>lista_argumentos</em>⟩</span> ::= <span
style="color:teal">⟨<em>expresión</em>⟩</span>(<strong><code>,</code></strong>
<span style="color:teal">⟨<em>expresión</em>⟩</span>)*</div></li>
</ul>
</section>
<section id="ejemplo" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejemplo</h5>
<ul>
<li><p>Dado el siguiente código:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>suma <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span></code></pre></div>
<p>¿Cuánto vale la expresión siguiente?</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>suma(<span class="dv">4</span>, <span class="dv">3</span>) <span class="op">*</span> suma(<span class="dv">2</span>, <span class="dv">7</span>)</span></code></pre></div>
<p>Según el modelo de sustitución, reescribimos:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>suma(<span class="dv">4</span>, <span class="dv">3</span>) <span class="op">*</span> suma(<span class="dv">2</span>, <span class="dv">7</span>)                    <span class="co"># definición de suma</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>) <span class="op">*</span> suma(<span class="dv">2</span>, <span class="dv">7</span>)  <span class="co"># evaluación de 4</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>) <span class="op">*</span> suma(<span class="dv">2</span>, <span class="dv">7</span>)  <span class="co"># evaluación de 3</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">4</span>, <span class="dv">3</span>) <span class="op">*</span> suma(<span class="dv">2</span>, <span class="dv">7</span>)  <span class="co"># aplicación a 4 y 3</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">4</span> <span class="op">+</span> <span class="dv">3</span>) <span class="op">*</span> suma(<span class="dv">2</span>, <span class="dv">7</span>)                     <span class="co"># evaluación de 4 + 3</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> suma(<span class="dv">2</span>, <span class="dv">7</span>)                           <span class="co"># definición de suma</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">2</span>, <span class="dv">7</span>)           <span class="co"># evaluación de 2</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">2</span>, <span class="dv">7</span>)           <span class="co"># evaluación de 7</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">2</span>, <span class="dv">7</span>)           <span class="co"># aplicación a 2 y 7</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> (<span class="dv">2</span> <span class="op">+</span> <span class="dv">7</span>)                              <span class="co"># evaluación de 2 + 7</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> <span class="dv">9</span>                                    <span class="co"># evaluación de 7 * 9</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">63</span></span></code></pre></div></li>
</ul>
</section>

<section id="composición-de-funciones" class="title-slide slide level3"
data-number="1.3.3">
<h3 data-number="1.3.3"><span class="header-section-number">1.3.3</span>
Composición de funciones</h3>
<ul>
<li><p>Podemos crear una función que use otra función. Por ejemplo, para
calcular el área de un círculo usamos otra función que calcule el
cuadrado de un número:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>cuadrado <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> x</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>area <span class="op">=</span> <span class="kw">lambda</span> r: <span class="fl">3.1416</span> <span class="op">*</span> cuadrado(r)</span></code></pre></div></li>
<li><p>La expresión <code
class="sourceCode python">area(<span class="dv">11</span> <span class="op">+</span> <span class="dv">1</span>)</code>
se evaluaría así:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode numberSource python number-lines"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1"></a>area(<span class="dv">11</span> <span class="op">+</span> <span class="dv">1</span>)                                <span class="co"># definición de area</span></span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="op">=</span> (<span class="kw">lambda</span> r: <span class="fl">3.1416</span> <span class="op">*</span> cuadrado(r))(<span class="dv">11</span> <span class="op">+</span> <span class="dv">1</span>)  <span class="co"># evalúa 11 y devuelve 11</span></span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="op">=</span> (<span class="kw">lambda</span> r: <span class="fl">3.1416</span> <span class="op">*</span> cuadrado(r))(<span class="dv">11</span> <span class="op">+</span> <span class="dv">1</span>)  <span class="co"># evalúa 1 y devuelve 1</span></span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="op">=</span> (<span class="kw">lambda</span> r: <span class="fl">3.1416</span> <span class="op">*</span> cuadrado(r))(<span class="dv">11</span> <span class="op">+</span> <span class="dv">1</span>)  <span class="co"># evalúa 11 + 1 y devuelve 12</span></span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="op">=</span> (<span class="kw">lambda</span> r: <span class="fl">3.1416</span> <span class="op">*</span> cuadrado(r))(<span class="dv">12</span>)      <span class="co"># aplicación a 12</span></span>
<span id="cb17-6"><a href="#cb17-6"></a><span class="op">=</span> (<span class="fl">3.1416</span> <span class="op">*</span> cuadrado(<span class="dv">12</span>))                   <span class="co"># evalúa 3.1416 y devuelve 3.1416</span></span>
<span id="cb17-7"><a href="#cb17-7"></a><span class="op">=</span> (<span class="fl">3.1416</span> <span class="op">*</span> cuadrado(<span class="dv">12</span>))                   <span class="co"># definición de cuadrado</span></span>
<span id="cb17-8"><a href="#cb17-8"></a><span class="op">=</span> (<span class="fl">3.1416</span> <span class="op">*</span> (<span class="kw">lambda</span> x: x <span class="op">*</span> x)(<span class="dv">12</span>))          <span class="co"># aplicación a 12</span></span>
<span id="cb17-9"><a href="#cb17-9"></a><span class="op">=</span> (<span class="fl">3.1416</span> <span class="op">*</span> (<span class="dv">12</span> <span class="op">*</span> <span class="dv">12</span>))                      <span class="co"># evalúa (12 * 12) y devuelve 144</span></span>
<span id="cb17-10"><a href="#cb17-10"></a><span class="op">=</span> (<span class="fl">3.1416</span> <span class="op">*</span> <span class="dv">144</span>)                            <span class="co"># evalúa (3.1416 * 11) y...</span></span>
<span id="cb17-11"><a href="#cb17-11"></a><span class="op">=</span> <span class="fl">452.3904</span>                                  <span class="co"># ... devuelve 452.3904</span></span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="1.3.3.0.1">

<ul>
<li><p>En detalle:</p>
<ul>
<li><p><strong>Línea 1</strong>: Se evalúa <code
class="sourceCode python">area</code>, que devuelve su definición (una
expresión lambda).</p></li>
<li><p><strong>Líneas 2–4</strong>: Lo siguiente a evaluar es la
aplicación de la expresión lambda de <code
class="sourceCode python">area</code> sobre su argumento, por lo que
primero evaluamos éste.</p></li>
<li><p><strong>Línea 5</strong>: Ahora se aplica la expresión lambda a
su argumento <code
class="sourceCode python"><span class="dv">12</span></code>.</p></li>
<li><p><strong>Línea 6</strong>: Lo siguiente que toca evaluar es el
<code class="sourceCode python"><span class="fl">3.1416</span></code>,
que ya está evaluado.</p></li>
<li><p><strong>Línea 7</strong>: A continuación hay que evaluar la
aplicación de <code class="sourceCode python">cuadrado</code> sobre
<code class="sourceCode python"><span class="dv">12</span></code>.
Primero se evalúa <code class="sourceCode python">cuadrado</code>,
sustituyéndose por su definición…</p></li>
<li><p><strong>Línea 8</strong>: … y ahora se aplica la expresión lambda
a su argumento <code
class="sourceCode python"><span class="dv">12</span></code>.</p></li>
<li><p>Lo que queda ya por evaluar es todo aritmética.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="1.3.3.0.2">

<ul>
<li><p>A veces no resulta fácil determinar el orden en el que hay que
evaluar las subexpresiones que forman una expresión, sobre todo cuando
se mezclan funciones y operadores en una misma expresión.</p></li>
<li><p>En ese caso, puede resultar útil reescribir los operadores como
funciones, cuando sea posible, y luego dibujar el árbol sintático
correspondiente a esa expresión, para ver a qué profundidad quedan los
nodos.</p></li>
<li><p>Por ejemplo, la siguiente expresión:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="bu">abs</span>(<span class="op">-</span><span class="dv">12</span>) <span class="op">+</span> <span class="bu">max</span>(<span class="dv">13</span>, <span class="dv">28</span>)</span></code></pre></div>
<p>se puede reescribir como:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> operator <span class="im">import</span> add</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>add(<span class="bu">abs</span>(<span class="op">-</span><span class="dv">12</span>), <span class="bu">max</span>(<span class="dv">13</span>, <span class="dv">28</span>))</span></code></pre></div>
<p>y si dibujáramos el árbol sintáctico veríamos que la suma está más
arriba que el valor absoluto y el máximo (que están, a su vez, al mismo
nivel de profundidad).</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.3.3.0.3">

<ul>
<li><p>Un ejemplo más complicado:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="bu">abs</span>(<span class="op">-</span><span class="dv">12</span>) <span class="op">*</span> <span class="bu">max</span>((<span class="dv">2</span> <span class="op">+</span> <span class="dv">3</span>) <span class="op">**</span> <span class="dv">5</span>), <span class="dv">37</span>)</span></code></pre></div>
<p>se reescribiría como:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> operator <span class="im">import</span> add, mul</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>mul(<span class="bu">abs</span>(<span class="op">-</span><span class="dv">12</span>), <span class="bu">max</span>(<span class="bu">pow</span>(add(<span class="dv">2</span>, <span class="dv">3</span>), <span class="dv">5</span>), <span class="dv">37</span>))</span></code></pre></div>
<p>donde se aprecia claramente que el orden de las operaciones, de más
interna a más externa, sería:</p>
<ol type="1">
<li><p>Suma (<code>+</code> o <code
class="sourceCode python">add</code>).</p></li>
<li><p>Potencia (<code>**</code> o <code
class="sourceCode python"><span class="bu">pow</span></code>).</p></li>
<li><p>Valor absoluto (<code
class="sourceCode python"><span class="bu">abs</span></code>) y máximo
(<code class="sourceCode python"><span class="bu">max</span></code>) al
mismo nivel.</p></li>
<li><p>Producto (<code>*</code> o <code
class="sourceCode python">mul</code>).</p></li>
</ol></li>
</ul>
</section>


<section
id="identificadores-cuantificados-y-libres-de-una-expresión-lambda"
class="title-slide slide level2" data-number="1.4">
<h2 data-number="1.4"><span class="header-section-number">1.4</span>
Identificadores cuantificados y libres de una expresión lambda</h2>
<ul>
<li><p>Si un <em>identificador</em> de los que aparecen en el
<em>cuerpo</em> de una expresión lambda también aparece en la <em>lista
de parámetros</em> de esa expresión lambda, decimos que es un
<strong>identificador cuantificado</strong> de la expresión
lambda.</p></li>
<li><p>En caso contrario, le llamamos <strong>identificador
libre</strong> de la expresión lambda.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.4.0.0.1">

<ul>
<li><p>En el ejemplo anterior:</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span></code></pre></div>
<p>los dos identificadores que aparecen en el cuerpo (<code
class="sourceCode python">x</code> e <code
class="sourceCode python">y</code>) aparecen también en la lista de
parámetros de la expresión lambda, por lo que ambos son identificadores
cuantificados y no hay ningún identificador libre.</p></li>
<li><p>En cambio, en la expresión lambda:</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lambda</span> x, y: x <span class="op">+</span> y <span class="op">+</span> z</span></code></pre></div>
<p><code class="sourceCode python">x</code> e <code
class="sourceCode python">y</code> son identificadores cuantificados
(porque aparecen en la lista de parámetros de la expresión lambda),
mientras que <code class="sourceCode python">z</code> es un
identificador libre.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.4.0.0.2">

<ul>
<li><p>En realidad, <strong>un <em>identificador cuantificado</em> y un
<em>parámetro</em> están vinculados, hasta el punto en que podemos
considerar que son la misma cosa</strong>.</p></li>
<li><p>Tan sólo cambia su denominación dependiendo del lugar donde
aparece su identificador en la expresión lambda:</p>
<ul>
<li><p>Cuando aparece <strong>antes</strong> del «<code>:</code>», le
llamamos «<em>parámetro</em>».</p></li>
<li><p>Cuando aparece <strong>después</strong> del «<code>:</code>», le
llamamos «<em>identificador cuantificado</em>».</p></li>
</ul></li>
<li><p>Por ejemplo: en la siguiente expresión lambda:</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>       ┬     ┬</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>       │     └────── identificador cuantificado</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>       └── parámetro</span></code></pre></div>
<p>el identificador <code class="sourceCode python">x</code> aparece dos
veces, pero en los dos casos representa la misma cosa. Tan sólo se llama
de distinta forma («<em>parámetro</em>» o «<em>identificador
cuantificado</em>») dependiendo de dónde aparece.</p></li>
</ul>
</section>
<section class="slide level5" data-number="1.4.0.0.3">

<ul>
<li><p>A los identificadores cuantificados se les llama así porque sus
posibles valores están cuantificados o <em>restringidos</em> a los
posibles valores que puedan tomar los parámetros de la expresión lambda
en cada llamada a la misma.</p></li>
<li><p>Dicho valor además vendrá determinado automáticamente por la
ligadura que crea el intérprete durante la llamada a la expresión
lambda.</p>
<p>Es decir: el intérprete liga automáticamente el identificador
cuantificado al valor del correspondiente argumento durante la llamada a
la expresión lambda.</p></li>
<li><p>En cambio, el valor al que esté ligado un identificador libre de
una expresión lambda no viene determinado por ninguna característica
propia de dicha expresión lambda.</p></li>
</ul>
</section>
</section>
<section>
<section id="ámbitos" class="title-slide slide level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span>
Ámbitos</h1>

</section>
<section id="ámbitos-léxicos" class="title-slide slide level2"
data-number="2.1">
<h2 data-number="2.1"><span class="header-section-number">2.1</span>
Ámbitos léxicos</h2>
<ul>
<li><p>Un <strong>ámbito léxico</strong> (también llamado <strong>ámbito
estático</strong>) es una porción del código fuente de un
programa.</p></li>
<li><p>Decimos que <strong>ciertas construcciones sintácticas determinan
ámbitos léxicos</strong>.</p></li>
<li><p>Cuando una construcción determina un ámbito léxico, <strong>la
sintaxis del lenguaje establece dónde empieza y acaba</strong> ese
ámbito léxico en el código fuente.</p></li>
<li><p>Por tanto, siempre se puede determinar sin ambigüedad si
<strong>una instrucción situada en un punto concreto del programa está
dentro de un determinado ámbito léxico</strong>, tan sólo leyendo el
código fuente del programa y sin necesidad de ejecutarlo.</p></li>
<li><p>Eso significa que el concepto de <em>ámbito léxico</em> es un
concepto <strong>estático</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.1.0.0.1">

<ul>
<li><p>Además de los ámbitos léxicos, existen también los llamados
<strong>ámbitos dinámicos</strong>, que funcionan de otra forma y que no
estudiaremos en este curso.</p></li>
<li><p>La mayoría de los lenguajes de programación usan ámbitos léxicos,
salvo excepciones (como LISP o los <em>shell scripts</em>) que usan
ámbitos dinámicos.</p></li>
<li><p>Por esa razón, a partir de ahora, cuando hablemos de «ámbitos»
sin especificar de qué tipo, nos estaremos siempre refiriendo a «ámbitos
léxicos».</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.1.0.0.2">

<ul>
<li><p>Por ejemplo: en el lenguaje de programación Java, los
<em>bloques</em> son estructuras sintácticas delimitadas por llaves
<code>{</code> y <code>}</code> que contienen instrucciones.</p></li>
<li><p>Los bloques de Java determinan ámbitos léxicos; por tanto, si una
instrucción está dentro de un bloque (es decir, si está situada entre
las llaves <code>{</code> y <code>}</code> que delimitan el bloque),
entonces esa instrucción se encuentra dentro del ámbito léxico que
define el bloque.</p></li>
<li><p>En Python, <strong>las expresiones lambda determinan ámbitos
léxicos</strong>, así que, cada vez que creamos una expresión lambda,
estamos introduciendo un nuevo ámbito en el código fuente de nuestro
programa.</p></li>
<li><p>En concreto, el ámbito que determina una expresión lambda viene
delimitado por su <strong>cuerpo</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.1.0.0.3">

<ul>
<li><p>Los ámbitos <strong>se pueden anidar recursivamente</strong>, o
sea, que pueden estar contenidos unos dentro de otros.</p></li>
<li><p>Por tanto, una instrucción puede estar en varios ámbitos al mismo
tiempo (anidados unos dentro de otros).</p></li>
<li><p>De todos ellos, el <strong>ámbito más interno</strong> es el que
no contiene, a su vez, a ningún otro ámbito.</p></li>
<li><p>Definimos el <strong>ámbito de una instrucción</strong> como el
ámbito más interno en el que se encuentra dicha instrucción.</p></li>
<li><p>Según lo anterior, en un momento dado, el <strong>ámbito
actual</strong> es el ámbito de la instrucción actual, es decir, el
ámbito más interno en el que se encuentra la instrucción que se está
ejecutando actualmente.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.1.0.0.4">

<ul>
<li><p>Decimos que los ámbitos léxicos cumplen la <strong>propiedad de
la estructura</strong>.</p></li>
<li><p>Una <strong>estructura</strong> es una construcción sintáctica
que puede <strong>anidarse completamente</strong> dentro de otras
estructuras, de forma que, dadas dos estructuras cualesquiera, o una
está incluida completamente dentro de la otra, o no se tocan en
absoluto.</p></li>
<li><p>Por tanto, los bordes de dos ámbitos léxicos nunca pueden
cruzarse:</p></li>
</ul>
<div class="columns">
<div class="column">
<div class="centered">
<figure>
<img data-src="images/estructuras-anidadas.svg" class="plain"
style="width:35.0%" alt="Ámbitos léxicos anidados" />
<figcaption aria-hidden="true">Ámbitos léxicos anidados</figcaption>
</figure>
</div>
</div><div class="column">
<div class="centered">
<figure>
<img data-src="images/estructuras-que-se-cruzan.svg" class="plain"
style="width:35.0%" alt="Estas no son estructuras" />
<figcaption aria-hidden="true">Estas no son estructuras</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="ámbito-global" class="title-slide slide level3"
data-number="2.1.1">
<h3 data-number="2.1.1"><span class="header-section-number">2.1.1</span>
Ámbito global</h3>
<!--

- El concepto de _ámbito_ no es nada trivial y, a medida que vayamos
  incorporando nuevos elementos al lenguaje, tendremos que ir adaptándolo para
  tener en cuenta más condicionantes.

-->
<ul>
<li><p>Un ámbito que siempre existe en cualquier programa es el llamado
<strong>ámbito global</strong>:</p>
<ul>
<li><p>Si se está ejecutando un <em>script</em> en el intérprete por
lotes (con <code>python script.py</code>), <strong>el <em>ámbito
global</em> abarca todo el <em>script</em></strong>, desde la primera
instrucción hasta la última.</p></li>
<li><p>Si estamos en el intérprete interactivo (con <code>python</code>
o <code>ipython3</code>), el <em>ámbito global</em> abarca <strong>toda
nuestra sesión con el intérprete</strong>, desde que arrancamos la
sesión hasta que finalizamos la misma.</p></li>
</ul></li>
<li><p>Por tanto:</p>
<ul>
<li><p>En el momento en que se empieza a ejecutar un <em>script</em> o
se arranca una sesión con el intérprete interactivo, <strong>se
entra</strong> en el <em>ámbito global</em>.</p></li>
<li><p>Del ámbito global sólo <strong>se sale</strong> cuando se
finaliza la ejecución del <em>script</em> o se cierra el intérprete
interactivo.</p></li>
</ul></li>
</ul>
</section>
<section id="ejemplos" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejemplos</h5>
<ul>
<li><p>Por ejemplo, en la siguiente línea de código:</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>suma <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span></code></pre></div>
<p>el cuerpo de la función <code class="sourceCode python">suma</code>
determina un ámbito.</p></li>
<li><p>Por tanto, en el siguiente código tenemos dos ámbitos: el ámbito
global (más externo) y el ámbito del cuerpo de la expresión lambda (más
interno y anidado dentro del ámbito global):</p>
<div class="centered">
<p><img data-src="images/ambitos-anidados.png" class="plain"
style="width:60.0%" /></p>
</div></li>
</ul>
</section>
<section class="slide level5" data-number="2.1.1.0.1">

<ul>
<li><p>En este otro ejemplo más complicado, tenemos el siguiente
<em>script</em>:</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode numberSource python number-lines"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1"></a>w <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb26-2"><a href="#cb26-2"></a>f <span class="op">=</span> <span class="kw">lambda</span> x, y: <span class="dv">5</span> <span class="op">+</span> (<span class="kw">lambda</span> z: z <span class="op">+</span> <span class="dv">3</span>)(x <span class="op">+</span> y)</span>
<span id="cb26-3"><a href="#cb26-3"></a>r <span class="op">=</span> f(<span class="dv">2</span>, <span class="dv">4</span>)</span>
<span id="cb26-4"><a href="#cb26-4"></a>m <span class="op">=</span> (<span class="kw">lambda</span> x: x <span class="op">**</span> <span class="dv">2</span>)(<span class="dv">3</span>)</span></code></pre></div>
<p>donde existen cuatro ámbitos:</p>
<div class="centered">
<p><img data-src="images/cuatro-ambitos.png" class="plain"
style="width:100.0%" /></p>
</div></li>
</ul>
</section>


<section id="ámbito-de-una-definición-y-de-una-ligadura"
class="title-slide slide level2" data-number="2.2">
<h2 data-number="2.2"><span class="header-section-number">2.2</span>
Ámbito de una definición y de una ligadura</h2>
<ul>
<li><p>El <strong>ámbito de una definición</strong> es el ámbito actual
de esa definición, es decir, el ámbito más interno donde aparece esa
definición.</p></li>
<li><p>Por extensión, llamamos <strong>ámbito de una ligadura</strong>
al ámbito de la definición que, al ejecutarse, creará la ligadura (es
decir, el ámbito más interno donde aparece la definición que, al
ejecutarse, creará la ligadura en tiempo de ejecución).</p></li>
<li><p>En la práctica, es lo mismo hablar del «ámbito de una definición»
que del «ámbito de la ligadura que se creará al ejecutar la definición»,
ya que son la misma cosa.</p></li>
<li><p>Decimos que la <em>definición</em> (y la <em>ligadura</em>
correspondiente que se creará al ejecutar esa definición) es
<strong>local</strong> a su ámbito.</p></li>
<li><p>Si ese ámbito es el ámbito <em>global</em>, decimos que la
<em>definición</em> (y la <em>ligadura</em> que se creará al ejecutar
esa definición) es <strong>global</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.2.0.0.1">

<ul>
<li><p>Por ejemplo, en el siguiente <em>script</em> se ejecutan cuatro
definiciones:</p>
<div class="centered">
<p><img data-src="images/ambito-global.png" class="plain"
style="width:40.0%" /></p>
</div></li>
<li><p>El ámbito de cada una de las instrucciones es el ámbito
<em>global</em>, que es el único ámbito que existe en el
<em>script</em>.</p></li>
<li><p>En consecuencia:</p>
<ul>
<li><p>Las cuatro definiciones tienen <strong>ámbito global</strong> (y
son, por tanto, <strong>definiciones globales</strong>).</p></li>
<li><p>Cuando se ejecuten, esas definiciones crearán <strong>ligaduras
globales</strong>.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="2.2.0.0.2">

<ul>
<li><p>Como estamos usando un lenguaje de programación que trabaja con
<em>ámbitos léxicos</em>, <strong>el ámbito de una definición siempre
vendrá determinado por una <em>construcción sintáctica</em></strong> del
lenguaje.</p></li>
<li><p>Por tanto:</p>
<ul>
<li><p>Sus <em>límites</em> vienen marcados únicamente por la
<em>sintaxis</em> de la construcción que determina el ámbito de esa
definición.</p></li>
<li><p>El ámbito de la definición se puede determinar simplemente
leyendo el código fuente del programa, observando dónde empieza y dónde
acaba esa construcción, sin tener que ejecutarlo.</p>
<p>Es decir, que se puede determinar de forma
<em>estática</em>.</p></li>
</ul></li>
</ul>
</section>
<section id="visibilidad" class="title-slide slide level3"
data-number="2.2.1">
<h3 data-number="2.2.1"><span class="header-section-number">2.2.1</span>
Visibilidad</h3>
<ul>
<li><p>La visibilidad de una ligadura indica en qué lugares del código
fuente del programa es visible y accesible esa ligadura.</p></li>
<li><p>Una ligadura puede existir en un punto concreto del programa,
pero en cambio no ser accesible en ese mismo punto.</p></li>
<li><p>Para determinar las reglas de visibilidad de una ligadura,
existen dos posibilidades, dependiendo de si la ligadura está ligando un
atributo de un objeto, o no.</p></li>
<li><p>Veamos cada caso con detalle.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.2.1.0.1">

<ol type="1">
<li><p>Si el identificador ligado es un <strong>atributo de un
objeto</strong>, la ligadura sólo será visible dentro del objeto.</p>
<p>En tal caso, decimos que la visibilidad de la ligadura (y del
correspondiente atributo ligado) es <strong>local al objeto</strong> que
contiene el atributo.</p>
<p>Eso significa que debemos indicar (usando el operador punto
(<code>.</code>)) el objeto que contiene a la ligadura para poder
acceder a ella, lo que significa que también debemos tener acceso al
propio objeto que la contiene.</p></li>
</ol>
</section>
<section class="slide level5" data-number="2.2.1.0.2">

<ol start="2" type="1">
<li><p>Si el identificador ligado <strong>NO es un atributo de un
objeto</strong>, la ligadura sólo será visible dentro del ámbito donde
se definió la ligadura.</p>
<p>Ese ámbito representa una «región» cuyas fronteras limitan la porción
del código fuente en la que es visible esa ligadura.</p>
<p>En tal caso, decimos que la <strong>visibilidad</strong> de la
ligadura es <strong>local a su ámbito</strong>.</p>
<p>Eso significa que <strong>no es posible acceder a esa ligadura fuera
de su ámbito</strong>; sólo es visible dentro de él.</p>
<p>En cambio, si el ámbito de la ligadura contiene dentro otro ámbito
anidado, sí que podremos acceder a la ligadura dentro de ese ámbito más
interno, ya que técnicamente seguiría estando dentro de su ámbito.</p>
<p>Si el ámbito es el global, decimos que la ligadura tiene
<strong>visibilidad global</strong>.</p></li>
</ol>
</section>
<section class="slide level5" data-number="2.2.1.0.3">

<ul>
<li><p>Suponiendo que tenemos los siguientes cuatro ámbitos,
identificados con las letras A, B, C y D:</p>
<div class="columns">
<div class="column" style="width:40%;">
<div class="centered">
<figure>
<img data-src="images/estructuras-anidadas.svg" class="plain"
style="width:45.0%" alt="Ámbitos léxicos anidados" />
<figcaption aria-hidden="true">Ámbitos léxicos anidados</figcaption>
</figure>
</div>
</div><div class="column" style="width:60%;">
<ul>
<li><p>A puede ver los nombres definidos en A, pero no los definidos en
B, C o D.</p></li>
<li><p>B puede ver los nombres definidos en A y B, pero no los definidos
en C o D.</p></li>
<li><p>C puede ver los nombres definidos en A, B y C, pero no los
definidos en D.</p></li>
<li><p>D puede ver los nombres definidos en A y D, pero no los definidos
en B o C.</p></li>
</ul>
</div>
</div></li>
</ul>
</section>

<section id="tiempo-de-vida" class="title-slide slide level3"
data-number="2.2.2">
<h3 data-number="2.2.2"><span class="header-section-number">2.2.2</span>
Tiempo de vida</h3>
<ul>
<li><p>El <strong>tiempo de vida</strong> de una ligadura representa el
periodo de tiempo durante el cual <em>existe</em> esa ligadura, es
decir, el periodo comprendido desde su creación y almacenamiento en la
memoria hasta su posterior destrucción.</p></li>
<li><p>En la mayoría de los lenguajes (incluyendo Python y Java), una
ligadura <strong>empieza a existir</strong> justo cuando se crea, es
decir, en el punto donde se ejecuta la instrucción que define la
ligadura.</p>
<p>Por tanto, no es posible <em>acceder</em> a esa ligadura
<em>antes</em> de ese punto, ya que no existe hasta entonces.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.2.2.0.1">

<ul>
<li><p>Por otra parte, el momento en que una ligadura <strong>deja de
existir</strong> depende si el identificador ligado es un atributo de un
objeto, o no:</p>
<ul>
<li><p>Si el identificador ligado es un atributo de un objeto, la
ligadura dejará de existir cuando se elimine el objeto de la memoria, o
bien, cuando se elimine el propio atributo ligado.</p></li>
<li><p>En caso contrario, la ligadura dejará de existir allí donde
termine el ámbito de la ligadura.</p></li>
</ul></li>
<li><p>Es importante hacer notar que, en un momento dado, una ligadura
puede existir pero no ser visible.</p></li>
<li><p>Por ejemplo, si una ligadura local y una global vinculan el mismo
identificador, la local «hace sombra» a la global, cosa que estudiaremos
con más profundidad posteriormente.</p></li>
</ul>
<!--

- Eso significa que la **visibilidad** de una ligadura y el **acceso** a una
  ligadura son conceptos distintos:

  - La **visibilidad** de una ligadura la define su ámbito, y es, por tanto, un
    concepto **_estático_**.

  - La posibilidad de **acceder** a una ligadura depende de si esa ligadura ya
    se ha creado previamente al intentar acceder a ella durante la ejecución
    del programa, y es un concepto **_estático_** si el lenguaje es compilado,
    o **_dinámico_** si es interpretado.

-->
</section>

<section id="almacenamiento" class="title-slide slide level3"
data-number="2.2.3">
<h3 data-number="2.2.3"><span class="header-section-number">2.2.3</span>
Almacenamiento</h3>
<ul>
<li><p>Sabemos que las ligaduras se almacenan en <em>espacios de
nombres</em>.</p></li>
<li><p>En Python, hay dos lugares donde se pueden almacenar ligaduras y,
por tanto, <strong>hay dos posibles espacios de nombres: los
<em>objetos</em> y los <em>marcos</em></strong>.</p></li>
<li><p>Así que tenemos dos posibilidades:</p>
<ol>
<li><p>Si el identificador que se está ligando es un <em>atributo</em>
de un objeto, entonces la ligadura se almacenará en el objeto, junto con
el propio atributo.</p></li>
<li><p>En caso contrario, la ligadura se almacenará en un marco, el cual
depende del <em>ámbito actual</em>.</p></li>
</ol></li>
<li><p>Veamos cada caso con más detalle.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.2.3.0.1">

<ol type="1">
<li><p>Cuando se crea una ligadura dentro de un objeto en Python usando
el operador punto (<code>.</code>), <strong>el espacio de nombres será
el propio objeto</strong>, ya que los objetos son espacios de nombres en
Python.</p>
<p>En tal caso, la ligadura asocia un valor con un <em>atributo</em> del
objeto, y tanto el atributo como la ligadura se almacenan dentro del
objeto.</p>
<p>Por ejemplo, si en Python hacemos:</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>math.x <span class="op">=</span> <span class="dv">75</span></span></code></pre></div>
<p>estamos creando la ligadura <code>x</code> → <code>75</code> en el
espacio de nombres que representa el módulo <code>math</code>, el cual
es un objeto en Python y, por tanto, es quien almacena la ligadura.</p>
<p>Así que el espacio de nombres ha sido seleccionado a través del
operador punto (<code>.</code>) para resolver el atributo dentro del
objeto, y no depende del ámbito donde se encuentre la sentencia <code
class="sourceCode python">math.x <span class="op">=</span> <span class="dv">75</span></code>.</p>
<p>Diremos que la ligadura es <strong>local</strong> al objeto.</p></li>
</ol>
</section>
<section class="slide level5" data-number="2.2.3.0.2">

<ol start="2" type="1">
<li><p>Si la ligadura no se crea dentro de un objeto usando el operador
punto (<code>.</code>), entonces el espacio de nombres irá asociado al
ámbito y, en este caso, <strong>ese espacio de nombres siempre será un
marco</strong>.</p>
<p>Ese marco será el que corresponda al <em>ámbito actual</em>, es
decir, el ámbito más interno en el que se encuentra la instrucción que
crea la ligadura.</p>
<p>Cuando el ámbito es el <em>ámbito global</em> (y, por tanto, la
ligadura se almacena en el marco global), se dice que la ligadura es
<strong>global</strong>.</p>
<p>En caso contrario, decimos que es <strong>local</strong> al ámbito, y
se almacenará en el marco correspondiente a ese ámbito.</p></li>
</ol>
</section>
<section id="ejemplo-1" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejemplo</h5>
<ul>
<li><p>En el siguiente ejemplo vemos cómo hay varias definiciones que,
al ejecutarse, crearán ligaduras en un determinado ámbito, pero no en un
objeto (ya que no se están creando atributos dentro de ningún
objeto):</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode numberSource python number-lines"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1"></a>x <span class="op">=</span> <span class="dv">25</span></span>
<span id="cb28-2"><a href="#cb28-2"></a>y <span class="op">=</span> <span class="dv">99</span></span>
<span id="cb28-3"><a href="#cb28-3"></a>z <span class="op">=</span> y</span>
<span id="cb28-4"><a href="#cb28-4"></a>nombre <span class="op">=</span> <span class="st">&#39;Manolo&#39;</span></span></code></pre></div></li>
<li><p>Todas esas definiciones son globales y, por tanto, las ligaduras
que crean al ejecutarse son ligaduras globales o de ámbito global, y se
almacenan en el marco global.</p></li>
<li><p>Al no tratarse de atributos de objetos, la visibilidad vendrá
determinada por sus ámbitos.</p></li>
<li><p>En consecuencia, la visibilidad de todas esas ligaduras será el
ámbito global, ya que son ligaduras globales. Por tanto, decimos que su
<strong>visibilidad</strong> es <strong>global</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.2.3.0.3">

<ul>
<li><p>Por otra parte, como esas ligaduras no se crean sobre atributos
de objetos, empezarán a existir justo donde se crean, y terminarán de
existir al final de su ámbito.</p></li>
<li><p>Por ejemplo, la ligadura <code>y</code> → <code>99</code>
empezará a existir en la línea 2 y terminará al final del
<em>script</em>, que es donde termina su ámbito (que, en este ejemplo,
es el ámbito global).</p></li>
<li><p>En consecuencia, el <strong>tiempo de vida</strong> de la
ligadura será el periodo comprendido desde su creación (en la línea 2)
hasta el final de su ámbito.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.2.3.0.4">

<ul>
<li><p>Cuando la ligadura se crea sobre un <strong>atributo</strong> de
un <em>objeto</em> de Python, entonces ese objeto almacenará la ligadura
y será, por tanto, su espacio de nombres.</p></li>
<li><p>Recordemos que, por ejemplo, cuando importamos un módulo usando
la sentencia <code
class="sourceCode python"><span class="im">import</span></code>, podemos
acceder al objeto que representa ese módulo usando su nombre, lo que nos
permite acceder a sus atributos y crear otros nuevos.</p></li>
<li><p>Esos atributos y sus ligaduras correspondientes sólo son visibles
cuando accedemos a ellos usando el operador punto (<code>.</code>) a
través del objeto que lo contiene.</p></li>
<li><p>Por tanto, los atributos no son visibles fuera del objeto, y
debemos usar el operador punto (<code>.</code>) para acceder a ellos (su
visibilidad es local al objeto que los contiene).</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.2.3.0.5">

<ul>
<li><p>Por ejemplo:</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> math</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> math.pi</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="fl">3.141592653589793</span>     <span class="co"># El nombre &#39;pi&#39; es visible dentro del objeto</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> pi                <span class="co"># El nombre &#39;pi&#39; no es visible fuera del objeto</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>Traceback (most recent call last):</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a><span class="pp">NameError</span>: name <span class="st">&#39;pi&#39;</span> <span class="kw">is</span> <span class="kw">not</span> defined</span></code></pre></div></li>
<li><p>Igualmente, si creamos un nuevo atributo dentro del objeto, la
ligadura entre el atributo y su valor sólo existirá en el propio objeto
y, por tanto, sólo será visible cuando accedamos al atributo a través
del objeto donde se ha creado.</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="im">import</span> math</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> math.x <span class="op">=</span> <span class="dv">95</span>       <span class="co"># Creamos un nuevo atributo en el objeto</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> math.x            <span class="co"># El nombre &#39;x&#39; es visible dentro del objeto</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="dv">95</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> x                 <span class="co"># El nombre &#39;x&#39; no es visible fuera del objeto</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>Traceback (most recent call last):</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a><span class="pp">NameError</span>: name <span class="st">&#39;x&#39;</span> <span class="kw">is</span> <span class="kw">not</span> defined</span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="2.2.3.0.6">

<ul>
<li><p>Resumiendo:</p>
<ul>
<li><p>Para poder acceder a un atributo de un objeto, debemos acceder
primero al objeto y usar el operador punto (<code>.</code>).</p></li>
<li><p>Por tanto, la <strong>visibilidad</strong> de su ligadura
correspondiente no vendrá determinada por un ámbito, sino por el objeto
que contiene al atributo (y que, por consiguiente, también contiene a su
ligadura).</p>
<p>En tal caso, diremos que la visibilidad es local al objeto que
contiene el atributo.</p></li>
<li><p>Por otra parte, el <strong>tiempo de vida</strong> de la ligadura
será el tiempo que permanezca el atributo en el objeto, ligado a algún
valor.</p></li>
</ul></li>
</ul>
</section>
<section id="resumen" class="title-slide slide level4"
data-number="2.2.3.1">
<h4 data-number="2.2.3.1"><span
class="header-section-number">2.2.3.1</span> Resumen</h4>
<div class="caja">
<p><strong>Ámbito (léxico):</strong></p>
<p>Porción del código fuente de un programa. Los límites de ese ámbito
sólo vienen determinados por la sintaxis del lenguaje, ya que ciertas
construcciones sintácticas determinan su propio ámbito.</p>
</div>
<div class="caja">
<p><strong>Ámbito de una definición:</strong></p>
<p>El ámbito actual de la definición; es decir: el ámbito más interno
donde aparece la definición.</p>
</div>
<div class="caja">
<p><strong>Ámbito de una ligadura:</strong></p>
<p>El ámbito de la instrucción que creará la ligadura en tiempo de
ejecución. Por ejemplo, si la instrucción es una definición, se
corresponde con el ámbito de la definición.</p>
</div>
</section>
<section class="slide level5" data-number="2.2.3.1.1">

<div class="caja">
<p><strong>Visibilidad de una ligadura:</strong></p>
<p>Determina dónde es visible una ligadura dentro del programa.</p>
<p>Esa visibilidad depende de si el identificador ligado es un atributo
de un objeto o no:</p>
<ol type="a">
<li><p>Si es un atributo de un objeto, la visibilidad lo determina el
objeto que contiene la ligadura.</p></li>
<li><p>En caso contrario, la visibilidad lo determina el ámbito de la
ligadura.</p></li>
</ol>
</div>
</section>
<section class="slide level5" data-number="2.2.3.1.2">

<div class="caja">
<p><strong>Tiempo de vida de una ligadura:</strong></p>
<p>El periodo de tiempo durante el cual <em>existe</em> esa ligadura, es
decir, el periodo comprendido desde su creación y almacenamiento en la
memoria hasta su posterior destrucción.</p>
<p>Su tiempo de vida empieza siempre en el momento en que se crea la
ligadura, y su final depende de si el identificador ligado es un
atributo de un objeto o no:</p>
<ol type="a">
<li><p>Si es un atributo de un objeto, el tiempo de vida acabará cuando
se destruya el objeto que lo contiene (o cuando se elimine el atributo
ligado).</p></li>
<li><p>En caso contrario, el tiempo de vida acabará al final del ámbito
de la ligadura.</p></li>
</ol>
</div>
</section>
<section class="slide level5" data-number="2.2.3.1.3">

<div class="caja">
<p><strong>Almacenamiento de una ligadura:</strong></p>
<p>Determina el <strong>espacio de nombres</strong> donde se almacenará
la ligadura:</p>
<ol type="a">
<li><p>Si el identificador ligado es un atributo de un objeto, el
espacio de nombres será el objeto que lo contiene.</p></li>
<li><p>En caso contrario, el espacio de nombres será el marco asociado
al ámbito de la ligadura.</p></li>
</ol>
</div>
</section>



<section id="ámbito-de-un-identificador"
class="title-slide slide level2" data-number="2.3">
<h2 data-number="2.3"><span class="header-section-number">2.3</span>
Ámbito de un identificador</h2>
<ul>
<li><p>A veces, por economía del lenguaje, se suele hablar del
«<strong><em>ámbito de un identificador</em></strong>», en lugar de
hablar del «<em>ámbito de la ligadura que liga ese identificador con un
valor</em>».</p></li>
<li><p>Por ejemplo, en el siguiente <em>script</em>:</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="dv">25</span></span></code></pre></div>
<p>tenemos que:</p>
<ul>
<li><p>En el ámbito global, hay una definición que liga al identificador
<code class="sourceCode python">x</code> con el valor <code
class="sourceCode python"><span class="dv">25</span></code>.</p></li>
<li><p>Por tanto, se dice que <strong>el <em>ámbito de esa ligadura</em>
es el ámbito global</strong>.</p></li>
<li><p>Pero también se suele decir que «<em>el identificador <code
class="sourceCode python">x</code> es global</em>» o, simplemente, que
«<em><code class="sourceCode python">x</code> es global</em>».</p></li>
</ul></li>
<li><p>O sea, se <strong>asocia al ámbito</strong> no la ligadura, sino
<strong>el identificador en sí</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.3.0.0.1">

<ul>
<li><p>Pero hay que tener cuidado, ya que ese mismo identificador puede
aparecer en ámbitos diferentes y, por tanto, ligarse en ámbitos
diferentes.</p></li>
<li><p>Así que no tendría sentido hablar del ámbito que tiene ese
identificador (ya que podría tener varios) sino, más bien, <strong>del
ámbito que tiene <em>una aparición concreta</em> de ese
identificador</strong>.</p></li>
<li><p>Por eso, sólo deberíamos hablar del ámbito de un identificador
cuando no haya ninguna ambigüedad respecto a qué aparición concreta nos
estamos refiriendo.</p></li>
<li><p>Por ejemplo, en el siguiente <em>script</em>:</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode numberSource python number-lines"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1"></a>x <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb32-2"><a href="#cb32-2"></a>suma <span class="op">=</span> (<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">2</span>, <span class="dv">3</span>)</span></code></pre></div>
<p>el identificador <code class="sourceCode python">x</code> que aparece
en la línea 1 y el identificador <code
class="sourceCode python">x</code> que aparece en la línea 2 pertenecen
a ámbitos distintos (como veremos en breve) aunque sea el mismo
identificador.</p></li>
</ul>
</section>

<section id="ámbito-de-un-parámetro" class="title-slide slide level2"
data-number="2.4">
<h2 data-number="2.4"><span class="header-section-number">2.4</span>
Ámbito de un parámetro</h2>
<ul>
<li><p><strong>El cuerpo de la expresión lambda determina un
ámbito.</strong></p></li>
<li><p>Por ejemplo, supongamos la siguiente llamada a una expresión
lambda:</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">lambda</span> x, y: x <span class="op">+</span> y)(<span class="dv">2</span>, <span class="dv">3</span>)</span></code></pre></div></li>
<li><p><strong>Al llamar a la expresión lambda</strong> (es decir, al
aplicar la expresión lambda a unos argumentos), se empieza a ejecutar su
cuerpo y, por tanto, <strong>se entra en dicho ámbito</strong>.</p></li>
<li><p>En ese momento, <strong>se crea un nuevo marco</strong> en la
memoria, que representa esa ejecución concreta de dicha expresión
lambda.</p></li>
<li><p>Lo que ocurre justo a continuación es que <strong>cada parámetro
de la expresión lambda se liga a uno de los argumentos</strong> en el
orden en que aparecen en la llamada a la expresión lambda (primer
parámetro con primer argumento, segundo con segundo, etcétera).</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.4.0.0.1">

<ul>
<li><p>En el ejemplo anterior, es como si el intérprete ejecutara las
siguientes definiciones dentro del ámbito de la expresión lambda:</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> <span class="dv">3</span></span></code></pre></div></li>
<li><p>Las ligaduras que crean esas definiciones <strong>se almacenan en
el marco de la llamada a la expresión lambda</strong>.</p></li>
<li><p>Ese marco se eliminará de la memoria al salir del ámbito de la
expresión lambda, es decir, cuando se termine de ejecutar el cuerpo de
la expresión lambda al finalizar la llamada a la misma.</p>
<p>Por tanto, las ligaduras se destruyen de la memoria al eliminarse el
marco que las almacena.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.4.0.0.2">

<ul>
<li><p>La próxima vez que se llame a la expresión lambda, se volverán a
ligar sus parámetros con los argumentos que haya en esa
llamada.</p></li>
<li><p>Por ejemplo, supongamos que tenemos esta situación:</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>suma <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> suma(<span class="dv">4</span>, <span class="dv">3</span>)</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> suma(<span class="dv">8</span>, <span class="dv">9</span>)</span></code></pre></div></li>
<li><p>En la primera llamada, se entrará en el ámbito determinado por el
cuerpo la expresión lambda, se creará el marco que representa a esa
llamada, y se ejecutarán las siguientes definiciones dentro del
ámbito:</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> <span class="dv">3</span></span></code></pre></div>
<p>lo que creará las correspondientes ligaduras y las almacenará en el
marco de esa llamada.</p>
<p>Despues, evaluará el cuerpo de la expresión lambda y devolverá el
resultado, saliendo del cuerpo de la expresión lambda y, por tanto, del
ámbito que determina dicho cuerpo, lo que hará que se destruya el marco
y, en consecuencia, las ligaduras que contiene.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.4.0.0.3">

<ul>
<li><p>En la siguiente llamada ocurrirá lo mismo pero, esta vez, las
definiciones que se ejecutarán serán las siguientes:</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="dv">8</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> <span class="dv">9</span></span></code></pre></div>
<p>lo que creará otras ligaduras, que serán destruidas luego cuando se
destruya el marco que las contiene, al finalizar la ejecución del cuerpo
de la expresión lambda.</p></li>
<li><p>Es importante hacer notar que <strong>en ningún momento se está
haciendo un <em>rebinding</em> de los parámetros</strong>, ya que cada
vez que se llama de nuevo a la expresión lambda, se está creando una
ligadura nueva sobre un identificador que no estaba ligado.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.4.0.0.4">

<ul>
<li><p>En consecuencia, podemos decir que:</p>
<ul>
<li><p>El <strong>ámbito de la ligadura</strong> entre un parámetro y su
argumento es el <strong>cuerpo</strong> de la expresión lambda, así que
la <strong>visibilidad</strong> del parámetro (y de la ligadura) es ese
cuerpo.</p></li>
<li><p>Esa ligadura se crea justo después de entrar en ese ámbito, así
que se puede acceder a ella en cualquier parte del cuerpo de la
expresión lambda, por lo que su <strong>tiempo de vida</strong> va desde
el principio hasta el final de la llamada.</p></li>
<li><p>El <strong>espacio de nombres</strong> que almacena las ligaduras
entre parámetros y argumentos es el <strong>marco</strong> que se crea
al llamar a la expresión lambda.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="2.4.0.0.5">

<ul>
<li><p>Esto se resume diciendo que «el <strong>ámbito de un
parámetro</strong> es el <strong>cuerpo</strong> de su expresión
lambda».</p></li>
<li><p>También se dice que el parámetro tiene un <strong>ámbito
<em>local</em></strong> y un <strong>almacenamiento
<em>local</em></strong> al cuerpo de la expresión lambda.</p>
<p>Resumiendo: el parámetro es <strong>local</strong> a dicha expresión
lambda.</p></li>
<li><p>Por tanto, <strong>sólo podemos acceder al valor de un parámetro
dentro del cuerpo de su expresión lambda</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.4.0.0.6">

<!-- Esta diapositiva está repetida en una sección posterior -->
<ul>
<li><p>Por ejemplo, en el siguiente código:</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>suma <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span></code></pre></div>
<p>el cuerpo de la expresión lambda ligada a <code
class="sourceCode python">suma</code> determina su propio
ámbito.</p></li>
<li><p>Por tanto, en el siguiente código tenemos dos ámbitos: el ámbito
global (más externo) y el ámbito del cuerpo de la expresión lambda (más
interno y anidado dentro del ámbito global):</p>
<div class="centered">
<p><img data-src="images/ambitos-anidados.png" class="plain"
style="width:60.0%" /></p>
</div></li>
<li><p>Además, cada vez que se llama a <code
class="sourceCode python">suma</code>, la ejecución del programa entra
en su cuerpo, lo que crea un nuevo marco que almacena las ligaduras
entre sus parámetros y los argumentos usados en esa llamada.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.4.0.0.7">

<div class="caja">
<p><strong>En resumen:</strong></p>
<ul>
<li><p>El <strong>ámbito de un parámetro</strong> es el ámbito de la
ligadura que se establece entre éste y su argumento correspondiente, y
se corresponde con el <strong>cuerpo</strong> de la expresión lambda
donde aparece.</p></li>
<li><p>Por tanto, el parámetro sólo existe dentro del cuerpo de la
expresión lambda y no podemos <strong>acceder</strong> a su valor fuera
del mismo; por eso se dice que tiene un <strong>ámbito
<em>local</em></strong> a la expresión lambda.</p></li>
<li><p>Además, <strong>la ligadura</strong> entre el parámetro y su
argumento <strong>se almacena en el marco</strong> de la llamada a la
expresión lambda, y por eso se dice que tiene un <strong>almacenamiento
<em>local</em></strong> a la expresión lambda.</p></li>
</ul>
</div>
</section>
<section class="slide level5" data-number="2.4.0.0.8">

<ul>
<li><p>Los ámbitos léxicos permiten ligaduras locales a ciertas
construcciones sintácticas, lo cual nos permite programar definiendo
partes suficientemente independientes entre sí.</p></li>
<li><p>Esto es la base de la llamada <em>programación
modular</em>.</p></li>
<li><p>Por ejemplo, nos permite crear funciones sin preocuparnos de si
los nombres de los parámetros ya han sido utilizados en otras partes del
programa.</p></li>
<li><p>Igualmente, nos permite crear programas sin preocuparnos de si
estamos usando nombres que ya han sido usadas en el interior de alguna
de las funciones del programa.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.4.0.0.9">

<ul>
<li><p>De lo contrario, se podría provocar lo que se conoce como
<strong><em>name clash</em></strong> (<em>conflicto de nombres</em> o
<em>choque de nombres</em>), que es el problema que se produce cuando
usamos el mismo nombre para varias cosas diferentes y que impide que se
puedan acceder a todas al mismo tiempo.</p></li>
<li><p>Lo que impide el <em>name clash</em> son dos cosas:</p>
<ul>
<li><p>Los <em>ámbitos</em> hacen que los nombres sólo sean visibles en
ciertas zonas.</p></li>
<li><p>Los <em>espacios de nombres</em> permiten que un mismo nombre
pueda ligarse a diferentes nombres simultáneamente.</p></li>
</ul></li>
</ul>
</section>

<section id="ámbito-de-un-identificador-cuantificado"
class="title-slide slide level2" data-number="2.5">
<h2 data-number="2.5"><span class="header-section-number">2.5</span>
Ámbito de un identificador cuantificado</h2>
<ul>
<li><p>Hemos visto que a los <strong>parámetros</strong> de una
expresión lambda se les llama <strong>identificadores
cuantificados</strong> cuando aparecen dentro del cuerpo de dicha
expresión lambda.</p></li>
<li><p>Por tanto, todo lo que se dijo sobre el ámbito de un parámetro se
aplica exactamente igual al ámbito de un identificador
cuantificado.</p></li>
<li><p>Recordemos que el ámbito de un parámetro es el cuerpo de su
expresión lambda, que es la porción de código donde podemos acceder al
valor del argumento con el que está ligado.</p></li>
<li><p>Por tanto, <strong>el <em>ámbito</em> de un identificador
cuantificado es el <em>cuerpo</em> de la expresión lambda</strong> donde
aparece, y es el único lugar dentro del cual podremos acceder al valor
del identificador cuantificado (que también será el valor del argumento
con el que está ligada).</p></li>
<li><p>Por eso también se dice que el identificador cuantificado tiene
un <strong>ámbito local</strong> al cuerpo de la expresión
lambda.</p></li>
</ul>
</section>
<section class="slide level5" data-number="2.5.0.0.1">

<div class="caja">
<p><strong>En resumen:</strong></p>
<ul>
<li><p>El <strong>ámbito de un identificador cuantificado</strong> es el
ámbito de la ligadura que se crea entre ésto y su argumento
correspondiente, y se corresponde con el <strong>cuerpo</strong> de la
expresión lambda donde aparece.</p></li>
<li><p>Por tanto, el identificador cuantificado sólo existe dentro del
cuerpo de la expresión lambda y no podemos <strong>acceder</strong> a su
valor fuera del mismo; por eso se dice que tiene un <strong>ámbito
<em>local</em></strong> a la expresión lambda.</p></li>
<li><p>Además, <strong>la ligadura</strong> entre el identificador
cuantificado y su argumento <strong>se almacena en el marco</strong> de
la llamada a la expresión lambda, y por eso se dice que tiene un
<strong>almacenamiento <em>local</em></strong> a la expresión
lambda.</p></li>
</ul>
</div>
<ul>
<li>O sea: con los <strong>identificadores cuantificados</strong> ocurre
exactamente lo mismo que con los <strong>parámetros</strong>, ya que, de
hecho, <strong>un parámetro y un identificador cuantificado son la misma
cosa</strong>, como ya hemos visto.</li>
</ul>
</section>
<section id="ejemplo-2" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejemplo</h5>
<ul>
<li><p>En el siguiente <em>script</em>:</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode numberSource python number-lines"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1"></a><span class="co"># Aquí empieza el script (no hay más definiciones antes de esta línea):</span></span>
<span id="cb39-2"><a href="#cb39-2"></a>producto <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> x</span>
<span id="cb39-3"><a href="#cb39-3"></a>y <span class="op">=</span> producto(<span class="dv">3</span>)</span>
<span id="cb39-4"><a href="#cb39-4"></a>z <span class="op">=</span> x <span class="op">+</span> <span class="dv">1</span>       <span class="co"># da error</span></span></code></pre></div></li>
<li><p>Hay dos ámbitos: el ámbito global y el ámbito local definido por
el cuerpo de la expresión lambda (o sea, la expresión <code
class="sourceCode python">x <span class="op">*</span> x</code>).</p></li>
<li><p>Esa expresión lambda tiene un parámetro (<code
class="sourceCode python">x</code>) que aparece como el identificador
cuantificado <code class="sourceCode python">x</code> en el cuerpo de la
expresión lambda.</p></li>
<li><p>El ámbito del parámetro <code class="sourceCode python">x</code>
(o, lo que es lo mismo, el identificador cuantificado <code
class="sourceCode python">x</code>) es el <strong>cuerpo</strong> de la
expresión lambda.</p></li>
<li><p>Por tanto, fuera de ese cuerpo, no es posible acceder al valor
del identificador cuantificado <code class="sourceCode python">x</code>,
al encontrarnos <strong>fuera de su ámbito</strong> (la ligadura
<strong>sólo es visible dentro del cuerpo</strong> de la expresión
lambda).</p></li>
<li><p>Por eso, la línea 4 dará un error al intentar acceder al valor
<code class="sourceCode python">x</code>, cuya ligadura no es visible
fuera de la expresión lambda.</p></li>
</ul>
</section>

<section id="ámbito-de-un-identificador-libre"
class="title-slide slide level2" data-number="2.6">
<h2 data-number="2.6"><span class="header-section-number">2.6</span>
Ámbito de un identificador libre</h2>
<ul>
<li><p>Los identificadores y ligaduras que no tienen ámbito local se
dice que tienen un <strong>ámbito <em>no local</em></strong> o, a veces,
un <strong>ámbito <em>más global</em></strong>.</p>
<p>Si, además, ese ámbito resulta ser el <strong>ámbito global</strong>,
decimos directamente que esos identificadores o ligaduras son
<strong>globales</strong>.</p></li>
<li><p>Por ejemplo, los <strong>identificadores libres</strong> que
aparecen en una expresión lambda no son locales a dicha expresión (ya
que no representan parámetros de la expresión) y, por tanto:</p>
<ol>
<li><p>Tienen un ámbito más global que el cuerpo de dicha expresión
lambda.</p></li>
<li><p>Se almacenarán en otro espacio de nombres distinto al marco que
se crea al llamar a la expresión lambda.</p></li>
</ol></li>
</ul>
</section>
</section>
<section>
<section id="abstracciones-funcionales" class="title-slide slide level1"
data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span>
Abstracciones funcionales</h1>

</section>
<section id="las-funciones-como-abstracciones"
class="title-slide slide level2" data-number="3.1">
<h2 data-number="3.1"><span class="header-section-number">3.1</span> Las
funciones como abstracciones</h2>
<ul>
<li><p>Recordemos la definición de la función <code
class="sourceCode python">area</code>:</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>cuadrado <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> x</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>area <span class="op">=</span> <span class="kw">lambda</span> r: <span class="fl">3.1416</span> <span class="op">*</span> cuadrado(r)</span></code></pre></div></li>
<li><p>Aunque es muy sencilla, la función <code
class="sourceCode python">area</code> ejemplifica la propiedad más
potente de las funciones definidas por el programador: la
<strong>abstracción</strong>.</p></li>
<li><p>La función <code class="sourceCode python">area</code> está
definida sobre la función <code
class="sourceCode python">cuadrado</code>, pero sólo necesita saber de
ella qué resultados de salida devuelve a partir de sus argumentos de
entrada (o sea, <strong><em>qué</em></strong> calcula y no
<strong><em>cómo</em></strong> lo calcula).</p></li>
<li><p>Podemos escribir la función <code
class="sourceCode python">area</code> sin preocuparnos de cómo calcular
el cuadrado de un número, porque eso ya lo hace la función <code
class="sourceCode python">cuadrado</code>.</p></li>
<li><p><strong>Los detalles</strong> sobre cómo se calcula el cuadrado
están <strong>ocultos dentro de la definición</strong> de <code
class="sourceCode python">cuadrado</code>. Esos detalles <strong>se
ignoran en este momento</strong> al diseñar <code
class="sourceCode python">area</code>, para considerarlos más tarde si
hiciera falta.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.1.0.0.1">

<ul>
<li><p>De hecho, por lo que respecta a <code
class="sourceCode python">area</code>, <code
class="sourceCode python">cuadrado</code> no representa una definición
concreta de función, sino más bien la abstracción de una función, lo que
se denomina una <strong>abstracción funcional</strong>, ya que a <code
class="sourceCode python">area</code> le sirve igual de bien cualquier
función que calcule el cuadrado de un número.</p></li>
<li><p>Por tanto, si consideramos únicamente los valores que devuelven,
las tres funciones siguientes son indistinguibles e igual de válidas
para <code class="sourceCode python">area</code>. Ambas reciben un
argumento numérico y devuelven el cuadrado de ese número:</p>
<div class="sourceCode" id="cb41"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>cuadrado <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> x</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>cuadrado <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>cuadrado <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> (x <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> x</span></code></pre></div></li>
<li><p>En otras palabras: la definición de una función debe ser capaz de
<strong>ocultar sus detalles internos de funcionamiento</strong>, ya que
para usar la función no debe ser necesario conocer esos
detalles.</p></li>
</ul>
</section>
<section id="encapsulación-y-cajas-negras"
class="title-slide slide level3" data-number="3.1.1">
<h3 data-number="3.1.1"><span class="header-section-number">3.1.1</span>
Encapsulación y cajas negras</h3>
<ul>
<li><p><strong>Encapsular</strong> es encerrar varios elementos juntos
dentro una <strong><em>cápsula</em></strong> que se puede manipular como
una sola unidad, de forma que parte de lo que hay dentro queda visible y
accesible desde el exterior, mientras que el resto queda oculto e
inaccesible en el interior.</p></li>
<li><p>La <strong>encapsulación</strong> es el mecanismo que
proporcionan los lenguajes de programación para que el programador pueda
encapsular elementos de un programa, y puede verse al mismo tiempo como
un mecanismo de <em>agrupamiento</em> y como un mecanismo de de
<em>protección</em>.</p></li>
<li><p>La membrana de la cápsula separa el exterior del interior de la
misma, y es una membrana <em>permeable</em> porque permite exponer los
elementos de la cápsula que son visibles y accesibles desde fuera de
ella.</p></li>
<li><p>La cápsula tiene un espacio de nombres local que guarda las las
ligaduras que van dentro de la cápsula y que previenen el <em>name
clash</em>, haciendo que varias cápsulas puedan contener elementos
internos con el mismo nombre sin que haya conflictos.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.1.1.0.1">

<ul>
<li><p>Una <strong>caja negra</strong> es una cápsula que expone
justamente aquello que es necesario conocer para poder usarla (el
<em>qué</em> hace) y oculta todos los demás detalles internos de
funcionamiento (el <em>cómo</em> lo hace).</p></li>
<li><p>La «tapa» de la caja negra es precisamente la barrera de
separación entre el qué hace y el cómo lo hace.</p></li>
<li><p><strong>Abstraer</strong> es quedarse con la idea esencial de
aquello que se está estudiando; el producto resultante de ese proceso se
llama <em>abstracción</em>.</p></li>
<li><p>Por tanto, la <strong>abstracción</strong>:</p>
<ul>
<li><p>Como <em>acción</em>, es el proceso mental que consiste en
centrarse en lo que es importante y esencial en un determinado momento e
ignorar los detalles que en ese momento no resultan
importantes.</p></li>
<li><p>Como <em>producto</em>, es una caja negra que contiene un
mecanismo más o menos complejo y a la que se le da un nombre. De esta
forma, podemos referirnos a todo el mecanismo simplemente usando ese
nombre sin tener que conocer su composición interna ni sus detalles
internos de funcionamiento.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.1.1.0.2">

<ul>
<li><p>Por tanto, para usar la abstracción nos bastará con conocer su
<em>nombre</em> y saber <em>qué hace</em>, sin necesidad de saber
<em>cómo lo hace</em> ni qué elementos la forman
<em>internamente</em>.</p></li>
<li><p>En consecuencia, las abstracciones están <em>encapsuladas</em>,
pero no de cualquier manera, sino de forma que:</p>
<ul>
<li><p>lo que queda visible desde el exterior de la cápsula es <em>qué
hace la abstracción</em>, y</p></li>
<li><p>lo que se oculta en el interior es <em>cómo lo
hace</em>.</p></li>
</ul></li>
<li><p>Es decir: <strong>las abstracciones son <em>cajas
negras</em></strong>.</p></li>
<li><p>Por tanto, podemos definir una caja negra como una cápsula que
representa una abstracción.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.1.1.0.3">

<ul>
<li><p><strong>La abstracción es el principal instrumento de control de
la complejidad</strong>, ya que nos permite ocultar detrás de un nombre
los detalles que componen una parte del programa, haciendo que esa parte
actúe (a ojos del programador que la utilice) como si fuera un elemento
<em>predefinido</em> del lenguaje, de forma que el programador lo puede
usar sin tener que saber cómo funciona por dentro.</p></li>
<li><p>Por tanto, <strong>las funciones son abstracciones</strong>
porque nos permiten usarlas sin tener que conocer los detalles internos
del procesamiento que realizan.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.1.1.0.4">

<ul>
<li><p>Por ejemplo, si queremos usar la función <code
class="sourceCode python">cubo</code> (que calcula el cubo de un
número), nos da igual que dicha función esté implementada de cualquiera
de las siguientes maneras:</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>cubo <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> x <span class="op">*</span> x</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>cubo <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">**</span> <span class="dv">3</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>cubo <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> x <span class="op">**</span> <span class="dv">2</span></span></code></pre></div></li>
<li><p>Para <strong>usar</strong> la función, nos basta con saber que
calcula el cubo de un número, sin necesidad de saber qué cálculo
concreto realiza para obtener el resultado.</p></li>
<li><p>Los detalles de implementación quedan ocultos y por eso también
decimos que <code class="sourceCode python">cubo</code> es una
abstracción.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.1.1.0.5">

<ul>
<li><p>Las funciones también son abstracciones porque nos permiten
definir <strong>conceptos abstractos</strong>.</p></li>
<li><p>Por ejemplo, cuando definimos:</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>cubo <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> x <span class="op">*</span> x</span></code></pre></div>
<p>estamos definiendo en qué consiste <em>elevar «algo» al cubo</em>, es
decir, estamos creando un concepto que antes no existía, y se lo estamos
enseñando a nuestro lenguaje.</p></li>
<li><p>De esta forma, nuestro lenguaje ya sabrá qué es elevar algo al
cubo, y podremos usarlo en nuestros programas.</p></li>
<li><p>Por supuesto, nos las podemos arreglar sin definir el concepto de
<em>cubo</em>, escribiendo siempre expresiones explícitas (como <code
class="sourceCode python"><span class="dv">3</span><span class="op">*</span><span class="dv">3</span><span class="op">*</span><span class="dv">3</span></code>,
<code
class="sourceCode python"><span class="dv">5</span><span class="op">*</span><span class="dv">5</span><span class="op">*</span><span class="dv">5</span></code>,
etc.) sin usar la palabra «<code>cubo</code>», pero eso nos obligaría
siempre a expresarnos usando las operaciones primitivas de nuestro
lenguaje (como <code>*</code>), en vez de poder usar términos de más
alto nivel.</p>
<p>Es decir: <strong>nuestros programas podrían calcular el cubo de un
número, pero no tendrían la habilidad de expresar el concepto de
<em>elevar al cubo</em></strong>.</p></li>
</ul>
</section>

<section id="generalización" class="title-slide slide level3"
data-number="3.1.2">
<h3 data-number="3.1.2"><span class="header-section-number">3.1.2</span>
Generalización</h3>
<ul>
<li><p>Finalmente, las funciones también son
<strong>generalizaciones</strong> de casos particulares porque describen
operaciones compuestas a realizar sobre ciertos valores sin importar
cuáles sean esos valores en concreto.</p></li>
<li><p>Por ejemplo, cuando definimos:</p>
<div class="sourceCode" id="cb44"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>cubo <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> x <span class="op">*</span> x</span></code></pre></div>
<p>no estamos hablando del cubo de un número en particular, sino más
bien de un <strong>método</strong> para calcular el cubo de cualquier
número.</p></li>
<li><p>De esta forma, podemos usar la función para obtener los
diferentes casos particulares que obtendríamos si no tuviéramos la
función.</p></li>
<li><p>Por ejemplo, podremos usar <code
class="sourceCode python">cubo(<span class="dv">3</span>)</code> en
lugar de <code
class="sourceCode python"><span class="dv">3</span><span class="op">*</span><span class="dv">3</span><span class="op">*</span><span class="dv">3</span></code>,
<code class="sourceCode python">cubo(<span class="dv">5</span>)</code>
en lugar de <code
class="sourceCode python"><span class="dv">5</span><span class="op">*</span><span class="dv">5</span><span class="op">*</span><span class="dv">5</span></code>,
etc.</p></li>
<li><p>Es decir, estamos expresando cómo se calcula el cubo de cualquier
número, en general.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.1.2.0.1">

<ul>
<li><p>Una de las habilidades que deberíamos pedir a un lenguaje potente
es la posibilidad de <strong>construir abstracciones</strong> asignando
nombres a los patrones más comunes, y luego trabajar directamente usando
dichas abstracciones.</p></li>
<li><p>Las funciones nos permiten esta habilidad, y esa es la razón de
que todos los lenguajes (salvo los más primitivos) incluyan mecanismos
para definir funciones.</p></li>
<li><p>Por ejemplo: en el caso anterior, vemos que hay un patrón
(multiplicar algo por sí mismo tres veces) que se repite con frecuencia,
y a partir de él construimos una abstracción que asigna un nombre a ese
patrón (<em>elevar al cubo</em>).</p></li>
<li><p>Esa abstracción la definimos como una función que describe la
<em>regla</em> necesaria para elevar algo al cubo.</p></li>
<li><p>Esa técnica combina la abstracción con la
generalización.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.1.2.0.2">

<ul>
<li><p>De esta forma, analizando ciertos <em>casos particulares</em>,
observamos que se repite el mismo patrón en todos ellos (es decir,
<strong>abstraemos</strong> el concepto esencial), y de ahí extraemos un
<em>caso general</em> (es decir, hacemos una
<strong>generalización</strong>) que agrupa a todos los posibles casos
particulares que cumplen ese patrón.</p></li>
<li><p>Luego, hacemos una <strong>encapsulación</strong>, metiendo ese
caso general en una «<em>caja negra</em>» que oculte sus detalles
internos, y finalmente le damos un nombre a la «caja», con lo que
acabamos creando una <strong>abstracción</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.1.2.0.3">

<ul>
<li><p>En resumen, creamos abstracciones:</p>
<ul>
<li><p>Cuando queremos <strong>reducir la complejidad</strong>, dándole
un nombre a un mecanismo complejo para poder referirnos a todo el
conjunto a través de su nombre sin tener que recordar continuamente qué
piezas contiene el mecanismo o cómo funciona éste por dentro.</p></li>
<li><p>Cuando queremos que nuestro programa pueda <strong>expresar un
concepto abstracto</strong>, como el de «elevar al cubo».</p></li>
<li><p>Cuando creamos <strong>casos generales a partir de patrones que
se repiten</strong> en varios casos particulares.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.1.2.0.4">

<ul>
<li><p>Por ejemplo, cuando vemos que en nuestros programas es frecuente
tener que multiplicar una cosa por sí misma tres veces, deducimos que
ahí hay un patrón común que se repite en todos los casos.</p></li>
<li><p>De ahí, creamos la abstracción que describe ese patrón general y
le llamamos «<em>elevar al cubo</em>»:</p></li>
</ul>
<div class="centered">
<p><img data-src="images/de-particular-a-general.svg" class="plain"
style="width:80.0%" /></p>
</div>
</section>
<section class="slide level5" data-number="3.1.2.0.5">

<ul>
<li><p>Ese patrón general representa a cada miembro del grupo formado
por sus casos particulares, y se construye colocando un
<em>parámetro</em> allí donde los casos particulares se diferencian
entre sí (es decir, hacemos una
<strong>parametrización</strong>).</p></li>
<li><p>La función resultante es, al mismo tiempo:</p>
<ul>
<li><p>una <strong>encapsulación</strong> (porque los detalles internos
de la función quedan ocultos dentro del cuerpo de la expresión lambda
como si fuera una caja negra),</p></li>
<li><p>una <strong>abstracción</strong> (porque se puede invocar a la
función usando simplemente su nombre sin necesidad de saber cómo está
hecha por dentro y, por tanto, sabiendo <em>qué</em> sin tener que saber
<em>cómo</em> lo hace), y</p></li>
<li><p>una <strong>generalización</strong> (porque, al estar
parametrizada, representa muchos casos particulares con un único caso
general).</p></li>
</ul></li>
<li><p>Al invocar a la función, se ligan sus parámetros con los
argumentos de la llamada, lo que produce un caso particular a partir del
caso general.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.1.2.0.6">

<ul>
<li><p>En resumen, el proceso conceptual sería el siguiente:</p>
<ol type="1">
<li><p>Observar que hay varios casos particulares que se parecen según
un patrón común y que representan el mismo concepto.</p></li>
<li><p>Generalizar esos casos particulares y parametrizar el caso
general creando una expresión lambda.</p></li>
<li><p>Abstraer la expresión lambda dándole un nombre.</p></li>
</ol></li>
<li><p>Veamos cada paso por separado con detalle.</p></li>
</ul>
</section>
<section id="paso-1-abstracción"
class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Paso 1: Abstracción</h5>
<ul>
<li><p>Partimos de casos particulares que se parecen. Por ejemplo,
supongamos las siguientes expresiones:</p>
<div class="sourceCode" id="cb45"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span> <span class="op">*</span> <span class="dv">3</span> <span class="op">*</span> <span class="dv">3</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="dv">5</span> <span class="op">*</span> <span class="dv">5</span> <span class="op">*</span> <span class="dv">5</span></span></code></pre></div></li>
<li><p>Si las comparamos, vemos que tienen la misma forma y que
contienen elementos que son iguales y otros que son diferentes.</p></li>
<li><p>Por ejemplo, los operadores <code>*</code> son iguales, y lo que
varía es la cosa que se multiplica (el <code>3</code>, el
<code>5</code>, etcétera).</p></li>
<li><p>A partir de ahí, hacemos abstracción y nos centramos en estudiar
aquello en lo que se parecen e ignoramos aquello en lo que se
diferencian.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.1.2.0.7">

<ul>
<li><p>Haciendo eso, deducimos un patrón común que subyace a todas esas
expresiones.</p></li>
<li><p>En este caso, el patrón es que en todas ellas hay «algo» que se
multiplica por sí mismo tres veces.</p></li>
<li><p>Al deducir ese patrón estamos realizando un proceso de
abstracción, porque nos estamos centrando en lo que ahora mismo importa
(es un producto de «cosas») e ignorando los detalles que ahora mismo no
importan (qué son esas «cosas»).</p></li>
<li><p>Ese patrón representa el concepto abstracto de «elevar al
cubo».</p></li>
<li><p>Ahora bien: ¿cómo se materializa ese concepto?</p></li>
</ul>
</section>
<section id="paso-2-generalización"
class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Paso 2: Generalización</h5>
<ul>
<li><p>Generalizamos estos casos particulares, <em>parametrizando</em>
los elementos en los que se diferencian (es decir, las partes que no son
comunes) y dejando el resto igual.</p></li>
<li><p>En nuestro ejemplo, los casos particulares se distinguen en el
número que se multiplica para calcular el cubo. Por tanto, habrá un
único parámetro que representará dicho número.</p></li>
<li><p>Incorporamos el parámetro en la expresión sustituyendo, en uno
cualquiera de los casos particulares, el número que se multiplica por el
nombre que escojamos para el parámetro (el cual debe ser un
identificador que no estuviera ya en la expresión) y utilizamos el
cuantificador <code
class="sourceCode python"><span class="kw">lambda</span></code>, creando
así una <strong><em>expresión lambda</em></strong>:</p>
<div class="sourceCode" id="cb46"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">lambda</span> x: x <span class="op">*</span> x <span class="op">*</span> x</span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="3.1.2.0.8">

<ul>
<li><p>Los <strong>parámetros</strong> son nombres que tomarán los
valores de los argumentos aplicados a la expresión lambda. En este caso,
la <code>x</code> es el único parámetro que tiene la expresión lambda
anterior.</p></li>
<li><p>Esa expresión describe el patrón común como un <strong>caso
general</strong> de las expresiones anteriores, ya que representa a
todos los posibles casos particulares (potencialmente infinitos) que se
ajustan a ese mismo patrón. Por ese motivo decimos que es una
<strong>generalización</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.1.2.0.9">

<ul>
<li><p>Un <strong><em>cuantificador</em></strong> es un símbolo que
convirte constantes en variables. En este caso, convierte las constantes
<code>3</code>, <code>5</code>, etc. en el identificador
<code>x</code>.</p></li>
<li><p>Ese identificador está cuantificado porque está afectado por el
cuantificador <code>lambda</code>. De lo contrario, sería un
identificador <em>libre</em>.</p></li>
<li><p>Al invocarla con un argumento concreto, el parámetro toma el
valor de ese argumento y así se van obteniendo los casos particulares
deseados:</p>
<div class="sourceCode" id="cb47"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">lambda</span> x: x <span class="op">*</span> x <span class="op">*</span> x)(<span class="dv">3</span>) → <span class="dv">3</span> <span class="op">*</span> <span class="dv">3</span> <span class="op">*</span> <span class="dv">3</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">lambda</span> x: x <span class="op">*</span> x <span class="op">*</span> x)(<span class="dv">5</span>) → <span class="dv">5</span> <span class="op">*</span> <span class="dv">5</span> <span class="op">*</span> <span class="dv">5</span></span></code></pre></div></li>
<li><p>La expresión lambda es una expresión que puede usarse simplemente
aplicando los argumentos necesarios en cada llamada, sin necesidad de
manipular directamente la expresión que forma su cuerpo y que es la que
lleva a cabo el procesamiento y el cálculo del resultado.</p></li>
<li><p>Por eso podemos decir que la expresión lambda está
<em>encapsulada</em> formando una <strong>caja negra</strong> con una
parte expuesta, visible y manipulable desde el exterior (sus parámetros)
y otra parte oculta dentro de la cápsula (su cuerpo), que no
necesitaríamos manipular para poder usar la expresión lambda.</p></li>
</ul>
</section>
<section id="paso-3-más-abstracción"
class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Paso 3: Más abstracción</h5>
<ul>
<li><p>Aunque para usar una expresión lambda no necesitamos conocer cómo
es su cuerpo, en la práctica sí que podemos verlo (aunque no podemos
manipularlo directamente):</p>
<div class="sourceCode" id="cb48"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">lambda</span> x: x <span class="op">*</span> x <span class="op">*</span> x)(<span class="dv">3</span>) → <span class="dv">3</span> <span class="op">*</span> <span class="dv">3</span> <span class="op">*</span> <span class="dv">3</span></span></code></pre></div></li>
<li><p>Una expresión lambda sin nombre es como una función de «usar y
tirar» que vive y muere en la misma expresión donde se la
utiliza.</p></li>
<li><p>En general, las <strong>abstracciones de usar y tirar</strong>
son aquellas que se crean para cumplir una función concreta, en un punto
específico del programa, y después no se reutilizan ni se les da un
nombre permanente.</p></li>
<li><p>Son abstracciones efímeras, que encapsulan algo pero sin la
intención de volver a usarlas más adelante.</p></li>
<li><p>En cambio, cuando le damos un nombre, subimos más el nivel de
abstracción ya que puede reutilizarse en muchas expresiones y toda la
expresión lambda queda «oculta» bajo el nombre que le damos.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.1.2.0.10">

<ul>
<li><p>Así, ahora podemos usar su nombre en lugar de la expresión lambda
y con ello creamos una <strong>abstracción lambda</strong>:</p>
<div class="sourceCode" id="cb49"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>cubo <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">*</span> x <span class="op">*</span> x</span></code></pre></div></li>
<li><p>De ahora en adelante, podemos invocar a la función usando su
nombre, sin tener que recordar incluso que debajo hay una expresión
lambda concreta:</p>
<div class="sourceCode" id="cb50"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>cubo(<span class="dv">3</span>) → <span class="dv">3</span> <span class="op">*</span> <span class="dv">3</span> <span class="op">*</span> <span class="dv">3</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>cubo(<span class="dv">5</span>) → <span class="dv">5</span> <span class="op">*</span> <span class="dv">5</span> <span class="op">*</span> <span class="dv">5</span></span></code></pre></div></li>
<li><p>La función <code>cubo</code> así creada <strong>es una
abstracción</strong> porque:</p>
<ul>
<li><p>Para usarla sólo basta con saber su nombre y <em>qué</em>
hace.</p></li>
<li><p>No es necesario saber <em>cómo</em> lo hace.</p></li>
<li><p>Es una caja negra que expone el <em>qué</em> y oculta el
<em>cómo</em>.</p></li>
</ul></li>
<li><p>Ahora ya ni siquiera tenemos que saber cómo es la expresión
lambda a la que está ligada el nombre. Por tanto, trabajamos a un nivel
mayor de abstracción.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.1.2.0.11">

<ul>
<li><p>La importancia de la <strong>abstracción</strong> reside en su
capacidad para ocultar detalles irrelevantes y en el uso de nombres para
referenciar objetos.</p></li>
<li><p>La principal preocupación del usuario de un programa (o de cada
una de sus partes) es <em>qué</em> hace. Esto contrasta con la del
programador de esa parte del programa, cuya principal preocupación es
<em>cómo</em> lo hace.</p></li>
<li><p>Los lenguajes de programación proporcionan abstracción mediante
funciones (y otros elementos como procedimientos y módulos, que veremos
posteriormente) que permiten al programador distinguir entre lo que hace
una parte del programa y cómo se implementa esa parte.</p></li>
<li><p>Una función, además, <strong>encapsula</strong> porque crea una
<em>cápsula</em> alrededor de ella que sólo deja visible al exterior
parte de su contenido; en particular, la cápsula de una función sólo
deja pasar fuera lo necesario para poder usar la función, y oculta
dentro todo lo demás, es decir, lo que no es necesario conocer ni
manipular para usarla.</p></li>
<li><p>La abstracción es esencial en la construcción de programas. Pone
el énfasis en lo que algo es o hace, más que en cómo se representa o
cómo funciona. Por lo tanto, es el principal medio para gestionar la
complejidad en programas grandes.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.1.2.0.12">

<ul>
<li><p>De igual importancia es la
<strong>generalización</strong>.</p></li>
<li><p>Mientras que la abstracción reduce la complejidad al ocultar
detalles irrelevantes, la generalización la reduce al sustituir, con una
sola construcción, varios elementos que realizan una funcionalidad
similar.</p></li>
<li><p>Los lenguajes de programación permiten la generalización mediante
variables, parametrización, genéricos y polimorfismo.</p></li>
<li><p>La generalización es esencial en la construcción de programas.
Pone el énfasis en las similitudes entre elementos. Por lo tanto, ayuda
a gestionar la complejidad al agrupar individuos y proporcionar un
representante que puede utilizarse para especificar cualquier individuo
del grupo.</p></li>
</ul>
</section>
<section id="resumen-1"
class="title-slide slide level4 unnumbered unlisted">
<h4 class="unnumbered unlisted">Resumen</h4>
<ul>
<li><p><strong>Encapsulación</strong>: Es agrupar varios elementos
juntos formando una sola unidad, ocultando algunos y exponiendo
otros.</p></li>
<li><p><strong>Cápsula</strong>: Es el resultado de la encapsulación. La
membrana de la cápsula separa lo que se expone de lo que se oculta al
exterior.</p></li>
<li><p><strong>Caja negra</strong>: Es una cápsula que expone sólo lo
necesario para poder usarla y oculta el resto de detalles innecesarios.
La «tapa» de la caja negra separa el <em>qué</em> hace del <em>cómo</em>
lo hace.</p></li>
<li><p><strong>Abstracción</strong>: Conceptualmente, es el proceso de
simplificar algo resaltando solo sus características esenciales y
ocultando los detalles irrelevantes para el contexto en que se usa.</p>
<p>En la práctica, también es el producto resultante de ese proceso. En
tal caso, una abstracción consiste en darle un nombre a una caja negra
que se expone la información necesaria para saber <em>qué</em> hace la
abstracción y oculta los detalles necesarios para saber <em>cómo</em> lo
hace.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.1.2.0.13">

<ul>
<li><p><strong>Generalización</strong>: Es el proceso de identificar un
patrón común entre varios casos particulares y crear un modelo más
general que los abarque a todos.</p></li>
<li><p><strong>Parametrización</strong>: Es el proceso de definir un
elemento que representa un caso general utilizando <em>parámetros</em>
que permiten obtener los casos particulares del caso general sin tener
que reescribirlo, ligando valores concretos a los parámetros.</p></li>
<li><p><strong>Parámetro</strong>: Es una parte que cambia en cada caso
particular de un patrón común.</p></li>
</ul>
</section>



<section id="pureza" class="title-slide slide level2" data-number="3.2">
<h2 data-number="3.2"><span class="header-section-number">3.2</span>
Pureza</h2>
<ul>
<li><p>Si una expresión lambda no contiene identificadores libres, el
valor que obtendremos al aplicarla a unos argumentos dependerá
únicamente del valor que tengan esos argumentos (no dependerá de nada
que sea «<em>exterior</em>» a la expresión lambda).</p></li>
<li><p>En cambio, si el cuerpo de una expresión lambda contiene
identificadores libres, el valor que obtendremos al aplicarla a unos
argumentos no sólo dependerá del valor de los argumentos, sino también
de los valores a los que estén ligados esos identificadores libres en el
momento de evaluar la aplicación de la expresión lambda.</p></li>
<li><p>Es el caso del siguiente ejemplo, donde tenemos una expresión
lambda que contiene un identificador libre (<code
class="sourceCode python">z</code>) y, por tanto, cuando la aplicamos a
los argumentos <code
class="sourceCode python"><span class="dv">4</span></code> y <code
class="sourceCode python"><span class="dv">3</span></code> obtenemos un
valor que depende no sólo de los valores de <code
class="sourceCode python">x</code> e <code
class="sourceCode python">y</code> sino también del valor de <code
class="sourceCode python">z</code> en el entorno:</p>
<div class="sourceCode" id="cb51"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> prueba <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y <span class="op">+</span> z</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> z <span class="op">=</span> <span class="dv">9</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> prueba(<span class="dv">4</span>, <span class="dv">3</span>)</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a><span class="dv">16</span></span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.0.0.1">

<ul>
<li><p>En este otro ejemplo, tenemos una expresión lambda que calcula la
suma de tres números a partir de otra expresión lambda que calcula la
suma de dos números:</p>
<div class="sourceCode" id="cb52"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>suma <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>suma3 <span class="op">=</span> <span class="kw">lambda</span> x, y, z: suma(x, y) <span class="op">+</span> z</span></code></pre></div>
<p>En este caso, hay un identificador (<code
class="sourceCode python">suma</code>) que no aparece en la lista de
parámetros de la expresión lambda ligada a <code
class="sourceCode python">suma3</code>.</p>
<p>En consecuencia, el valor de dicha expresión lambda dependerá de lo
que valga <code class="sourceCode python">suma</code> en el entorno
actual.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.0.0.2">

<ul>
<li><p>Se dice que una expresión lambda es <strong>pura</strong> si,
siempre que la apliquemos a unos argumentos, el valor obtenido va a
depender únicamente del valor de esos argumentos o, lo que es lo mismo,
del valor de sus parámetros en la llamada.</p></li>
<li><p>Podemos decir que hay distintos <strong>grados de
pureza</strong>:</p>
<ul>
<li><p>Una expresión lambda en cuyo cuerpo no hay ningún identificador
libre es <strong>más pura</strong> que otra que contiene identificadores
libres.</p></li>
<li><p>Una expresión lambda cuyos <strong>identificadores
libres</strong> representan <strong>funciones</strong> que se usan en el
cuerpo de la expresión lambda, es <strong>más pura</strong> que otra
cuyos identificadores libres representan cualquier otro tipo de
valor.</p></li>
</ul>
<p>En el ejemplo anterior, tenemos que la expresión lambda de <code
class="sourceCode python">suma3</code>, sin ser <em>totalmente
pura</em>, a efectos prácticos se la puede considerar
<strong>pura</strong>, ya que su único identificador libre (<code
class="sourceCode python">suma</code>) se usa como una
<strong>función</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.2.0.0.3">

<ul>
<li><p>Por ejemplo, las siguientes expresiones lambda están ordenadas de
mayor a menor pureza, siendo la primera totalmente
<strong>pura</strong>:</p>
<div class="sourceCode" id="cb53"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="co"># producto es una expresión lambda totalmente pura:</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>producto <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">*</span> y</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="co"># cuadrado es casi pura; a efectos prácticos se la puede</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a><span class="co"># considerar pura ya que sus identificadores libres (en este</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a><span class="co"># caso, sólo una: producto) son funciones:</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>cuadrado <span class="op">=</span> <span class="kw">lambda</span> x: producto(x, x)</span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a><span class="co"># suma es impura, porque su identificador libre (z) no es una función:</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>suma <span class="op">=</span> <span class="kw">lambda</span> x, y: x <span class="op">+</span> y <span class="op">+</span> z</span></code></pre></div></li>
<li><p><strong>La pureza de una función es un rasgo deseado y que hay
que tratar de alcanzar siempre que sea posible</strong>, ya que facilita
el desarrollo y mantenimiento de los programas, además de simplificar el
razonamiento sobre los mismos, permitiendo aplicar directamente nuestro
modelo de sustitución.</p></li>
<li><p>Es más incómodo trabajar con <code
class="sourceCode python">suma</code> porque hay que <em>recordar</em>
que depende de un valor que está <em>fuera</em> de la expresión lambda,
cosa que no resulta evidente a no ser que mires en el cuerpo de la
expresión lambda.</p></li>
</ul>
</section>

<section id="especificaciones-de-funciones"
class="title-slide slide level2" data-number="3.3">
<h2 data-number="3.3"><span class="header-section-number">3.3</span>
Especificaciones de funciones</h2>
<ul>
<li><p>La <strong>especificación de una <em>función</em></strong> es la
descripción de <strong>qué</strong> hace la función sin entrar a
detallar <strong>cómo</strong> lo hace.</p></li>
<li><p>La <strong>implementación de una <em>función</em></strong> es la
descripción de <strong>cómo</strong> hace lo que hace, es decir, los
detalles de su algoritmo interno.</p></li>
<li><p><strong>Para poder usar una función, un programador no debe
necesitar saber cómo está implementada</strong>.</p></li>
<li><p>Eso es lo que ocurre, por ejemplo, con las funciones predefinidas
del lenguaje (como <code
class="sourceCode python"><span class="bu">max</span></code>, <code
class="sourceCode python"><span class="bu">abs</span></code> o <code
class="sourceCode python"><span class="bu">len</span></code>): sabemos
<em>qué</em> hacen pero no necesitamos saber <em>cómo</em> lo
hacen.</p></li>
<li><p>Incluso puede que el usuario de una función no sea el mismo que
la ha escrito, sino que la puede haber recibido de otro programador como
una «<strong>caja negra</strong>», que tiene unas entradas y una salida
pero no se sabe cómo funciona por dentro.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.0.0.1">

<ul>
<li><p>Para poder <strong>usar una abstracción funcional</strong>
<em>nos basta</em> con conocer su <em>especificación</em>, porque es la
descripción de qué hace esa función.</p></li>
<li><p>Igualmente, para poder <strong>implementar una abstracción
funcional</strong> <em>necesitamos</em> conocer su
<em>especificación</em>, ya que necesitamos saber <em>qué tiene que
hacer</em> la función antes de diseñar <em>cómo va a
hacerlo</em>.</p></li>
<li><p>La especificación de una abstracción funcional describe tres
características fundamentales de dicha función:</p>
<ul>
<li><p>El <strong>dominio</strong>: el conjunto de datos de entrada
válidos.</p></li>
<li><p>El <strong>rango</strong> o <strong>codominio</strong>: el
conjunto de posibles valores que devuelve.</p></li>
<li><p>El <strong>propósito</strong>: qué hace la función, es decir, la
relación entre su entrada y su salida.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.0.0.2">

<ul>
<li><p>Hasta ahora, al especificar <strong>programas</strong>, hemos
llamado «<strong>entrada</strong>» al dominio, y hemos agrupado el rango
y el propósito en una sola propiedad que llamamos
«<strong>salida</strong>».</p></li>
<li><p>Por ejemplo, cualquier función <code
class="sourceCode python">cuadrado</code> que usemos para implementar
<code class="sourceCode python">area</code> debe satisfacer esta
especificación:</p>
<p><span class="math display">\begin{cases}
  \text{\textbf{Entrada}}: n \in \mathbb{R} \\
  \texttt{cuadrado} \\
  \text{\textbf{Salida}}: n^2
\end{cases}</span></p></li>
<li><p>La especificación <strong>no concreta cómo</strong> se debe
llevar a cabo el propósito. Esos son <strong>detalles de
implementación</strong> que se abstraen a este nivel.</p></li>
<li><p>Este esquema es el que hemos usado hasta ahora para especificar
programas, y se podría seguir usando para especificar funciones, ya que
éstas son consideradas <em>subprogramas</em> (programas que forman parte
de otros programas más grandes).</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.0.0.3">

<ul>
<li><p>Pero para especificar funciones resulta más adecuado usar el
siguiente esquema, al que llamaremos <strong>especificación
funcional</strong>:</p>
<p><span class="math display">\left\{\begin{array}{ll}
  \text{\textbf{Pre}}: &amp; \texttt{True} \\[0.5em]
&amp; \texttt{cuadrado(\(n\):\,float)\;-&gt;\;float} \\[0.5em]
\text{\textbf{Post}}: &amp; \texttt{cuadrado(\(n\))} = n^2
\end{array}\right.</span></p></li>
<li><p>«<strong>Pre</strong>» representa la
<strong>precondición</strong>: la propiedad que debe cumplirse justo
<em>en el momento</em> de llamar a la función.</p></li>
<li><p>«<strong>Post</strong>» representa la
<strong>postcondición</strong>: la propiedad que debe cumplirse justo
<em>después</em> de que la función haya terminado de
ejecutarse.</p></li>
<li><p>Lo que hay en medio es la <strong>signatura</strong>: el nombre
de la función, el nombre y tipo de sus parámetros y el tipo del valor de
retorno.</p></li>
<li><p>La especificación se lee así: «<strong><em>Si se llama a la
función respetando su signatura y cumpliendo su precondición, la llamada
termina cumpliendo su postcondición</em></strong>».</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.0.0.4">

<ul>
<li><p>En este caso, la <strong>precondición</strong> es <code
class="sourceCode python"><span class="va">True</span></code>, que
equivale a decir que cualquier condición de entrada es buena para usar
la función.</p></li>
<li><p>Dicho de otra forma: no hace falta que se dé ninguna condición
especial para usar la función. Siempre que la llamada respete la
signatura de la función, el parámetro <span class="math inline">n</span>
puede tomar cualquier valor de tipo <code
class="sourceCode python"><span class="bu">float</span></code> y no hay
ninguna restricción adicional.</p></li>
<li><p>Por otro lado, la <strong>postcondición</strong> dice que al
llamar a la función <code class="sourceCode python">cuadrado</code> con
el argumento <span class="math inline">n</span> se debe devolver <span
class="math inline">n^2</span>.</p></li>
<li><p>Tanto la precondición como la postcondición son
<strong>predicados</strong>, es decir, expresiones lógicas que se
escriben usando el lenguaje de las matemáticas y la lógica.</p></li>
<li><p>La <strong>signatura</strong> se escribe usando la sintaxis del
lenguaje de programación que se vaya a usar para implementar la función
(Python, en este caso).</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.0.0.5">

<ul>
<li><p>Recordemos la diferencia entre:</p>
<ul>
<li><p><strong>Dominio</strong> y <strong>conjunto origen</strong> de
una función.</p></li>
<li><p><strong>Rango</strong> (o <strong>codominio</strong>) y
<strong>conjunto imagen</strong> de una función.</p></li>
</ul></li>
<li><p>¿Cómo recoge la especificación esas cuatro características de la
función?</p>
<ul>
<li><p>La <strong>signatura</strong> expresa el <strong>conjunto
origen</strong> y el <strong>conjunto imagen</strong> de la
función.</p></li>
<li><p>El <strong>dominio</strong> viene determinado por los valores del
conjunto origen que cumplen la <strong>precondición</strong>.</p></li>
<li><p>El <strong>codominio</strong> viene determinado por los valores
del conjunto imagen que cumplen la
<strong>postcondición</strong>.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.0.0.6">

<ul>
<li><p>En el caso de la función <code
class="sourceCode python">cuadrado</code> tenemos que:</p>
<ul>
<li><p>El conjunto origen es <code
class="sourceCode python"><span class="bu">float</span></code>, ya que
su parámetro <span class="math inline">n</span> está declarado de tipo
<code class="sourceCode python"><span class="bu">float</span></code> en
la signatura de la función.</p>
<p>Por tanto, los datos de entrada a la función deberán pertenecer al
tipo <code
class="sourceCode python"><span class="bu">float</span></code>.</p></li>
<li><p>El dominio coincide con el conjunto origen, ya que su
precondición es <code
class="sourceCode python"><span class="va">True</span></code>. Eso
quiere decir que cualquier dato de entrada es válido siempre que
pertenezca al dominio (en este caso, el tipo <code
class="sourceCode python"><span class="bu">float</span></code>).</p></li>
<li><p>El conjunto imagen también es <code
class="sourceCode python"><span class="bu">float</span></code>, ya que
así está declarado el tipo de retorno de la función.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.0.0.7">

<ul>
<li><p>Las pre y postcondiciones no es necesario escribirlas de una
manera <strong>formal y rigurosa</strong>, usando el lenguaje de las
Matemáticas o la Lógica.</p></li>
<li><p>Si la especificación se escribe en <em>lenguaje natural</em> y se
entiende bien, completamente y sin ambigüedades, no hay
problema.</p></li>
<li><p>El motivo de usar un lenguaje formal es que, normalmente, resulta
<strong>mucho más conciso y preciso que el lenguaje
natural</strong>.</p></li>
<li><p>El lenguaje natural suele ser:</p>
<ul>
<li><p><strong>Más prolijo</strong>: necesita más palabras para decir lo
mismo que diríamos matemáticamente usando menos caracteres.</p></li>
<li><p><strong>Más ambiguo</strong>: lo que se dice en lenguaje natural
se puede interpretar de distintas formas.</p></li>
<li><p><strong>Menos completo</strong>: quedan flecos y situaciones
especiales que no se tienen en cuenta.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.0.0.8">

<ul>
<li><p>En este otro ejemplo, más completo, se especifica una función
llamada <code class="sourceCode python">cuenta</code>:</p>
<p><span class="math display">\left\{\begin{array}{ll}
  \text{\textbf{Pre}}: &amp; car \mathrel{\char`≠}
\text{\texttt{&quot;&quot;}} \land \texttt{len(}car\texttt{)} = 1
\\[0.5em]
&amp; \texttt{cuenta(\(cadena\):\,str,\;\(car\):\,str)\;-&gt;\;int}
\\[0.5em]
\text{\textbf{Post}}: &amp; \texttt{cuenta(\(cadena\),\;\(car\))} \geq
0\ \land\\[0.1em]
&amp; \texttt{cuenta(\(cadena\),\;\(car\))} =
cadena\texttt{.count(\(car\))}
\end{array}\right.</span></p></li>
<li><p>Con esta especificación, estamos diciendo que <code
class="sourceCode python">cuenta</code> es una función que recibe una
cadena y un carácter (otra cadena con un único carácter
dentro).</p></li>
<li><p>Ahora bien: esa cadena y ese carácter no pueden ser cualesquiera,
sino que tienen que cumplir la <em>precondición</em>.</p></li>
<li><p>Eso significa, entre otras cosas, que aquí <strong>el
<em>dominio</em> y el <em>conjunto origen</em> de la función no
coinciden</strong> (no todos los valores pertenecientes al conjunto
origen sirven como datos de entrada válidos para la función).</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.0.0.9">

<ul>
<li><p>En esta especificación, <code
class="sourceCode python">count</code> se usa como un <strong>método
auxiliar</strong>.</p>
<p>Las <em>operaciones auxiliares</em> se puede usar en una
especificación siempre que estén perfectamente especificadas, aunque no
estén implementadas.</p></li>
<li><p>En este caso, se usa en la <em>postcondición</em> para decir que
la función <code class="sourceCode python">cuenta</code>, la que se está
especificando, debe devolver el mismo resultado que devuelve el método
<code class="sourceCode python">count</code> (el cual ya conocemos
perfectamente y sabemos qué hace, puesto que es un método que ya existe
en Python).</p></li>
<li><p>Es decir: la especificación anterior describe con total precisión
que la función <code class="sourceCode python">cuenta</code>
<strong>cuenta el número de veces que el carácter <span
class="math inline">\underline{\textbf{\textit{car}}}</span> aparece en
la cadena <span
class="math inline">\underline{\textbf{\textit{cadena}}}</span></strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="3.3.0.0.10">

<ul>
<li><p>En realidad, las condiciones de la especificación anterior se
podrían simplificar aprovechando las propiedades de las expresiones
lógicas, quedando así:</p>
<p><span class="math display">\left\{\begin{array}{ll}
  \text{\textbf{Pre}}: &amp; \texttt{len(\(car\))} = 1 \\[0.5em]
&amp; \texttt{cuenta(\(cadena\):\,str,\;\(car\):\,str)\;-&gt;\;int}
\\[0.5em]
\text{\textbf{Post}}: &amp; \texttt{cuenta(\(cadena\),\;\(car\))} =
cadena\texttt{.count(\(car\))}
\end{array}\right.</span></p></li>
</ul>
</section>
<section id="ejercicio" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejercicio</h5>
<ol class="example" type="1">
<li>¿Por qué?</li>
</ol>
</section>
<section class="slide level5" data-number="3.3.0.0.11">

<ul>
<li><p>Finalmente, podríamos escribir la misma especificación en
lenguaje natural:</p>
<p><span class="math display">\left\{\begin{array}{ll}
  \text{\textbf{Pre}}: &amp; car \text{ debe ser un único carácter}
\\[0.5em]
&amp; \texttt{cuenta(\(cadena\):\,str,\;\(car\):\,str)\;-&gt;\;int}
\\[0.5em]
\text{\textbf{Post}}: &amp; \texttt{cuenta(\(cadena\),\;\(car\))} \text{
devuelve el número de veces}\\[0.1em]
&amp; \text{que aparece el carácter } car \text{ en la cadena }
cadena.\\[0.1em]
&amp; \text{Si } cadena \text{ es vacía o } car \text{ no aparece nunca
en la}\\[0.1em]
&amp; \text{cadena } cadena \text{, debe devolver } 0.
\end{array}\right.</span></p></li>
<li><p>Probablemente resulta más fácil de leer (sobre todo para los
novatos), pero también es más largo y prolijo.</p></li>
<li><p>Es como un contrato escrito por un abogado en lenguaje
jurídico.</p></li>
</ul>
<!--

- Un ejemplo mucho más avanzado para los curiosos:

  $$\begin{cases}
    \text{\textbf{Pre}}: lista \mathrel{\char`≠} \texttt{[]} \\
    suma\ (lista: \texttt{List[}T\texttt{]}) \text{ -> } T \\
    \text{\textbf{Post}}: suma(lista) = sum(lista)
  \end{cases}$$

- $sum$ es una función auxiliar.

- `List[`$T$`]` es un tipo genérico que pertenece al módulo `typing` y que se
  puede utilizar para indicar el tipo de una lista cuyos elementos son todos
  del tipo $T$.

- Con esto estamos diciendo que `suma` es una función que recibe una lista no
  vacía de elementos de un determinado tipo y que devuelve un resultado de ese
  mismo tipo.

- Para más información, consultar:

  - [https://docs.python.org/3/library/typing.html](https://docs.python.org/3/library/typing.html)

  - [https://www.python.org/dev/peps/pep-0484/](https://www.python.org/dev/peps/pep-0484/)
-->
</section>
</section>
<section>
<section id="recursividad" class="title-slide slide level1"
data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span>
Recursividad</h1>

</section>
<section id="funciones-y-procesos" class="title-slide slide level2"
data-number="4.1">
<h2 data-number="4.1"><span class="header-section-number">4.1</span>
Funciones y procesos</h2>
<ul>
<li><p>Los <strong>procesos</strong> son entidades abstractas que
habitan los ordenadores.</p></li>
<li><p>Conforme van evolucionando, los procesos manipulan otras
entidades abstractas llamadas <strong>datos</strong>.</p></li>
<li><p>La evolución de un proceso está dirigida por un patrón de reglas
llamado <strong>programa</strong>.</p></li>
<li><p>Los programadores crean programas para <strong>dirigir</strong> a
los procesos.</p></li>
<li><p>Es como decir que los programadores son magos que invocan a los
espíritus del ordenador (los procesos) con sus conjuros (los programas)
escritos en un lenguaje mágico (el lenguaje de programación).</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.1.0.0.1">

<ul>
<li><p>Una <strong>función</strong> describe la <em>evolución local</em>
de un <strong>proceso</strong>, es decir, cómo se debe comportar el
proceso durante la ejecución de la función.</p></li>
<li><p>En cada paso de la ejecución se calcula el <em>siguiente
estado</em> del proceso basándonos en el estado actual y en las reglas
definidas por la función.</p></li>
<li><p>Nos gustaría ser capaces de visualizar y de realizar afirmaciones
sobre el comportamiento global del proceso cuya evolución local está
definida por la función.</p></li>
<li><p>Esto, en general, es muy difícil, pero al menos vamos a describir
algunos de los modelos típicos de evolución de los procesos.</p></li>
</ul>
</section>
<section id="funciones-ad-hoc" class="title-slide slide level3"
data-number="4.1.1">
<h3 data-number="4.1.1"><span class="header-section-number">4.1.1</span>
Funciones <em>ad-hoc</em></h3>
<ul>
<li><p>Supongamos que queremos diseñar una función llamada <code
class="sourceCode python">permutas</code> que reciba un número entero
<span class="math inline">n</span> y que calcule cuántas permutaciones
distintas podemos hacer con <span class="math inline">n</span>
elementos.</p></li>
<li><p>Por ejemplo: si tenemos 3 elementos (digamos, <em>A</em>,
<em>B</em> y <em>C</em>), podemos formar con ellos las siguientes
permutaciones:</p>
<p><span class="math display">ABC, ACB, BAC, BCA, CAB, CBA</span></p>
<p>y, por tanto, con 3 elementos podemos formar 6 permutaciones
distintas. En consecuencia, <code
class="sourceCode python">permutas(<span class="dv">3</span>)</code>
debe devolver <code
class="sourceCode python"><span class="dv">6</span></code>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.1.1.0.1">

<ul>
<li><p>La implementación de esa función deberá satisfacer la siguiente
especificación:</p>
<p><span class="math display">\left\{\begin{array}{ll}
  \text{\textbf{Pre}}: &amp; n \geq 0 \\[0.5em]
&amp; \texttt{permutas(\(n\):\,int)\;-&gt;\;int} \\[0.5em]
\text{\textbf{Post}}: &amp; \texttt{permutas(\(n\))} = \text{el número
de permutaciones que}\\[0.1em]
&amp; \text{podemos formar con \(n\) elementos}
\end{array}\right.</span></p></li>
</ul>
</section>
<section class="slide level5" data-number="4.1.1.0.2">

<ul>
<li><p>Un programador con poca idea de programación (o muy listillo) se
podría plantear una implementación parecida a la siguiente:</p>
<div class="sourceCode" id="cb54"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>permutas <span class="op">=</span> <span class="kw">lambda</span> n: <span class="dv">1</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">1</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span> <span class="cf">else</span> <span class="dv">2</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">2</span> <span class="cf">else</span> ...</span></code></pre></div>
<p>que se puede escribir mejor usando la barra invertida
(<code>\</code>) para poder separar una instrucción en varias
líneas:</p>
<div class="sourceCode" id="cb55"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>permutas <span class="op">=</span> <span class="kw">lambda</span> n: <span class="dv">1</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="op">\</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>                     <span class="dv">1</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span> <span class="cf">else</span> <span class="op">\</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>                     <span class="dv">2</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">2</span> <span class="cf">else</span> <span class="op">\</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>                     <span class="dv">6</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">3</span> <span class="cf">else</span> <span class="op">\</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>                     <span class="dv">24</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">4</span> <span class="cf">else</span> <span class="op">\</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>                     ...                    <span class="co"># sigue y sigue</span></span></code></pre></div></li>
<li><p>Pero este algoritmo en realidad es <em>tramposo</em>, porque no
calcula nada, sino que se limita a asociar el dato de entrada con el de
salida, que se ha tenido que calcular previamente usando otro
procedimiento.</p></li>
<li><p>Este tipo de algoritmos se denominan <strong>algoritmos
<em>ad-hoc</em></strong>, y las funciones que los implementan se
denominan <strong>funciones <em>ad-hoc</em></strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.1.1.0.3">

<ul>
<li><p>Las funciones <em>ad-hoc</em> <strong>no son
convenientes</strong> porque:</p>
<ul>
<li><p>Realmente son <strong>tramposos</strong> (no calculan
nada).</p></li>
<li><p><strong>No son útiles</strong>, porque al final el cálculo se
tiene que hacer con otra cosa.</p></li>
<li><p>Generalmente resulta <strong>imposible</strong> que una función
de este tipo abarque todos los posibles datos de entrada, ya que, en
principio, puede haber <strong>infinitos</strong> y, por tanto, su
código fuente también tendría que ser infinito.</p></li>
</ul></li>
</ul>
<div class="caja centered">
<p><strong>Usar algoritmos y funciones <em>ad-hoc</em> se penaliza en
esta asignatura.</strong></p>
</div>
</section>


<section id="funciones-recursivas" class="title-slide slide level2"
data-number="4.2">
<h2 data-number="4.2"><span class="header-section-number">4.2</span>
Funciones recursivas</h2>

</section>
<section id="definición" class="title-slide slide level3"
data-number="4.2.1">
<h3 data-number="4.2.1"><span class="header-section-number">4.2.1</span>
Definición</h3>
<ul>
<li><p>Una <strong>función recursiva</strong> es aquella que se define
en términos de sí misma.</p></li>
<li><p>Eso quiere decir que, durante la ejecución de una llamada a la
función, se ejecuta otra llamada a la misma función, es decir, que la
función se llama a sí misma directa o indirectamente.</p></li>
<li><p>La forma más sencilla y habitual de función recursiva es aquella
en la que <strong>la propia definición de la función contiene una o
varias llamadas a ella misma</strong>. En tal caso, decimos que la
función se llama a sí misma <em>directamente</em> o que hay una
<strong>recursividad directa</strong>.</p>
<p>Ese es el tipo de recursividad que vamos a estudiar.</p></li>
<li><p>Las definiciones recursivas son el mecanismo básico para ejecutar
<strong>repeticiones de instrucciones</strong> en un lenguaje de
programación funcional.</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.1.0.1">

<ul>
<li><p>Por ejemplo: <span class="math display">f(n) = n + f(n +
1)</span></p></li>
<li><p>Esta función matemática es <em>recursiva</em> porque aparece ella
misma en su propia definición.</p>
<p>Para calcular el valor de <span class="math inline">f(n)</span>
tenemos que volver a utilizar la propia función <span
class="math inline">f</span>.</p></li>
<li><p>Por ejemplo: <span class="math display">f(1) = 1 + f(2) = 1 + 2 +
f(3) = 1 + 2 + 3 + f(4) = \ldots</span></p></li>
<li><p>Cada vez que una función se llama a sí misma decimos que se
realiza una <strong>llamada recursiva</strong> o <strong>paso
recursivo</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.1.0.2">

<div class="centered">
<p><img data-src="images/pintura-recursiva.jpg" class="plain"
style="width:100.0%" /></p>
</div>
</section>
<section id="ejercicio-1" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejercicio</h5>
<ol start="2" class="example" type="1">
<li>Desde el principio del curso ya hemos estado trabajando con
estructuras que pueden tener una definición recursiva. ¿Cuáles son?</li>
</ol>
</section>

<section id="casos-base-y-casos-recursivos"
class="title-slide slide level3" data-number="4.2.2">
<h3 data-number="4.2.2"><span class="header-section-number">4.2.2</span>
Casos base y casos recursivos</h3>
<ul>
<li><p>Resulta importante que una definición recursiva se detenga alguna
vez y proporcione un resultado, ya que si no, no sería útil (tendríamos
lo que se llama una <strong>recursión infinita</strong>).</p></li>
<li><p>Por tanto, en algún momento, la recursión debe alcanzar un punto
en el que la función no se llame a sí misma y se detenga.</p></li>
<li><p>Para ello, es necesario que la función, en cada paso recursivo,
se vaya acercando cada vez más a ese punto.</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.2.0.1">

<ul>
<li><p>Ese punto en el que la función recursiva <strong>no se llama a sí
misma</strong>, se denomina <strong>caso base</strong>, y puede haber
más de uno.</p></li>
<li><p>Los casos base, por tanto, determinan bajo qué condiciones la
función no se llamará a sí misma, o dicho de otra forma, con qué valores
de sus argumentos la función devolverá directamente un valor y no
provocará una nueva llamada recursiva.</p></li>
<li><p>Los demás casos, que sí provocan llamadas recursivas, se
denominan <strong>casos recursivos</strong>.</p></li>
</ul>
</section>

<section id="el-factorial" class="title-slide slide level3"
data-number="4.2.3">
<h3 data-number="4.2.3"><span class="header-section-number">4.2.3</span>
El factorial</h3>
<ul>
<li><p>El ejemplo más típico de función recursiva es el
<strong>factorial</strong>.</p></li>
<li><p>El factorial de un número natural <span
class="math inline">n</span> se representa por <span
class="math inline">n!</span> y se define como el producto de todos los
números desde 1 hasta <span class="math inline">n</span>: <span
class="math display">n! =
n\cdot(n-1)\cdot(n-2)\cdot\cdots\cdot1</span></p>
<p>Por ejemplo: <span class="math display">6! =
6\cdot5\cdot4\cdot3\cdot2\cdot1 = 720</span></p></li>
<li><p>Pero para calcular <span class="math inline">6!</span> también se
puede calcular <span class="math inline">5!</span> y después multiplicar
el resultado por 6, ya que: <span class="math display">6! =
6\cdot\overbrace{5\cdot4\cdot3\cdot2\cdot1}^{5!}</span> <span
class="math display">6! = 6\cdot5!</span></p></li>
<li><p>Por tanto, el factorial se puede definir de forma
<strong>recursiva</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.3.0.1">

<ul>
<li><p>Tenemos el <strong>caso recursivo</strong>, pero necesitamos al
menos un <strong>caso base</strong> para evitar que la recursión se haga
<em>infinita</em>.</p></li>
<li><p>El caso base del factorial se obtiene sabiendo que el factorial
de 0 es directamente 1 (no hay que llamar al factorial recursivamente):
<span class="math display">0! = 1</span></p></li>
<li><p>Combinando ambos casos tendríamos:</p>
<p><span class="math display">n! = \begin{cases}
         1 &amp; \text{si } n = 0 \text{\quad(caso base)} \\
         n\cdot(n-1)! &amp; \text{si } n &gt; 0 \text{\quad(caso
recursivo)}
       \end{cases}</span></p></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.3.0.2">

<ul>
<li><p>La <strong>especificación</strong> de una función que calcule el
factorial de un número sería:</p>
<p><span class="math display">\left\{\begin{array}{ll}
  \text{\textbf{Pre}}: &amp; n \geq 0 \\[0.5em]
&amp; \texttt{factorial(\(n\):\,int)\;-&gt;\;int} \\[0.5em]
\text{\textbf{Post}}: &amp; \texttt{factorial(\(n\))} = n!
\end{array}\right.</span></p></li>
<li><p>Y su <strong>implementación</strong> en Python podría ser la
siguiente:</p>
<div class="sourceCode" id="cb56"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>factorial <span class="op">=</span> <span class="kw">lambda</span> n: <span class="dv">1</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> n <span class="op">*</span> factorial(n <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div>
<p>que sería prácticamente una traducción literal de la definición
recursiva de factorial que acabamos de obtener.</p></li>
</ul>
</section>

<section id="diseño-de-funciones-recursivas"
class="title-slide slide level3" data-number="4.2.4">
<h3 data-number="4.2.4"><span class="header-section-number">4.2.4</span>
Diseño de funciones recursivas</h3>
<ul>
<li><p>El diseño de funciones recursivas se basa en:</p>
<ol>
<li><p>Identificación de casos base</p></li>
<li><p>Descomposición (reducción) del problema</p></li>
<li><p>Pensamiento optimista</p></li>
</ol></li>
</ul>
</section>
<section id="identificación-de-casos-base"
class="title-slide slide level4" data-number="4.2.4.1">
<h4 data-number="4.2.4.1"><span
class="header-section-number">4.2.4.1</span> Identificación de casos
base</h4>
<ul>
<li><p>Debemos identificar los ejemplares para los cuales hay una
solución directa que no necesita recursividad.</p></li>
<li><p>Esos ejemplares representarán los <em>casos base</em> de la
función recursiva, y por eso los denominamos <em>ejemplares
básicos</em>.</p></li>
<li><p>Por ejemplo:</p>
<ul>
<li><p>Supongamos que queremos diseñar una función (llamada <span
class="math inline">fact</span>, por ejemplo) que calcule el factorial
de un número.</p>
<p>Es decir: <span class="math inline">fact(n)</span> debe devolver el
factorial de <span class="math inline">n</span>.</p></li>
<li><p>Sabemos que <span class="math inline">0! = 1</span>, por lo que
nuestra función podría devolver directamente <span
class="math inline">1</span> cuando se le pida calcular el factorial de
<span class="math inline">0</span>.</p></li>
<li><p>Por tanto, el caso base del factorial es el cálculo del factorial
de 0: <span class="math display">fact(0) = 1</span></p></li>
</ul></li>
</ul>
</section>

<section id="descomposición-reducción-del-problema"
class="title-slide slide level4" data-number="4.2.4.2">
<h4 data-number="4.2.4.2"><span
class="header-section-number">4.2.4.2</span> Descomposición (reducción)
del problema</h4>
<ul>
<li><p>Reducimos el problema de forma que así tendremos un ejemplar
<em>más pequeño</em> del problema.</p></li>
<li><p>Un ejemplar más pequeño es aquel que está <strong>más cerca del
caso base</strong>.</p></li>
<li><p>De esta forma, cada ejemplar se irá acercando más y más al caso
base hasta que finalmente se alcanzará dicho caso base y eso detendrá la
recursión.</p></li>
<li><p>Es importante comprobar que eso se cumple, es decir, que la
reducción que le realizamos al problema produce ejemplares que están más
cerca del caso base, porque de lo contrario se produciría una
<em>recursión infinita</em>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.4.2.1">

<ul>
<li><p>En el ejemplo del factorial:</p>
<ul>
<li><p>El caso base es <span class="math inline">fact(0)</span>, es
decir, el caso en el que queremos calcular el factorial de 0, que ya
vimos que es directamente 1 (sin necesidad de llamadas
recursivas).</p></li>
<li><p>Si queremos resolver el problema de calcular, por ejemplo, el
factorial de 5, podríamos intentar reducir el problema a calcular el
factorial de 4, que es un número que está más cerca del caso base (que
es 0).</p></li>
<li><p>A su vez, para calcular el factorial de 4, reduciríamos el
problema a calcular el factorial de 3, y así sucesivamente.</p></li>
<li><p>De esta forma, podemos reducir el problema de calcular el
factorial de <span class="math inline">n</span> a calcular el factorial
de <span class="math inline">(n - 1)</span>, que es un número que está
más cerca del 0. Así, cada vez estaremos más cerca del caso base y, al
final, siempre lo acabaremos alcanzando.</p></li>
</ul></li>
</ul>
</section>

<section id="pensamiento-optimista" class="title-slide slide level4"
data-number="4.2.4.3">
<h4 data-number="4.2.4.3"><span
class="header-section-number">4.2.4.3</span> Pensamiento optimista</h4>
<ul>
<li><p>Consiste en suponer que la función deseada ya existe y que,
aunque no sabe resolver el ejemplar original del problema, sí que es
capaz de resolver ejemplares <em>más pequeños</em> de ese problema (este
paso se denomina <strong>hipótesis inductiva</strong> o
<strong>hipótesis de inducción</strong>).</p></li>
<li><p>Suponiendo que se cumple la <em>hipótesis inductiva</em>, y
aprovechando que ya contamos con un método para <em>reducir el ejemplar
a uno más pequeño</em>, ahora tratamos de encontrar un <em>patrón
común</em> de forma que resolver el ejemplar original implique usar el
mismo patrón en un ejemplar más pequeño.</p></li>
<li><p>Es decir:</p>
<ul>
<li><p>Al reducir el problema, obtenemos un ejemplar más pequeño del
mismo problema y, por tanto, podremos usar la función para poder
resolver ese ejemplar más pequeño (que sí sabe resolverlo, por hipótesis
inductiva).</p></li>
<li><p>A continuación, usamos dicha solución <em>parcial</em> para
tratar de obtener la solución para el ejemplar original del
problema.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.4.3.1">

<ul>
<li><p>En el ejemplo del factorial:</p>
<ul>
<li><p>Supongamos que queremos calcular, por ejemplo, el factorial de
6.</p></li>
<li><p>Aún no sabemos calcular el factorial de 6, pero suponemos (por
<em>hipótesis inductiva</em>) que sí sabemos calcular el factorial de
5.</p>
<p>En ese caso, ¿cómo puedo aprovechar que sé resolver el factorial de 5
para lograr calcular el factorial de 6?</p></li>
<li><p>Analizando el problema, observo que se cumple esta propiedad:
<span class="math display">6! =
6\cdot\overbrace{5\cdot4\cdot3\cdot2\cdot1}^{5!}=6\cdot 5!</span></p>
<p>Por tanto, he deducido un método para resolver el problema de
calcular el factorial de 6 a partir del factorial de 5: <em>para
calcular el factorial de 6 basta con calcular primero el factorial de 5
y luego multiplicar el resultado por 6</em>.</p>
<div class="caja">
<p>Dicho de otro modo: <em>si yo supiera</em> calcular el factorial de
5, me bastaría con multiplicarlo por 6 para obtener el factorial de
6.</p>
</div></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.4.3.2">

<ul>
<li><p>Generalizando para cualquier número, no sólo para el 6:</p>
<ul>
<li><p>Si queremos diseñar una función <span
class="math inline">fact(n)</span> que calcule el factorial de <span
class="math inline">n</span>, supondremos que esa función ya existe pero
que aún no sabe calcular el factorial de <span
class="math inline">n</span>, aunque <strong>sí sabe calcular el
factorial de <span class="math inline">\pmb{(n -
1)}</span></strong>.</p>
<p>Tenemos que creer en que es así y actuar como si fuera así, aunque
ahora mismo no sea verdad. <em>Ésta es nuestra <strong>hipótesis
inductiva</strong></em>.</p></li>
<li><p>Por otra parte, sabemos que: <span class="math display">n! =
n\cdot\overbrace{(n-1)\cdot(n-2)\cdot(n-3)\cdot2\cdot1}^{(n-1)!}=n\cdot(n-1)!</span></p>
<p>Por tanto, si sabemos calcular el factorial de <span
class="math inline">(n - 1)</span> llamando a <span
class="math inline">fact(n
- 1)</span>, para calcular <span class="math inline">fact(n)</span> sólo
necesito multiplicar <span class="math inline">n</span> por el resultado
de <span class="math inline">fact(n - 1)</span>.</p>
<div class="caja">
<p>Resumiendo: <strong><em>si yo supiera</em> calcular el factorial de
<span class="math inline">\pmb{(n - 1)}</span>, me bastaría con
multiplicarlo por <span class="math inline">\pmb{n}</span> para obtener
el factorial de <span class="math inline">\pmb{n}</span></strong>.</p>
</div></li>
<li><p>Así obtengo el caso recursivo de la función <em>fact</em>, que
sería: <span class="math display">fact(n) = n\cdot
fact(n-1)</span></p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.4.3.3">

<ul>
<li>Combinando todos los pasos, obtenemos la solución general:</li>
</ul>
<p><span class="math display">fact(n) = \begin{cases}
         1 &amp; \text{si } n = 0 \text{\quad(caso base)} \\
         n\cdot fact(n-1) &amp; \text{si } n &gt; 0 \text{\quad(caso
recursivo)}
       \end{cases}</span></p>
</section>


<section id="recursividad-lineal" class="title-slide slide level3"
data-number="4.2.5">
<h3 data-number="4.2.5"><span class="header-section-number">4.2.5</span>
Recursividad lineal</h3>
<ul>
<li><p>Una función tiene <strong>recursividad lineal</strong> si cada
llamada a la función recursiva genera, como mucho, otra llamada
recursiva a la misma función.</p></li>
<li><p>El factorial definido en el ejemplo anterior es un caso típico de
recursividad lineal ya que, cada vez que se llama al factorial se
genera, como mucho, otra llamada al factorial.</p></li>
<li><p>Eso se aprecia claramente observando que la definición del caso
recursivo de la función <span class="math inline">fact</span> contiene
una única llamada a la misma función <span
class="math inline">fact</span>:</p></li>
</ul>
<p><span class="math display">fact(n) = n\cdot fact(n-1)\quad \text{si }
n &gt; 0\quad \text{(caso recursivo)}</span></p>
</section>
<section id="procesos-recursivos-lineales"
class="title-slide slide level4" data-number="4.2.5.1">
<h4 data-number="4.2.5.1"><span
class="header-section-number">4.2.5.1</span> Procesos recursivos
lineales</h4>
<ul>
<li><p>La forma más directa y sencilla de definir una función que
calcule el factorial de un número a partir de su definición recursiva
podría ser la siguiente:</p>
<div class="sourceCode" id="cb57"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>factorial <span class="op">=</span> <span class="kw">lambda</span> n: <span class="dv">1</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> n <span class="op">*</span> factorial(n <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div></li>
<li><p>Utilizaremos el modelo de sustitución para observar el
funcionamiento de esta función al calcular <span
class="math inline">6!</span>:</p>
<div class="sourceCode" id="cb58"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>factorial(<span class="dv">6</span>)</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> factorial(<span class="dv">5</span>))</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> factorial(<span class="dv">4</span>)))</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> factorial(<span class="dv">3</span>))))</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">*</span> factorial(<span class="dv">2</span>)))))</span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">*</span> (<span class="dv">2</span> <span class="op">*</span> factorial(<span class="dv">1</span>))))))</span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">*</span> (<span class="dv">2</span> <span class="op">*</span> (<span class="dv">1</span> <span class="op">*</span> factorial(<span class="dv">0</span>)))))))</span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">*</span> (<span class="dv">2</span> <span class="op">*</span> (<span class="dv">1</span> <span class="op">*</span> <span class="dv">1</span>))))))</span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">*</span> (<span class="dv">2</span> <span class="op">*</span> <span class="dv">1</span>)))))</span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">*</span> <span class="dv">2</span>))))</span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> (<span class="dv">4</span> <span class="op">*</span> <span class="dv">6</span>)))</span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> (<span class="dv">5</span> <span class="op">*</span> <span class="dv">24</span>))</span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> (<span class="dv">6</span> <span class="op">*</span> <span class="dv">120</span>)</span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">720</span></span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.5.1.1">

<ul>
<li><p>Podemos observar un perfil de <strong>expansión</strong> seguido
de una <strong>contracción</strong>:</p>
<ul>
<li><p>La <strong>expansión</strong> ocurre conforme el proceso
construye una secuencia de operaciones a realizar
<em>posteriormente</em> (en este caso, una secuencia de
multiplicaciones).</p></li>
<li><p>La <strong>contracción</strong> se realiza conforme se van
ejecutando realmente las multiplicaciones.</p></li>
</ul></li>
<li><p>Llamaremos <strong>proceso recursivo</strong> a este tipo de
proceso caracterizado por una secuencia de <strong>operaciones
pendientes de completar</strong>.</p></li>
<li><p>Para poder ejecutar este proceso, el intérprete necesita
<strong>memorizar</strong>, en algún lugar, un registro de las
multiplicaciones que se han dejado para más adelante.</p></li>
<li><p>En el cálculo de <span class="math inline">n!</span>, la longitud
de la secuencia de operaciones pendientes (y, por tanto, la información
que necesita almacenar el intérprete), crece <em>linealmente</em> con
<span class="math inline">n</span>, al igual que el número de pasos de
reducción.</p>
<p>A este tipo de procesos lo llamaremos <strong>proceso recursivo
<em>lineal</em></strong>.</p></li>
</ul>
</section>

<section id="procesos-iterativos-lineales"
class="title-slide slide level4" data-number="4.2.5.2">
<h4 data-number="4.2.5.2"><span
class="header-section-number">4.2.5.2</span> Procesos iterativos
lineales</h4>
<ul>
<li><p>A continuación adoptaremos un enfoque diferente.</p></li>
<li><p>Podemos mantener un producto acumulado y un contador desde <span
class="math inline">n</span> hasta 1, de forma que el contador y el
producto cambien de un paso al siguiente según la siguiente regla:</p>
<p><span class="math display">\begin{array}{l}
    acumulador_{nuevo} = acumulador_{viejo} \cdot contador_{viejo}
\\[0.5em]
    contador_{nuevo} = contador_{viejo} - 1
  \end{array}</span></p></li>
<li><p>Su traducción a Python podría ser la siguiente, usando una
función auxiliar <code>fact_iter</code>:</p>
<div class="sourceCode" id="cb59"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>fact_iter <span class="op">=</span> <span class="kw">lambda</span> cont, acc: acc <span class="cf">if</span> cont <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="op">\</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>                              fact_iter(cont <span class="op">-</span> <span class="dv">1</span>, cont <span class="op">*</span> acc)</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>factorial <span class="op">=</span> <span class="kw">lambda</span> n: fact_iter(n, <span class="dv">1</span>)</span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.5.2.1">

<ul>
<li><p>Al igual que antes, usaremos el modelo de sustitución para
visualizar el proceso del cálculo de <span
class="math inline">6!</span>:</p>
<div class="sourceCode" id="cb60"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>factorial(<span class="dv">6</span>)</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> fact_iter(<span class="dv">6</span>, <span class="dv">1</span>)</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> fact_iter(<span class="dv">5</span>, <span class="dv">6</span>)</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> fact_iter(<span class="dv">4</span>, <span class="dv">30</span>)</span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> fact_iter(<span class="dv">3</span>, <span class="dv">120</span>)</span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> fact_iter(<span class="dv">2</span>, <span class="dv">360</span>)</span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> fact_iter(<span class="dv">1</span>, <span class="dv">720</span>)</span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> fact_iter(<span class="dv">0</span>, <span class="dv">720</span>)</span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a><span class="op">=</span> <span class="dv">720</span></span></code></pre></div></li>
<li><p>Este proceso no tiene expansiones ni contracciones ya que, en
cada instante, toda la información que se necesita almacenar es el valor
actual de los parámetros <code class="sourceCode python">cont</code> y
<code class="sourceCode python">acc</code>, por lo que el tamaño de la
memoria necesaria es constante.</p></li>
<li><p>A este tipo de procesos lo llamaremos <strong>proceso
iterativo</strong>.</p></li>
<li><p>El número de pasos necesarios para calcular <span
class="math inline">n!</span> usando esta función crece
<em>linealmente</em> con <span class="math inline">n</span>.</p>
<p>A este tipo de procesos lo llamaremos <strong>proceso iterativo
<em>lineal</em></strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.5.2.2">

<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 37%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">Tipo de proceso</th>
<th style="text-align: left;">Número de reducciones</th>
<th style="text-align: left;">Memoria necesaria</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Recursivo</td>
<td style="text-align: left;">Proporcional a <span
class="math inline">\underline{n}</span></td>
<td style="text-align: left;">Proporcional a <span
class="math inline">\underline{n}</span></td>
</tr>
<tr>
<td style="text-align: left;">Iterativo</td>
<td style="text-align: left;">Proporcional a <span
class="math inline">\underline{n}</span></td>
<td style="text-align: left;">Constante</td>
</tr>
</tbody>
</table>
<p><br>* * *<br></p>
<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 36%" />
<col style="width: 36%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">Tipo de proceso</th>
<th style="text-align: left;">Número de reducciones</th>
<th style="text-align: left;">Memoria necesaria</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Recursivo lineal</td>
<td style="text-align: left;">Linealmente<br />
proporcional a <span class="math inline">\underline{n}</span></td>
<td style="text-align: left;">Linealmente<br />
proporcional a <span class="math inline">\underline{n}</span></td>
</tr>
<tr>
<td style="text-align: left;">Iterativo lineal</td>
<td style="text-align: left;">Linealmente<br />
proporcional a <span class="math inline">\underline{n}</span></td>
<td style="text-align: left;">Constante</td>
</tr>
</tbody>
</table>
</section>
<section class="slide level5" data-number="4.2.5.2.3">

<ul>
<li><p>En general, un <strong>proceso iterativo</strong> es aquel que
está definido por una serie de <strong>coordenadas de estado</strong>
junto con una <strong>regla</strong> fija que describe cómo actualizar
dichas coordenadas conforme cambia el proceso de un estado al
siguiente.</p></li>
<li><p>La <strong>diferencia entre los procesos recursivo e
iterativo</strong> se puede describir de esta otra manera:</p>
<ul>
<li><p>En el <strong>proceso iterativo</strong>, los parámetros dan una
descripción completa del estado del proceso en cada instante.</p>
<p>Así, si parásemos el cálculo entre dos pasos, lo único que
necesitaríamos hacer para seguir con el cálculo es darle al intérprete
el valor de los dos parámetros.</p></li>
<li><p>En el <strong>proceso recursivo</strong>, el intérprete tiene que
mantener cierta información <em>oculta</em> que no está almacenada en
ningún parámetro y que indica qué operaciones ha realizado hasta ahora y
cuáles quedan pendientes por hacer.</p></li>
</ul></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.5.2.4">

<ul>
<li><p>No debe confundirse un <strong>proceso recursivo</strong> con una
<strong>función recursiva</strong>:</p>
<ul>
<li><p>Cuando hablamos de <em>función recursiva</em> nos referimos al
hecho de que la función se llama a sí misma (directa o
indirectamente).</p></li>
<li><p>Cuando hablamos de <em>proceso recursivo</em> nos referimos a la
forma en como se desenvuelve la ejecución de la función (con una
expansión más una contracción).</p></li>
</ul></li>
<li><p>Puede parecer extraño que digamos que una función recursiva (por
ejemplo, <code class="sourceCode python">fact_iter</code>) genera un
proceso iterativo.</p>
<p>Sin embargo, el proceso es realmente iterativo porque su estado está
definido completamente por dos parámetros, y para ejecutar el proceso
sólo se necesita almacenar el valor de esos dos parámetros.</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.5.2.5">

<ul>
<li><p>Aquí hemos visto un ejemplo donde se aprecia claramente que
<strong>una función sólo puede tener una especificación</strong> pero
<strong>puede tener varias implementaciones</strong> distintas.</p></li>
<li><p>Eso sí: todas las implementaciones de una función deben
satisfacer su especificación.</p></li>
<li><p>En este caso, las dos implementaciones son:</p>
<div class="sourceCode" id="cb61"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>factorial <span class="op">=</span> <span class="kw">lambda</span> n: <span class="dv">1</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> n <span class="op">*</span> factorial(n <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div>
<p>y</p>
<div class="sourceCode" id="cb62"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>fact_iter <span class="op">=</span> <span class="kw">lambda</span> cont, acc: acc <span class="cf">if</span> cont <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="op">\</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>                              fact_iter(cont <span class="op">-</span> <span class="dv">1</span>, cont <span class="op">*</span> acc)</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>factorial <span class="op">=</span> <span class="kw">lambda</span> n: fact_iter(n, <span class="dv">1</span>)</span></code></pre></div></li>
<li><p>Y aunque las dos satisfacen la misma especificación (y, por
tanto, calculan exactamente los mismos valores), lo hacen de una forma
muy diferente, generando incluso procesos de distinto tipo.</p></li>
</ul>
</section>


<section id="recursividad-múltiple" class="title-slide slide level3"
data-number="4.2.6">
<h3 data-number="4.2.6"><span class="header-section-number">4.2.6</span>
Recursividad múltiple</h3>
<ul>
<li><p>Una función tiene <strong>recursividad múltiple</strong> cuando,
durante la misma activación o llamada a la función, se puede generar más
de una llamada recursiva a la misma función.</p></li>
<li><p>El ejemplo clásico es la función que calcula los términos de la
<strong>sucesión de Fibonacci</strong>.</p></li>
<li><p>La sucesión comienza con los números 0 y 1, y a partir de éstos,
cada término es la suma de los dos anteriores:</p>
<p>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987,
1597, …</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.6.0.1">

<ul>
<li><p>Podemos definir una función recursiva que devuelva el <span
class="math inline">n</span>-ésimo término de la sucesión de
Fibonacci:</p>
<p><span class="math display">fib(n) = \begin{cases}
             0 &amp; \text{si } n = 0 \text{\quad (caso base)} \\
             1 &amp; \text{si } n = 1 \text{\quad (caso base)} \\
             fib(n - 1) + fib(n - 2) &amp; \text{si } n &gt; 1
\text{\quad (caso recursivo)}
           \end{cases}</span></p></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.6.0.2">

<ul>
<li><p>La especificación de una función que devuelva el <span
class="math inline">n</span>-ésimo término de la sucesión de Fibonacci
sería:</p>
<p><span class="math display">\left\{\begin{array}{ll}
  \text{\textbf{Pre}}: &amp; n \geq 0 \\[0.5em]
&amp; \texttt{fib(\(n\):\,int)\;-&gt;\;int} \\[0.5em]
\text{\textbf{Post}}: &amp; \texttt{fib(\(n\))} = \text{el \(n\)-ésimo
término de la sucesión de Fibonacci}
\end{array}\right.</span></p></li>
<li><p>Y su implementación en Python podría ser:</p>
<div class="sourceCode" id="cb63"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>fib <span class="op">=</span> <span class="kw">lambda</span> n: <span class="dv">0</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">1</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span> <span class="cf">else</span> fib(n <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> fib(n <span class="op">-</span> <span class="dv">2</span>)</span></code></pre></div>
<p>o bien, separando la definición en varias líneas:</p>
<div class="sourceCode" id="cb64"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>fib <span class="op">=</span> <span class="kw">lambda</span> n: <span class="dv">0</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="op">\</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>                <span class="dv">1</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span> <span class="cf">else</span> <span class="op">\</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>                fib(n <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> fib(n <span class="op">-</span> <span class="dv">2</span>)</span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.6.0.3">

<ul>
<li><p>Si vemos el perfil de ejecución de <code
class="sourceCode python">fib(<span class="dv">5</span>)</code>, vemos
que:</p>
<ul>
<li><p>Para calcular <code
class="sourceCode python">fib(<span class="dv">5</span>)</code>, antes
debemos calcular <code
class="sourceCode python">fib(<span class="dv">4</span>)</code> y <code
class="sourceCode python">fib(<span class="dv">3</span>)</code>.</p></li>
<li><p>Para calcular <code
class="sourceCode python">fib(<span class="dv">4</span>)</code>, antes
debemos calcular <code
class="sourceCode python">fib(<span class="dv">3</span>)</code> y <code
class="sourceCode python">fib(<span class="dv">2</span>)</code>.</p></li>
<li><p>Así sucesivamente hasta poner todo en función de <code
class="sourceCode python">fib(<span class="dv">0</span>)</code> y <code
class="sourceCode python">fib(<span class="dv">1</span>)</code>, que se
pueden calcular directamente (son los casos base).</p></li>
</ul></li>
<li><p>En general, el proceso resultante tiene forma de árbol.</p></li>
<li><p>Por eso decimos que las funciones con recursividad múltiple
generan <strong>procesos recursivos en árbol</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.6.0.4">

<div class="centered">
<p><img data-src="images/arbol-fibonacci.svg" class="plain"
style="width:80.0%" /></p>
</div>
</section>
<section class="slide level5" data-number="4.2.6.0.5">

<ul>
<li><p>La función anterior es un buen ejemplo de recursión en árbol,
pero desde luego es un método <em>horrible</em> para calcular los
números de Fibonacci, por la cantidad de <strong>operaciones
redundantes</strong> que efectúa.</p></li>
<li><p>Para tener una idea de lo malo que es, se puede observar que
<span class="math inline">fib(n)</span> crece exponencialmente en
función de <span class="math inline">n</span>.</p></li>
<li><p>Por lo tanto, el proceso necesita una cantidad de tiempo que
crece <strong>exponencialmente</strong> con <span
class="math inline">n</span>.</p></li>
<li><p>Por otro lado, el espacio necesario sólo crece
<strong>linealmente</strong> con <span class="math inline">n</span>,
porque en un cierto momento del cálculo sólo hay que memorizar los nodos
que hay por encima.</p></li>
<li><p>En general, en un proceso recursivo en árbol <strong>el tiempo de
ejecución crece con el <em>número de nodos</em> del árbol</strong>
mientras que <strong>el espacio necesario crece con la <em>altura
máxima</em> del árbol</strong>.</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.6.0.6">

<ul>
<li><p>Se puede construir un <strong>proceso iterativo</strong> para
calcular los números de Fibonacci.</p></li>
<li><p>La idea consiste en usar dos coordenadas de estado <em>a</em> y
<em>b</em> (con valores iniciales 0 y 1, respectivamente) y aplicar
repetidamente la siguiente transformación:</p>
<p><span class="math display">\begin{array}{l}
    a_{nuevo} = b_{viejo} \\[0.5em]
    b_{nuevo} = b_{viejo} + a_{viejo}
  \end{array}</span></p></li>
<li><p>Después de <span class="math inline">n</span> pasos, <em>a</em> y
<em>b</em> contendrán <span class="math inline">fib(n)</span> y <span
class="math inline">fib(n + 1)</span>, respectivamente.</p></li>
<li><p>En Python sería:</p>
<div class="sourceCode" id="cb65"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>fib_iter <span class="op">=</span> <span class="kw">lambda</span> cont, a, b: a <span class="cf">if</span> cont <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> fib_iter(cont <span class="op">-</span> <span class="dv">1</span>, b, a <span class="op">+</span> b)</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>fib <span class="op">=</span> <span class="kw">lambda</span> n: fib_iter(n, <span class="dv">0</span>, <span class="dv">1</span>)</span></code></pre></div></li>
<li><p>Esta función genera un proceso iterativo lineal, por lo que es
mucho más eficiente.</p></li>
</ul>
</section>

<section id="recursividad-final-y-no-final"
class="title-slide slide level3" data-number="4.2.7">
<h3 data-number="4.2.7"><span class="header-section-number">4.2.7</span>
Recursividad final y no final</h3>
<ul>
<li><p>Lo que diferencia al <code
class="sourceCode python">fact_iter</code> que genera un proceso
iterativo del <code class="sourceCode python">factorial</code> que
genera un proceso recursivo, es el hecho de que <code
class="sourceCode python">fact_iter</code> se llama a sí misma y
devuelve directamente el valor que le ha devuelto su llamada recursiva
sin hacer luego nada más.</p>
<p>En cambio, <code class="sourceCode python">factorial</code> tiene que
hacer una multiplicación después de llamarse a sí misma y antes de
terminar de ejecutarse:</p>
<div class="sourceCode" id="cb66"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Versión con recursividad final:</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>fact_iter <span class="op">=</span> <span class="kw">lambda</span> cont, acc: acc <span class="cf">if</span> cont <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="op">\</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>                              fact_iter(cont <span class="op">-</span> <span class="dv">1</span>, acc <span class="op">*</span> cont)</span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>fact <span class="op">=</span> <span class="kw">lambda</span> n: fact_iter(n, <span class="dv">1</span>)</span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Versión con recursividad no final:</span></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a>factorial <span class="op">=</span> <span class="kw">lambda</span> n: <span class="dv">1</span> <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> n <span class="op">*</span> factorial(n <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.7.0.1">

<ul>
<li><p>Es decir:</p>
<ul>
<li><p><code class="sourceCode python">fact_iter(cont, acc)</code>
simplemente llama a:</p>
<p><code
class="sourceCode python">fact_iter(cont <span class="op">-</span> <span class="dv">1</span>, acc <span class="op">*</span> cont)</code></p>
<p>y luego devuelve directamente el valor que le entrega ésta llamada,
sin hacer ninguna otra operación posterior antes de terminar.</p></li>
<li><p>En cambio, <code class="sourceCode python">factorial(n)</code>
hace:</p>
<p><code
class="sourceCode python">n <span class="op">*</span> factorial(n <span class="op">-</span> <span class="dv">1</span>)</code></p>
<p>o sea, se llama a sí misma pero el resultado de la llamada recursiva
tiene que multiplicarlo luego por <code
class="sourceCode python">n</code> antes de devolver el resultado
final.</p></li>
</ul></li>
<li><p>Por tanto, <strong>lo último que hace <code
class="sourceCode python">fact_iter</code> es llamarse a sí
misma</strong>. En cambio, lo último que hace <code
class="sourceCode python">factorial</code> no es llamarse a sí misma,
porque tiene que hacer más operaciones (en este caso, la multiplicación)
antes de devolver el resultado.</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.7.0.2">

<ul>
<li><p>Cuando lo último que hace una función recursiva es llamarse a sí
misma y devolver directamente el valor devuelto por esa llamada
recursiva, decimos que la función es <strong>recursiva final</strong> o
que tiene <strong>recursividad final</strong>.</p></li>
<li><p>En caso contrario, decimos que la función es <strong>recursiva no
final</strong> o que tiene <strong>recursividad no
final</strong>.</p></li>
<li><p><strong>Las funciones recursivas finales generan procesos
iterativos.</strong></p></li>
<li><p>La función <code>fact_iter</code> es recursiva final, y por eso
genera un proceso iterativo.</p></li>
<li><p>En cambio, la función <code>factorial</code> es recursiva no
final, y por eso genera un proceso recursivo.</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.2.7.0.3">

<ul>
<li><p>En la práctica, para que un proceso iterativo consuma realmente
una cantidad constante de memoria, es necesario que el traductor
<strong>optimice la recursividad final</strong>.</p></li>
<li><p>Ese tipo de optimización se denomina <strong><em>tail-call
optimization (TCO)</em></strong>.</p></li>
<li><p>No muchos traductores optimizan la recursividad final.</p></li>
<li><p>De hecho, ni el intérprete de Python ni la máquina virtual de
Java optimizan la recursividad final.</p></li>
<li><p>Por tanto, en estos dos lenguajes, las funciones recursivas
finales consumen tanta memoria como las no finales.</p></li>
</ul>
</section>


<section id="tipos-de-datos-recursivos" class="title-slide slide level2"
data-number="4.3">
<h2 data-number="4.3"><span class="header-section-number">4.3</span>
Tipos de datos recursivos</h2>

</section>
<section id="concepto" class="title-slide slide level3"
data-number="4.3.1">
<h3 data-number="4.3.1"><span class="header-section-number">4.3.1</span>
Concepto</h3>
<ul>
<li><p>Un <strong>tipo de dato recursivo</strong> es aquel que puede
definirse en términos de sí mismo.</p></li>
<li><p>Un <strong>dato recursivo</strong> es un dato que pertenece a un
tipo recursivo. Por tanto, es un dato que se construye sobre otros datos
del mismo tipo.</p></li>
<li><p>Como toda estructura recursiva, un tipo de dato recursivo tiene
casos base y casos recursivos:</p>
<ul>
<li><p>En los casos base, el tipo recursivo se define directamente, sin
referirse a sí mismo.</p></li>
<li><p>En los casos recursivos, el tipo recursivo se define sobre sí
mismo.</p></li>
</ul></li>
<li><p>La forma más natural de manipular un dato recursivo es usando
funciones recursivas.</p></li>
</ul>
</section>

<section id="cadenas" class="title-slide slide level3"
data-number="4.3.2">
<h3 data-number="4.3.2"><span class="header-section-number">4.3.2</span>
Cadenas</h3>
<ul>
<li><p>Las <strong>cadenas</strong> se pueden considerar <strong>tipos
de datos recursivos</strong>, ya que podemos decir que toda cadena <code
class="sourceCode python">c</code>:</p>
<ul>
<li><p>o bien es la cadena vacía <code
class="sourceCode python"><span class="st">&#39;&#39;</span></code>
(<em>caso base</em>),</p></li>
<li><p>o bien está formada por dos partes:</p>
<ul>
<li><p>El <strong>primer carácter</strong> de la cadena, al que se
accede mediante <code
class="sourceCode python">c[<span class="dv">0</span>]</code>.</p></li>
<li><p>El <strong>resto</strong> de la cadena (al que se accede mediante
<code class="sourceCode python">c[<span class="dv">1</span>:]</code>),
que también es una cadena (<em>caso recursivo</em>).</p></li>
</ul>
<p>En tal caso, se cumple que <code
class="sourceCode python">c <span class="op">==</span> c[<span class="dv">0</span>] <span class="op">+</span> c[<span class="dv">1</span>:]</code>.</p></li>
</ul></li>
<li><p>Eso significa que podemos acceder al segundo carácter de la
cadena (suponiendo que exista) mediante <code
class="sourceCode python">c[<span class="dv">1</span>:][<span class="dv">0</span>]</code>.</p>
<div class="sourceCode" id="cb67"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>cadena <span class="op">=</span> <span class="st">&#39;hola&#39;</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>cadena[<span class="dv">0</span>]       <span class="co"># devuelve &#39;h&#39;</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>cadena[<span class="dv">1</span>:]      <span class="co"># devuelve &#39;ola&#39;</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>cadena[<span class="dv">1</span>:][<span class="dv">0</span>]   <span class="co"># devuelve &#39;o&#39;</span></span></code></pre></div></li>
</ul>
</section>

<section id="tuplas" class="title-slide slide level3"
data-number="4.3.3">
<h3 data-number="4.3.3"><span class="header-section-number">4.3.3</span>
Tuplas</h3>
<ul>
<li><p>Las <strong>tuplas</strong> (datos de tipo <code
class="sourceCode python"><span class="bu">tuple</span></code>) son una
generalización de las cadenas.</p></li>
<li><p>Una tupla es una <strong>secuencia de elementos</strong> que no
tienen por qué ser caracteres, sino que cada uno de ellos pueden ser
<strong>de cualquier tipo</strong> (números, cadenas, booleanos, …,
incluso otras tuplas).</p></li>
<li><p>Los literales de tipo tupla se representan enumerando sus
elementos separados por comas y encerrados entre paréntesis.</p></li>
<li><p>Por ejemplo:</p>
<div class="sourceCode" id="cb68"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>tupla <span class="op">=</span> (<span class="dv">27</span>, <span class="st">&#39;hola&#39;</span>, <span class="va">True</span>, <span class="fl">73.4</span>, (<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>), <span class="dv">99</span>)</span></code></pre></div></li>
<li><p>Si sólo tiene un elemento, hay que poner una coma detrás:</p>
<div class="sourceCode" id="cb69"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>tupla <span class="op">=</span> (<span class="dv">35</span>,)</span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="4.3.3.0.1">

<ul>
<li><p>Las tuplas también pueden verse como un <strong>tipo de datos
recursivo</strong>, ya que toda tupla <code
class="sourceCode python">t</code>:</p>
<ul>
<li><p>o bien es la tupla vacía, representada mediante <code
class="sourceCode python">()</code> (<em>caso base</em>),</p></li>
<li><p>o bien está formada por dos partes:</p>
<ul>
<li><p>El <strong>primer elemento</strong> de la tupla (al que se accede
mediante <code
class="sourceCode python">t[<span class="dv">0</span>]</code>), que
hemos visto que puede ser de cualquier tipo.</p></li>
<li><p>El <strong>resto</strong> de la tupla (al que se accede mediante
<code class="sourceCode python">t[<span class="dv">1</span>:]</code>),
que también es una tupla (<em>caso recursivo</em>).</p></li>
</ul></li>
</ul></li>
<li><p>Según el ejemplo anterior:</p>
<div class="sourceCode" id="cb70"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> tupla <span class="op">=</span> (<span class="dv">27</span>, <span class="st">&#39;hola&#39;</span>, <span class="va">True</span>, <span class="fl">73.4</span>, (<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>), <span class="dv">99</span>)</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> tupla[<span class="dv">0</span>]</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a><span class="dv">27</span></span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> tupla[<span class="dv">1</span>:]</span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a>(<span class="st">&#39;hola&#39;</span>, <span class="va">True</span>, <span class="fl">73.4</span>, (<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>), <span class="dv">99</span>)</span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> tupla[<span class="dv">1</span>:][<span class="dv">0</span>]</span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a><span class="st">&#39;hola&#39;</span></span></code></pre></div></li>
</ul>
</section>
<section class="slide level5" data-number="4.3.3.0.2">

<ul>
<li><p>Junto a las operaciones <code
class="sourceCode python">t[<span class="dv">0</span>]</code> y <code
class="sourceCode python">t[<span class="dv">1</span>:]</code>, tenemos
también la operación <code>+</code> (<strong>concatenación</strong>), al
igual que ocurre con las cadenas.</p></li>
<li><p>Con la concatenación se pueden crear nuevas tuplas a partir de
otras tuplas.</p></li>
<li><p>Por ejemplo:</p>
<div class="sourceCode" id="cb71"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>) <span class="op">+</span> (<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>)</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>)</span></code></pre></div></li>
<li><p>Eso significa que, si <code class="sourceCode python">t</code> es
una tupla no vacía, se cumple que <br> <code
class="sourceCode python">t <span class="op">==</span> (t[<span class="dv">0</span>],) <span class="op">+</span> t[<span class="dv">1</span>:]</code>.</p>
<p>Esta propiedad es similar (aunque no exactamente igual) a la que se
cumple en las cadenas no vacías.</p></li>
</ul>
</section>

<section id="rangos" class="title-slide slide level3"
data-number="4.3.4">
<h3 data-number="4.3.4"><span class="header-section-number">4.3.4</span>
Rangos</h3>
<ul>
<li><p>Los rangos (datos de tipo <code
class="sourceCode python"><span class="bu">range</span></code>) son
valores que representan <strong>sencuencias de números
enteros</strong>.</p></li>
<li><p>Los rangos se crean con la función <code
class="sourceCode python"><span class="bu">range</span></code>, cuya
signatura es:</p>
<div class="caja">
<p><span
class="math inline">\texttt{range(\([\)\(start\):\,int,\(]\)\;\(stop\):\,int\;\([\),\;\(step\):\,int\(]\))\;-&gt;\;range}</span></p>
</div></li>
<li><p>Cuando se omite <em>start</em>, se entiende que es <code
class="sourceCode python"><span class="dv">0</span></code>.</p></li>
<li><p>Cuando se omite <em>step</em>, se entiende que es <code
class="sourceCode python"><span class="dv">1</span></code>.</p></li>
<li><p>El valor de <em>stop</em> no se alcanza nunca.</p></li>
<li><p>Cuando <em>start</em> y <em>stop</em> son iguales, representa el
<em>rango vacío</em>.</p></li>
<li><p><em>step</em> debe ser siempre distinto de cero.</p></li>
<li><p>Cuando <em>start</em> es mayor que <em>stop</em>, el valor de
<em>step</em> debería ser negativo. En caso contrario, también
representaría el rango vacío.</p></li>
</ul>
</section>
<section id="ejemplos-1" class="slide level5 unnumbered unlisted">
<h5 class="unnumbered unlisted">Ejemplos</h5>
<ul>
<li><p><code
class="sourceCode python"><span class="bu">range</span>(<span class="dv">10</span>)</code>
representa la secuencia <span class="math inline">0, 1, 2, \ldots,
9</span>.</p></li>
<li><p><code
class="sourceCode python"><span class="bu">range</span>(<span class="dv">3</span>, <span class="dv">10</span>)</code>
representa la secuencia <span class="math inline">3, 4, 5, \ldots,
9</span>.</p></li>
<li><p><code
class="sourceCode python"><span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">2</span>)</code>
representa la secuencia <span class="math inline">0, 2, 4, 6,
8</span>.</p></li>
<li><p><code
class="sourceCode python"><span class="bu">range</span>(<span class="dv">4</span>, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>)</code>
representa la secuencia <span class="math inline">4, 3, 2,
1</span>.</p></li>
<li><p><code
class="sourceCode python"><span class="bu">range</span>(<span class="dv">3</span>, <span class="dv">3</span>)</code>
representa el rango vacío.</p></li>
<li><p><code
class="sourceCode python"><span class="bu">range</span>(<span class="dv">4</span>, <span class="dv">3</span>)</code>
también representa el rango vacío.</p></li>
</ul>
</section>
<section class="slide level5" data-number="4.3.4.0.1">

<ul>
<li>La <strong>forma normal</strong> de un rango es una expresión en la
que se llama a la función <code
class="sourceCode python"><span class="bu">range</span></code> con los
argumentos necesarios para construir el rango:</li>
</ul>
<div class="columns">
<div class="column">
<div class="sourceCode" id="cb72"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">range</span>(<span class="dv">2</span>, <span class="dv">3</span>)</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a><span class="bu">range</span>(<span class="dv">2</span>, <span class="dv">3</span>)</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">range</span>(<span class="dv">4</span>)</span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a><span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">4</span>)</span></code></pre></div>
</div><div class="column">
<div class="sourceCode" id="cb73"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">range</span>(<span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">1</span>)</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a><span class="bu">range</span>(<span class="dv">2</span>, <span class="dv">5</span>)</span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">range</span>(<span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">2</span>)</span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a><span class="bu">range</span>(<span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">2</span>)</span></code></pre></div>
</div>
</div>
<ul>
<li><p>El <strong>rango vacío</strong> es un valor que no tiene
expresión canónica, ya que cualquiera de las siguientes expresiones
representan al rango vacío tan bien como cualquier otra:</p>
<ul>
<li><p><code
class="sourceCode python"><span class="bu">range</span>(<span class="dv">0</span>)</code>.</p></li>
<li><p><code
class="sourceCode python"><span class="bu">range</span></code><code>(</code><span
class="math inline">a</span><code>,</code><span
class="math inline">\;a</span><code>)</code>, donde <em>a</em> es
cualquier entero.</p></li>
<li><p><code
class="sourceCode python"><span class="bu">range</span></code><code>(</code><span
class="math inline">a</span><code>,</code><span
class="math inline">\;b</span><code>,</code><span
class="math inline">\;c</span><code>)</code>, donde <span
class="math inline">a \geq b</span> y <span class="math inline">c &gt;
0</span>.</p></li>
<li><p><code
class="sourceCode python"><span class="bu">range</span></code><code>(</code><span
class="math inline">a</span><code>,</code><span
class="math inline">\;b</span><code>,</code><span
class="math inline">\;c</span><code>)</code>, donde <span
class="math inline">a \leq b</span> y <span class="math inline">c &lt;
0</span>.</p></li>
</ul></li>
</ul>
<div class="sourceCode" id="cb74"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">range</span>(<span class="dv">3</span>, <span class="dv">3</span>) <span class="op">==</span> <span class="bu">range</span>(<span class="dv">4</span>, <span class="dv">4</span>)</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a><span class="va">True</span></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">range</span>(<span class="dv">4</span>, <span class="dv">3</span>) <span class="op">==</span> <span class="bu">range</span>(<span class="dv">3</span>, <span class="dv">4</span>, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a><span class="va">True</span></span></code></pre></div>
</section>
<section class="slide level5" data-number="4.3.4.0.2">

<ul>
<li><p>Los rangos también pueden verse como un <strong>tipo de datos
recursivo</strong>, ya que todo rango <code
class="sourceCode python">r</code>:</p>
<ul>
<li><p>o bien es el rango vacío (<em>caso base</em>),</p></li>
<li><p>o bien está formado por dos partes:</p>
<ul>
<li><p>El <strong>primer elemento</strong> del rango (al que se accede
mediante <code
class="sourceCode python">r[<span class="dv">0</span>]</code>), que
hemos visto que tiene que ser un número entero.</p></li>
<li><p>El <strong>resto</strong> del rango (al que se accede mediante
<code class="sourceCode python">r[<span class="dv">1</span>:]</code>),
que también es un rango (<em>caso recursivo</em>).</p></li>
</ul></li>
</ul></li>
<li><p>Según el ejemplo anterior:</p>
<div class="sourceCode" id="cb75"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> rango <span class="op">=</span> <span class="bu">range</span>(<span class="dv">4</span>, <span class="dv">7</span>)</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> rango[<span class="dv">0</span>]</span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a><span class="dv">4</span></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> rango[<span class="dv">1</span>:]</span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a><span class="bu">range</span>(<span class="dv">5</span>, <span class="dv">7</span>)</span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> rango[<span class="dv">1</span>:][<span class="dv">0</span>]</span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a><span class="dv">5</span></span></code></pre></div></li>
</ul>
</section>

<section id="conversión-a-tupla" class="title-slide slide level3"
data-number="4.3.5">
<h3 data-number="4.3.5"><span class="header-section-number">4.3.5</span>
Conversión a tupla</h3>
<ul>
<li>Las cadenas y los rangos se pueden convertir fácilmente a tuplas
usando la función <code
class="sourceCode python"><span class="bu">tuple</span></code>:</li>
</ul>
<div class="columns">
<div class="column" style="width:40%;">
<div class="sourceCode" id="cb76"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">tuple</span>(<span class="st">&#39;hola&#39;</span>)</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>(<span class="st">&#39;h&#39;</span>, <span class="st">&#39;o&#39;</span>, <span class="st">&#39;l&#39;</span>, <span class="st">&#39;a&#39;</span>)</span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">tuple</span>(<span class="st">&#39;&#39;</span>)</span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>()</span></code></pre></div>
</div><div class="column" style="width:60%;">
<div class="sourceCode" id="cb77"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">tuple</span>(<span class="bu">range</span>(<span class="dv">10</span>))</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>)</span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">tuple</span>(<span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">11</span>))</span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">10</span>)</span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">tuple</span>(<span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">30</span>, <span class="dv">5</span>))</span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a>(<span class="dv">0</span>, <span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">15</span>, <span class="dv">20</span>, <span class="dv">25</span>)</span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">tuple</span>(<span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">3</span>))</span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a>(<span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">6</span>, <span class="dv">9</span>)</span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">tuple</span>(<span class="bu">range</span>(<span class="dv">0</span>, <span class="op">-</span><span class="dv">10</span>, <span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb77-10"><a href="#cb77-10" aria-hidden="true" tabindex="-1"></a>(<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">3</span>, <span class="op">-</span><span class="dv">4</span>, <span class="op">-</span><span class="dv">5</span>, <span class="op">-</span><span class="dv">6</span>, <span class="op">-</span><span class="dv">7</span>, <span class="op">-</span><span class="dv">8</span>, <span class="op">-</span><span class="dv">9</span>)</span>
<span id="cb77-11"><a href="#cb77-11" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">tuple</span>(<span class="bu">range</span>(<span class="dv">0</span>))</span>
<span id="cb77-12"><a href="#cb77-12" aria-hidden="true" tabindex="-1"></a>()</span>
<span id="cb77-13"><a href="#cb77-13" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">tuple</span>(<span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">0</span>))</span>
<span id="cb77-14"><a href="#cb77-14" aria-hidden="true" tabindex="-1"></a>()</span></code></pre></div>
</div>
</div>
</section>

</section>
<section id="bibliografía"
class="title-slide slide level1 unnumbered unlisted">
<h1 class="unnumbered unlisted">Bibliografía</h1>
<div id="refs" class="references csl-bib-body hanging-indent"
data-entry-spacing="0" role="list">
<div id="ref-abelson_structure_1996" class="csl-entry" role="listitem">
Abelson, Harold, Gerald Jay Sussman, and Julie Sussman. 1996.
<em>Structure and Interpretation of Computer Programs</em>. 2nd ed.
Cambridge, Mass. : New York: MIT Press ; McGraw-Hill.
</div>
</div>
</section>
    </div>
  </div>

  <script src="./reveal.js/dist/reveal.js"></script>

  <!-- reveal.js plugins -->
  <script src="./reveal.js/plugin/notes/notes.js"></script>
  <script src="./reveal.js/plugin/search/search.js"></script>
  <script src="./reveal.js/plugin/zoom/zoom.js"></script>
  <script src="./reveal.js/plugin/reveal.js-menu/menu.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
        // Display controls in the bottom right corner
        controls: true,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: true,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'bottom-right',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: true,

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: false,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'default',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: true,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'slide',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'fade',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1280,

        height: 1080,
        // The display mode that will be used to show slides
        display: 'block',

        menu: {
          hideMissingTitles: true,
        },

        dependencies: [
          { src: './reveal.js/plugin/reveal.js-quiz/quiz/js/quiz.js', async: true, callback: function() { prepareQuizzes({preventUnanswered: true, checkAnswerText: 'Comprueba la respuesta', nextQuestionText: 'Siguiente &raquo;', backButtonText: '&laquo; Anterior', tryAgainText: 'Prueba de nuevo', preventUnansweredText: 'Selecciona una respuesta', questionCountText: 'Pregunta %current de %total', skipStartButton: true}); } }
        ],

        // reveal.js plugins
        plugins: [
          RevealMenu,
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    <script type="text/javascript">
       var title = document.getElementsByClassName('title')[0];
       title = title != null ? title.innerHTML : '';
       var author = document.getElementsByClassName('author')[0];
       author = author != null ? author.innerHTML : '';
       var date = document.getElementsByClassName('date')[0];
       date = date != null ? date.innerHTML : '';
       document.getElementById('header-left').innerHTML = '<a href="#/title-slide">' + title + '</a>';
       document.getElementById('footer-left').innerHTML = '<a href="https://pro.iesdonana.org">&copy; ' + author + ' (' + date + ')</a>';

       function updateHeader(nd) {
           var hr = document.getElementById('header-right');
           while (hr.children.length > 0) {
               hr.removeChild(hr.lastChild);
           }
           buscar(nd, 3, hr);
           buscar(nd, 2, hr);
           buscar(nd, 1, hr);
           hr.style.fontSize = Math.round(50 * Reveal.getScale()) + '%';
           hr.style.fontSize = Math.max(Number.parseInt(getComputedStyle(hr).fontSize), 12) + 'px';
           var hl = document.getElementById('header-left');
           hl.style.fontSize = hr.style.fontSize;
       }

       function buscar(nd, level, hr) {
           if (!nd.classList.contains('level' + (level - 1))) {
               for (var n = nd; n != null; n = n.previousSibling) {
                   if (n.nodeType == Node.TEXT_NODE) {
                       continue;
                   }
                   var cl = n.classList;
                   if (cl.contains('level' + level)) {
                       var h = n.querySelector('h' + level);
                   } else if (cl.contains('level' + (level - 1))) {
                       break;
                   } else {
                       continue;
                   }
                   if (h == null || Reveal.getCurrentSlide().id == 'title-slide') {
                       hr.innerHTML = '';
                   } else {
                       var el = document.createElement('a');
                       var href = '#/' + n.id;
                       el.href = href;
                       el.innerHTML = h.innerHTML;
                       var a = el.querySelector('a');
                       if (a !== null) {
                           a.href = href;
                       }
                       if (hr.innerHTML != '') {
                           hr.innerHTML = ' &mdash; ' + hr.innerHTML;
                       }
                       hr.insertBefore(el, hr.firstChild);
                   }
                   break;
               }
           }
       }

       // On Reveal.js ready event, copy header/footer <div>
       // into each `.slide-background` <div>
       Reveal.on('ready', event => {
           var header = document.getElementById('header');
           document.querySelector('.reveal').appendChild(header);
           updateHeader(Reveal.getCurrentSlide());
       });

       Reveal.on('slidechanged', event => {
           // event.previousSlide, event.currentSlide, event.indexh, event.indexv
           updateHeader(event.currentSlide);
       });
    </script>
    </body>
</html>
